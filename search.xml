<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ChatGPT原理笔记</title>
      <link href="/2023/05/18/chatgpt-yuan-li/"/>
      <url>/2023/05/18/chatgpt-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="1-ChatGPT与NLP"><a href="#1-ChatGPT与NLP" class="headerlink" title="1 ChatGPT与NLP"></a>1 ChatGPT与NLP</h3><p>ChatGPT（Chat Generative Pre-training Transformer）属于自然语言处理（Natural Language Processing）领域中的对话系统</p><h4 id="ChatGPT的建模方式"><a href="#ChatGPT的建模方式" class="headerlink" title="ChatGPT的建模方式"></a>ChatGPT的建模方式</h4><p>生成式（Generative ）：</p><ol><li><p>输入1 -》 ChatGPT -》输出1</p></li><li><p>输入1、输出1，输入2 -》 ChatGPT -》 输出2</p></li><li><p>。。。</p></li></ol><p>一次生成一个字</p><h4 id="NLP的发展历史"><a href="#NLP的发展历史" class="headerlink" title="NLP的发展历史"></a>NLP的发展历史</h4><p><strong>1.基于规则的NLP</strong></p><p>基于规则的 NLP，是指使用人工编写的规则来处理自然语言</p><p>输入：I love you</p><p>规则： 定义一个单词映射的规则：I -》 you， you -》I</p><p>输出：you love I</p><p>缺点：人工</p><p><strong>2.基于统计的NLP</strong></p><p>基于统计的 NLP 则是利用机器学习算法从大量的语料库中学习自然语言的规律特征</p><p>基本特点：</p><blockquote><p>标注数据 =&gt; 建立模型、确定输入输出 =&gt; 训练模型 =&gt; 利用已训练好的模型进行工作</p></blockquote><p>例子：对样本数据进行计算回归方程</p><p>核心：模型参数</p><p>ChatGPT 采用预训练（ Pre-training <strong>）</strong> 技术来完成基于统计的 NLP 模型学习</p><p>缺点：黑盒，规则隐性，体现在参数中</p><p><strong>3.基于强化学习的NLP</strong></p><p>ChatGPT 模型是基于统计的，然而它又利用了新的方法，带人工反馈的强化学习（Reinforcement Learning with Human Feedback，RLHF）</p><p>理解：反射机制，模型产生预期的行为，给予正反馈，非预期行为，给予负反馈</p><h4 id="NLP技术的发展脉络"><a href="#NLP技术的发展脉络" class="headerlink" title="NLP技术的发展脉络"></a>NLP技术的发展脉络</h4><p>基于规则、统计、强化学习，更是一种思想，往往在同一模型中都有体现</p><blockquote><p>基于规则：家长手把手教孩子怎么解一道题</p><p>基于统计：教解题方法</p><p>基于强化学习：只定目标，考到90分就行，孩子怎么做到的，不管 </p></blockquote><h4 id="ChatGPT的神经网络结构-Transformer"><a href="#ChatGPT的神经网络结构-Transformer" class="headerlink" title="ChatGPT的神经网络结构 Transformer"></a>ChatGPT的神经网络结构 Transformer</h4><p>文字（输入） —&gt;  Transformer –&gt; 文字（输出）</p><p>Transformer 的核心是<strong>自注意力机制</strong>（Self-Attention），处理输入的文字序列时，每一个字符以及它们的位置都是一个向量，当关注某一个位置的字符时，可以通过向量计算的方式，得到当前字符与其他字符的关系，而且计算可以并行完成</p><h3 id="2-从GPT1-0到ChatGPT"><a href="#2-从GPT1-0到ChatGPT" class="headerlink" title="2 从GPT1.0到ChatGPT"></a>2 从GPT1.0到ChatGPT</h3><p>整体发展脉络：朝着拟人化的方向在发展</p><h4 id="GPT初代"><a href="#GPT初代" class="headerlink" title="GPT初代"></a>GPT初代</h4><p>GPT和Bert、ELMO等模型，将NLP带入了大规模神经网络语言模型（Large Language Model, LLM）时代</p><p><strong>GPT的语言建模</strong></p><p>初代GPT能做什么？</p><blockquote><p>补全：特朗普是中国人民的好__ __ ？</p></blockquote><p>可以是：朋友、 老师等等</p><p>GPT 初代所做的事情：将一个句子分为两个部分，分析句子的上下文，基于上半部分，补全下半部分</p><p><strong>语言的编解码</strong></p><p>文字输入 —&gt; ChatGPT –&gt; 文字输出</p><p>输入需要处理成模型所能理解的语言，输出需要从模型的语言转化为人类能够理解的原研</p><p>输入 —&gt;（Encode）—&gt;  ChatGPT – &gt; (Decode) –&gt; 输出</p><h4 id="GPT-2"><a href="#GPT-2" class="headerlink" title="GPT-2"></a>GPT-2</h4><p>从 “根据上文补全下文” —&gt; 多任务学习者（开始走向泛化，一脑多用）</p><h4 id="GPT-3"><a href="#GPT-3" class="headerlink" title="GPT-3"></a>GPT-3</h4><p><strong>大模型中的大模型</strong></p><p>GPT-3 里的大模型计算量是 GPT-1 的上千倍</p><p>训练数据足够大，模型的参数量才够大，才有可能足够智能</p><blockquote><p>参数量就好比人脑中的神经元，神经元数量足够多，才有可能具有更高的智能</p></blockquote><p><strong>对话模式</strong></p><p>GPT 系列模型都是采用 decoder 解码器结构进行训练的，也就是更加适合文本生成的形式。即输入一句话，输出也是一句话。这被称之为对话模式</p><p><strong>小样本学习（Few-Shots）</strong></p><p>人工标注样子数据成本极高</p><p>GPT3 就提出了小样本学习的概念，简单来讲，就是让模型学习语言时，不需要那么多的样例数据。</p><h4 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h4><p>ChatGPT 模型结构上和之前的几代都没有太大变化，主要变化的是训练策略变了。</p><p><strong>强化学习</strong></p><p>环境模型（Reward 模型）：</p><ol><li> ChatGPT 会针对某一个问题，生成一个回答</li><li>环境模型会对 ChatGPT 生成的答案做评价，评价一个分值出来（如 10 分、3 分等等，高分代表奖励，低分代表惩罚），而不具体给出标准答案</li><li>ChatGPT 接收到评价反馈后，可以根据这个数值做模型的进一步训练，朝着生成更加恰当答案的方向拟合。</li></ol><h3 id="3-ChatGPT是一个语言模型"><a href="#3-ChatGPT是一个语言模型" class="headerlink" title="3 ChatGPT是一个语言模型"></a>3 ChatGPT是一个语言模型</h3><p>语言模型：由计算机来实现类似于人的语言交流、对话、叙述能力，它集中体现在模型能够依赖上下文进行正确的文字输出</p><h4 id="ChatGPT语言模型的数学建模"><a href="#ChatGPT语言模型的数学建模" class="headerlink" title="ChatGPT语言模型的数学建模"></a>ChatGPT语言模型的数学建模</h4><p><strong>语言模型的基础建模</strong></p><p>语言模型的建模公式可以表示为：</p><p>P(w1, w2,…. , wi) = P(w1) * P(w2 | w1) *  P(w3 | w1,w2)  * … * P(wi | w1,w2… w(i-1))</p><p>P(wi)表示字符wi在语料库中出现的概率，P(wi | w1,w2… w(i-1))表示在已知前面字符的情况下，字符 wi 出现的概率，即依赖上文，对下文的预测。把每一个字符都按照此方式预测出来，其结果就是整条语句的出现概率。</p><blockquote><p>补全：特朗普是中国人民的好__ __ ？</p></blockquote><p>如何补全上面这句话？</p><p>方案1： 假设汉字一共有一万个，其中 一、朋、老 这三个汉字在训练材料中出现的概率分别为0.0005，0.0001，0.00002，当随机在好后面填入一个字符时，一的概率最大，老概率次之，朋概率最小</p><p>问题：只考虑了汉字出现的概率，没有考虑上下文</p><p>方案2：依据上下文的条件概率公式</p><p>P（朋|特朗普是中国人民的好） = P（特朗普是中国人民的好朋）/  P（特朗普是中国人民的好） = 假设等于0.5</p><p>P（友|特朗普是中国人民的好朋） = P（特朗普是中国人民的好朋友）/  P（特朗普是中国人民的好朋） = 假设等于0.8</p><p><strong>N-gram的语言建模</strong></p><p>过长的文本会导致条件概率太过复杂的问题，所以一般只考虑某个位置附近的上下文</p><p>N-gram：就近考虑距离第i个字符，N个距离以内的字符</p><p>则P(wi | w1,w2… w(i-1)) 简化为 P(wi | w(i-n+1), w(i-n+2),… w(i-1)) </p><p><strong>语言log化</strong></p><p>概率都是小于等于1的，P(w1, w2,…. , wi) = P(w1) * P(w2 | w1) *  P(w3 | w1,w2)  * … * P(wi | w1,w2… w(i-1)) 的连乘会导致乘积越小，最终小数位越来越多，计算机无法处理太多小数位</p><p>所以要对上面的公式做log运算</p><p>log（P(w1, w2,…. , wi)） = ∑(i)log(P(wi | w1,w2… w(i-1)))</p><p>考虑到N-gram</p><p>简化为：log（P(w1, w2,…. , wi)） = ∑(i)log(P(wi | w(i-n+1), w(i-n+2),… w(i-1)))</p><h4 id="ChatGPT的语言模型"><a href="#ChatGPT的语言模型" class="headerlink" title="ChatGPT的语言模型"></a>ChatGPT的语言模型</h4><p><strong>ChatGPT的建模公式</strong></p><p>ChatGPT的建模公式本质上还是log（P(w1, w2,…. , wi)） = ∑(i)log(P(wi | w(i-n+1), w(i-n+2),… w(i-1)))</p><p>w1, w2,…. , wi定义U</p><p>考虑到模型的大量参数集合Θ</p><p>则公式变为 log（P(U） = ∑(i)log(P(wi | w(i-n+1), w(i-n+2),… w(i-1))，Θ )</p><p><strong>语言模型中的最大似然概率</strong></p><p>log（P(w1, w2,…. , wi)）就是一种最大似然的建模方式。</p><p>最大似然估计：通过有代表性的样本去估计总体</p><p>总体：人类全部的文字集合</p><p>样本：GPT的训练样本</p><p><strong>ChatGPT语言模型的训练方法</strong></p><p>目标：当能够根据上文，来对下文进行预测</p><p>输入：特朗普是中国人民的好</p><p>输出：P(朋)=0.5，P(老)=0.3，P(总)=0.2</p><p>根据最大似然估计原则，在好后面最大概率的文字是 ”朋“</p><p>重复这一过程，最终得到输出：特朗普是中国人民的好朋友</p><p>其本质就是在让模型学会文字接龙的游戏，以最大似然的准则来约束模型</p><h3 id="4-ChatGPT如何处理文字输入"><a href="#4-ChatGPT如何处理文字输入" class="headerlink" title="4 ChatGPT如何处理文字输入"></a>4 ChatGPT如何处理文字输入</h3><p>  文字 –&gt; (BPE) –&gt; token –&gt; （embedding） –&gt; tensor –&gt; ChatGPT –&gt; tensor –&gt; （选词） –&gt; token –&gt; (逆BPE) –&gt; 输出</p><h4 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h4><p>Tokenizer ： 文本 –&gt; token –&gt; 文本 的过程</p><p><strong>BPE（Byte Pair Encoding）算法</strong></p><p>BPE 算法是根据一份 token 词表（Vocabulary），将输入的文本拆解成若干个 token</p><p>（基于字符）</p><p><strong>Byte-level BPE 算法</strong></p><p>字符–&gt;Unicode编码</p><p>（基于字节）</p><p>Unicode编码数量，基于字符形式构造词表，Vocabulary会非常庞大。而Byte-level BPE 算法 直接操作字节，字节数一共才256，这样能够使得Vocabulary大大减少，但同时也会时候sequence 变得庞大</p><p><strong>BPE词表如何训练得到</strong></p><p>根据训练文本语料统计</p><p>贪心算法：把最常见的一对相邻数据单替换为该数据中没有出现过的一个新单位，反复迭代直到满足停止条件</p><p><strong>Tokenizer的好处</strong></p><p>克服长尾效应：BPE词表的生成算法决定了，高频词高概率在词表中，低频词更低概率在词表中</p><p>多语言支持：基于Unicode或基于Unicode字节</p><h4 id="词嵌入-Embedding"><a href="#词嵌入-Embedding" class="headerlink" title="词嵌入(Embedding)"></a>词嵌入(Embedding)</h4><p>token –&gt; tensor(张量)这个过程叫做embedding</p><p>tensor(张量)即 多维数组 ，如 a= [ [1.23, 1.231,2.31], [554.44 ,45.2,54 .3] ] 就是一个（2，3）的张量</p><p>假设 token 词表（Vocabulary）的数量总共为 N，每一个 token 都用一个 M 维的浮点数张量表示，其中每一个 token 都对应了一行张量，即该 token 的 embedding 表示。</p><p>#token→ [0.103,0.034,0.129,−0.219,−0.156,…,0.0284,−0.172]</p><p>则所有的词表组成了一个N* × <em>M</em>维度的张量 UW(e)</p><p>一个序列中文字的位置信息也很重要，所以需要一张表示位置信息的张量（Position Embedding）,W(p)</p><p>ChatGPT具备多轮对话能力，需要将每轮对话需要分割开，，每一轮对话都是一个segment，每一个segment有多个token，这些token具有相同的segment embedding</p><p>所以，embedding(Input) = embedding(token)  + embedding(position)  +embedding(segment) </p><p><strong>embedding的好处</strong></p><p>1.embedding 将文字对应的 token 转换为抽象的固定维度的张量，可进行矩阵运算的那种，基于数学运算的大规模神经网络成为了可能</p><p>2.Embedding 建立了自然语言的语义与数学之间的关联关系：两个向量余弦距离越小，向量表示的文字语义越近</p><h3 id="5-Attention注意力机制"><a href="#5-Attention注意力机制" class="headerlink" title="5 Attention注意力机制"></a>5 Attention注意力机制</h3><p> 注意力机制：从输入的信息中，重点关注重要信息，忽略不重要的信息</p><h4 id="注意力机制的建模"><a href="#注意力机制的建模" class="headerlink" title="注意力机制的建模"></a>注意力机制的建模</h4><p><strong>建立权重模式</strong></p><p>若想要模型更加关注到某个字，则可给这个字更高的权重</p><p>假设ei表示第i个token的embedding，wi是第i个token的权重，则可对所有token的embedding做一个加权：</p><p>h = ∑(i) wi * ei</p><p><strong>softmax函数</strong></p><p>wi是一个标量，假设经过计算后得到 w = (w1,w2,…,wn) = (1, -2.2, …, -0.1) </p><p>对w向总和为1的概率值进行转换</p><p>αi = exp(wi)/∑(i)exp(wi)</p><p>模型的所有 embedding 加权后的权重</p><p>h= ∑(i) αi * ei</p><p><strong>自注意力机制</strong></p><p>如何计算w：自注意力机制（Self-Attention）</p><p>假设对第i个token，有两个向量qi、ki，其权重wi=qi*ki，</p><p>最简单的方式：当前token的embedding为q，把其他token的embedding当作k，二者相乘 —— 相当于是在比较当前token和其他token的关联关系</p><p>相乘的结果做归一化（除以维度dp的根号），再执行softmax操作</p><p>Attention(Q，K，V) = softmax(Q*K/根号dq)*V</p><p>实际情况：Q<em>、</em>K<em>、</em>V* 三个模型矩阵都是由 token embedding 矩阵做一个矩阵变换得到的。</p><p>Q = Wq * ei， K = Wk * ei， V = Wv * ei， </p><p>Wq，Wk，Wv神经网络模型扩展的可训练参数</p><h4 id="注意力机制的好处"><a href="#注意力机制的好处" class="headerlink" title="注意力机制的好处"></a>注意力机制的好处</h4><p>解决长文本依赖：注意力机制能够跨越很多个token，找到目标token和关联token</p><p>支持并行计算</p><h3 id="6-transformer结构"><a href="#6-transformer结构" class="headerlink" title="6 transformer结构"></a>6 transformer结构</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/transformer.png"></p><h4 id="transFormer结构"><a href="#transFormer结构" class="headerlink" title="transFormer结构"></a>transFormer结构</h4><p><strong>稀疏 Transformer</strong></p><p>Sparse Transformer 的核心是 Sparse Self-Attention （稀疏自注意力机制）</p><p>： 只选择部分token计算权重</p><p>可以有效减少计算</p><p><strong>稀疏 Transformer 原理</strong></p><p><em>S</em>14=(0,1,2,3,5,7,10,13) 表示 计算第14个位置的token时，只计算括号内的索引位置的token</p><p>则K和V的运算相应的也只计算索引位置</p><p><strong>多头（multi-head）注意力机制</strong></p><p>稀疏 Transformer存在某些token信息丢失的问题，可以通过多头注意力机制，多计算几次，综合多次计算的结果</p><p><strong>Normalization 正规化</strong></p><p>x-μ/标准差</p><p><strong>Dropout 机制</strong></p><p>假设 Attention 层输出了一组 token 矩阵，模型经过一个完全随机的 dropout 之后，其结果中的某些元素就被置为 0，防止过拟合（Overfitting）</p><p><strong>ResNet 残差模块</strong></p><p>Attention 模块的输入 embed 和输出结果有一个叠加，这种叠加操作被称为残差模块。之所以这么操作，主要是为了方便模型的训练过程中，梯度不会消失或爆炸</p><p><strong>Linear Feed-forward 全连接层</strong></p><p>为模型增加参数，增强模型的拟合能力</p><h3 id="7-Encoder-Decoder"><a href="#7-Encoder-Decoder" class="headerlink" title="7 Encoder-Decoder"></a>7 Encoder-Decoder</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>普通心理学</title>
      <link href="/2023/04/12/pu-tong-xin-li-xue/"/>
      <url>/2023/04/12/pu-tong-xin-li-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-心理学的研究对象和方法"><a href="#第一章-心理学的研究对象和方法" class="headerlink" title="第一章 心理学的研究对象和方法"></a>第一章 心理学的研究对象和方法</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E7%A0%94%E7%A9%B6%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95.png"></p><h3 id="第二章-心理的神经生理机制"><a href="#第二章-心理的神经生理机制" class="headerlink" title="第二章 心理的神经生理机制"></a>第二章 心理的神经生理机制</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E5%BF%83%E7%90%86%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%94%9F%E7%90%86%E6%9C%BA%E5%88%B6.png"></p><h3 id="第三章-感觉"><a href="#第三章-感觉" class="headerlink" title="第三章 感觉"></a>第三章 感觉</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E6%84%9F%E8%A7%89.png"></p><h3 id="第四章-知觉"><a href="#第四章-知觉" class="headerlink" title="第四章 知觉"></a>第四章 知觉</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E7%9F%A5%E8%A7%89.png"></p><h3 id="第五章-意识和注意"><a href="#第五章-意识和注意" class="headerlink" title="第五章 意识和注意"></a>第五章 意识和注意</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E6%84%8F%E8%AF%86%E5%92%8C%E6%B3%A8%E6%84%8F.png"></p><h3 id="第六章-记忆"><a href="#第六章-记忆" class="headerlink" title="第六章 记忆"></a>第六章 记忆</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E8%AE%B0%E5%BF%86.png"></p><h3 id="第七章-思维"><a href="#第七章-思维" class="headerlink" title="第七章 思维"></a>第七章 思维</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E6%80%9D%E7%BB%B4.png"></p><h3 id="第八章-语言"><a href="#第八章-语言" class="headerlink" title="第八章 语言"></a>第八章 语言</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E8%AF%AD%E8%A8%80.png"></p><h3 id="第九章-动机"><a href="#第九章-动机" class="headerlink" title="第九章 动机"></a>第九章 动机</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E5%8A%A8%E6%9C%BA.png"></p><h3 id="第十章-情绪"><a href="#第十章-情绪" class="headerlink" title="第十章 情绪"></a>第十章 情绪</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E6%83%85%E7%BB%AA.png"></p><h3 id="第十一章-能力"><a href="#第十一章-能力" class="headerlink" title="第十一章 能力"></a>第十一章 能力</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E8%83%BD%E5%8A%9B.png"></p><h3 id="第十二章-人格"><a href="#第十二章-人格" class="headerlink" title="第十二章 人格"></a>第十二章 人格</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E4%BA%BA%E6%A0%BC.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>麦肯锡：问题分析与解决技巧</title>
      <link href="/2023/02/20/mai-ken-xi-wen-ti-fen-xi-he-jie-jue-ji-qiao/"/>
      <url>/2023/02/20/mai-ken-xi-wen-ti-fen-xi-he-jie-jue-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h3 id="Part-1-：-从发现问题到想出解决策略"><a href="#Part-1-：-从发现问题到想出解决策略" class="headerlink" title="Part 1 ： 从发现问题到想出解决策略"></a>Part 1 ： 从发现问题到想出解决策略</h3><p>先将问题依据本质做分类，再选出重要的课题领域，然后通过思考解决策略或替代方案的优点和缺点，来逐步进行</p><h4 id="第1章-如何掌握问题"><a href="#第1章-如何掌握问题" class="headerlink" title="第1章 如何掌握问题"></a>第1章 如何掌握问题</h4><p>问题的本质：有了落差，是必须要被解决的课题</p><p>潜在或者显在</p><p>事情的优先级：紧急性和重要性</p><p>问题的分类：</p><ul><li>恢复原状型：</li><li>防范潜在型：重要性小紧急度低</li><li>追求理想型：重要性大紧急性低</li></ul><h4 id="第2章-如何解决恢复原状型问题"><a href="#第2章-如何解决恢复原状型问题" class="headerlink" title="第2章 如何解决恢复原状型问题"></a>第2章 如何解决恢复原状型问题</h4><p>两大课题：分析原因、采取应对策略（紧急处理、根本解决、防止复发）</p><p>分析原因最重要：因为唯有确定不良状态的原因，才能替问题量身定做，拟定根本解决和防止复发策略</p><p>分析原因：基于事实、掌握状况</p><p>分析：针对对象的状态和现象，追根究底地进行归类，阐明其相互关系（人话：找到产生问题的根本原因）</p><ul><li>要素归纳：MECN原则，不重复、不遗漏</li><li>分析原因：6W3H分析（寻找根本原因）、差异分析（寻找变量）</li></ul><p>确定因果关系：1. X-&gt;Y 之间有关联性 2.X发生在Y之前 3.没有其他干扰因素</p><h4 id="第3章-如何解决防范潜在型问题"><a href="#第3章-如何解决防范潜在型问题" class="headerlink" title="第3章 如何解决防范潜在型问题"></a>第3章 如何解决防范潜在型问题</h4><p>课题：确定不良状态、确定诱因、预防策略、发生时的应对策略</p><p>自下而上和自上而下 —&gt; 找到可能的诱因 —&gt;拟定预防策略，排除可能的诱因—&gt;拟定发生不良状态时的应对策略</p><h4 id="第4章-如何解决追去理想型问题"><a href="#第4章-如何解决追去理想型问题" class="headerlink" title="第4章 如何解决追去理想型问题"></a>第4章 如何解决追去理想型问题</h4><p>现状-&gt;理想：资产盘点-&gt;选定理想-&gt;行动计划</p><p>已有最终目标的理想形象，则此时为规划型的课题：如何做到？</p><p>行动起来：设定期限-&gt;找出必要条件-&gt;学习技术或者知识-&gt;制定实施计划</p><p>以自我的价值观为基础，追求属于自己的理想形象</p><h4 id="第5章-如何以分析发现问题"><a href="#第5章-如何以分析发现问题" class="headerlink" title="第5章 如何以分析发现问题"></a>第5章 如何以分析发现问题</h4><p>自己权限内的问题，才是能解决的问题</p><ul><li>要拥有大格局的视点，但别超出自己的权责范围，要以当事者的身份脚踏实地地解决问题</li></ul><p>SCAQ分析</p><ol><li>预先确认当事者的具体形象</li><li>situation：描述当事人过去的经验，目前稳定的状态和心中的理想，以及未来的目标</li><li>Complication：假设一个正在颠覆目前稳定状态的事件</li><li>Question：自问自答的方式假设各种课题</li><li>Answer：思考出Q的解答</li></ol><h4 id="第6章-如何掌握问题的本质，制定替代方案"><a href="#第6章-如何掌握问题的本质，制定替代方案" class="headerlink" title="第6章 如何掌握问题的本质，制定替代方案"></a>第6章 如何掌握问题的本质，制定替代方案</h4><p>设定课题决定了解决问题质量的优劣</p><p>替代方案：选择合适的</p><p>脑力激荡法：不可批评他人，尽量提出想法、自由奔放的发言，发展别人的想法</p><p>替代方案的评价标准：能否真的解决问题、设定好制约条件、思考期待条件、评估权重打相对分数、考虑负面评价</p><h3 id="Part-2：-情境分析：提升决策质量"><a href="#Part-2：-情境分析：提升决策质量" class="headerlink" title="Part 2： 情境分析：提升决策质量"></a>Part 2： 情境分析：提升决策质量</h3><h4 id="第7章-情境分析"><a href="#第7章-情境分析" class="headerlink" title="第7章 情境分析"></a>第7章 情境分析</h4><p>情境分析将环境变化的不确定性带入解决问题的作业过程，能够提升解决问题时做决策的质量</p><ul><li>解决问题时，以不确定性为前提，有系统的评价各种方案</li></ul><p>事先以故事的形式，将环境可能发生的变化考虑在内，因此即使环境产生变化，但因为组织内部已经做好信息共享，所以能够迅速做出应对</p><h4 id="第8章-制作环境脚本"><a href="#第8章-制作环境脚本" class="headerlink" title="第8章 制作环境脚本"></a>第8章 制作环境脚本</h4><p>三步骤</p><ol><li>将环境中风险因素结构化</li><li>定义风险的重要度</li><li>制作环境脚本</li></ol><p>找到高不确定性，高影响度的环境风险</p><h4 id="第9章-结合脚本和替代方案"><a href="#第9章-结合脚本和替代方案" class="headerlink" title="第9章 结合脚本和替代方案"></a>第9章 结合脚本和替代方案</h4><p>使用环境脚本评价各替代方案</p><h4 id="第10章-解决策略的选择顺序"><a href="#第10章-解决策略的选择顺序" class="headerlink" title="第10章 解决策略的选择顺序"></a>第10章 解决策略的选择顺序</h4><p>选择方案</p><ol><li>剔除超出容许范围的解决策略</li><li>思考环境脚本各状况的发生几率</li><li>思考风险和报酬，再选择行动</li></ol><h3 id="Part3：分析"><a href="#Part3：分析" class="headerlink" title="Part3：分析"></a>Part3：分析</h3><h4 id="第11章-分析要合乎逻辑"><a href="#第11章-分析要合乎逻辑" class="headerlink" title="第11章 分析要合乎逻辑"></a>第11章 分析要合乎逻辑</h4><p>分析和解决的基础：逻辑思考 </p><ol><li><p>说出主张，提出论据</p></li><li><p>后设认知检视自己的逻辑：站在听的人的立场上来修正自己的逻辑</p></li><li><p>不断反复检验假设</p></li></ol><h4 id="第12章-分析的本质"><a href="#第12章-分析的本质" class="headerlink" title="第12章 分析的本质"></a>第12章 分析的本质</h4><p>分析即拆解：本质为MECE发想（不重复、不遗漏）</p><p>分析的基本概念：将事物拆解，思考各个组成成分之间的相互关系</p><h4 id="第13章-如何分析策略、产业和营销"><a href="#第13章-如何分析策略、产业和营销" class="headerlink" title="第13章 如何分析策略、产业和营销"></a>第13章 如何分析策略、产业和营销</h4><p>3C分析和7S分析</p><h4 id="第14章-如何分析价值链、消费行为、公关危机"><a href="#第14章-如何分析价值链、消费行为、公关危机" class="headerlink" title="第14章 如何分析价值链、消费行为、公关危机"></a>第14章 如何分析价值链、消费行为、公关危机</h4><p>商业价值链、AIDMA模型（注意、兴趣、欲望、记忆/动机、行动）</p><h4 id="第15章-矩阵分析：从个人职业发展到公司成长"><a href="#第15章-矩阵分析：从个人职业发展到公司成长" class="headerlink" title="第15章 矩阵分析：从个人职业发展到公司成长"></a>第15章 矩阵分析：从个人职业发展到公司成长</h4><p>PPM矩阵：产品*市场矩阵</p><h4 id="第16章-解决问题的心理素质"><a href="#第16章-解决问题的心理素质" class="headerlink" title="第16章 解决问题的心理素质"></a>第16章 解决问题的心理素质</h4><p>失去平常心：</p><ol><li>否定状况</li><li>在错误的时机追究责任</li><li>对状况产生非现实性的评价</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>可能性的艺术：比较政治学30讲</title>
      <link href="/2023/01/24/bi-jiao-zheng-zhi-xue/"/>
      <url>/2023/01/24/bi-jiao-zheng-zhi-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="序言-可能性的艺术：通过比较理解政治"><a href="#序言-可能性的艺术：通过比较理解政治" class="headerlink" title="序言 可能性的艺术：通过比较理解政治"></a>序言 可能性的艺术：通过比较理解政治</h3><p>政治很复杂, 但需要理解政治</p><ul><li><p>似乎政治是一切关系、一切道义、一切概念的扭曲场；似乎，政治总是带来错位，理解政治的努力永远造成误解</p></li><li><p>人类是天生的城邦动物</p></li></ul><p>本书尝试换个视野看政治</p><ul><li>本书不试图对一时一地的政治做出是非判断，而恰恰是试图从此时此刻抽离，通过历史与全球的视野来激发新的问题和思考</li></ul><p>比较政治学是什么？</p><ul><li>其根本特性不在于研究内容是否真的进行案例比较</li><li>是一种研究的视野。当你把你所面对的政治现实当作一万种可能性之一来对待时，你就获得了一种比较的视野。带着这种广阔的视野，即使你的研究对象只是一个时代的一个国家，你的问题意识却是来源于潜在的比较</li><li>比较政治学的功能，是帮助我们建立一个政治可能性的参照系，以此分析理解各国政治所处的位置</li><li>比较政治学思考的核心任务：在差异中寻找规律。简单来讲，就是试图搞清楚，想要从A到B，需要哪些条件C？或者说，从A没有到达B，是因为缺少了哪些条件C</li></ul><p>政治的力量</p><ul><li>政治对国家命运具有根本性的影响</li></ul><p>政治的限度</p><ul><li>相似的政治理念，放到不同的社会文化土壤当中，发生了完全不同的化学反应，这就是“政治在社会中”</li></ul><h3 id="第一章-全球视野"><a href="#第一章-全球视野" class="headerlink" title="第一章 全球视野"></a>第一章 全球视野</h3><h4 id="1-政治比较的维度"><a href="#1-政治比较的维度" class="headerlink" title="1.政治比较的维度"></a>1.政治比较的维度</h4><p>横轴:民主问责, 国家发展的方向盘</p><p>纵轴:国家能力, 国家发展的发动机</p><p>本书的五个主题</p><ul><li>宏观的时代背景和全球化</li><li>政治转型</li><li>国家能力</li><li>政治文化</li><li>政治经济</li></ul><p>比较的视野是一种俯瞰的视野, 从宏观开始领略, 然后慢慢聚焦到微观</p><h4 id="2-现代社会的和平"><a href="#2-现代社会的和平" class="headerlink" title="2.现代社会的和平"></a>2.现代社会的和平</h4><p>历史的大多数时期，战争是常态，和平是例外。但在冷战结束后的今天，和平是常态，战争才是例外</p><p>从很多角度来看，今天我们所生活的时代，可以说是人类历史上的黄金时代。战争的频度和烈度在下降、人均寿命在延长、贫困率急剧缩小、受教育的水平在显著提高。面对这些进步，对现实过度悲观的判断可能带来错误的药方，反而可能摧毁已有的进步</p><p>为什么过度悲观是问题？</p><p>如果时代是一团漆黑，那么需要的是革命，极左或者极右。在一个无可救药的世界里，激进是美德，越激进越推动社会的进步。但是如果我们承认时代的巨大进步，并在这个前提下讨论战争、贫穷和饥饿，那么我们需要的改良是耐心，是在现有国际体系、现有全球化基础上的修补</p><p>衡量现实不能以理想为尺度，而且要以历史为尺度，因为摧毁进步的不仅仅可能是所谓的保守势力，而且也可能是对完美乌托邦的迷恋。</p><h4 id="3-全球化下的自由霸权"><a href="#3-全球化下的自由霸权" class="headerlink" title="3.全球化下的自由霸权"></a>3.全球化下的自由霸权</h4><p>在一个全球化的时代，深深影响我们命运的，不仅仅是国家政治，而且是国际政治。很大程度上，国际体系影响国家的命运，然后再通过国家的命运影响个体</p><p>二战后的国际格局：自由霸权（信奉自由主义的国家成为国家社会的霸权国家），意味者发源于西方国家的经济自由、政治自由和社会自由不断向外传播，欧美内部的市场自由开始成为全球的市场自由，它内部的政治模式开始借助全球的政治转型，它内部的社会观念也向全球的各个角落渗透</p><h4 id="4-经济全球化"><a href="#4-经济全球化" class="headerlink" title="4.经济全球化"></a>4.经济全球化</h4><p>世界体系理论：世界被分割成了中心地带和边缘地带，中心地带由于贪得无厌，不断从边缘地带榨取资源，将其陷入永久的贫困。因此，所谓国际贸易、国际投资、国际金融，本质上是新殖民主义的表现形势，发展中国家几乎不可能通过全球化翻身</p><p>连通器原理：全球化构建了一个连通器，它把世界各地之间的关卡都给撤掉了——撤掉之后高处的水就哗哗的流下来，低处的水就哗哗的涨上去。哪怕各国的生产率都提高，总体水位会上升，但是由于处于连通器的不同位置，也就是初始位置不同，水位的上升幅度也是大大不同的</p><p>所以有人说，现在世界的主要矛盾，不再是发达国家和发展中国家之间的矛盾，而是各国的全球主义者站在一起，与四面八方的民族主义者之间的矛盾</p><p>三难困境：全球化、主权国家和民主政治</p><h4 id="5-全球化和文化反弹"><a href="#5-全球化和文化反弹" class="headerlink" title="5.全球化和文化反弹"></a>5.全球化和文化反弹</h4><p>文化传播 —-&gt;文化反弹</p><p>多元文化主义：移民速度和文化距离</p><p>人道主义与现实主义的平衡：移民的速度和融合的速度可能成反比</p><h3 id="第二章-政治转型"><a href="#第二章-政治转型" class="headerlink" title="第二章 政治转型"></a>第二章 政治转型</h3><h4 id="6-民主衰退"><a href="#6-民主衰退" class="headerlink" title="6.民主衰退"></a>6.民主衰退</h4><p>民主化进程</p><ul><li>第一波：从19世纪早期的美国开始，到第一次世界大战开始：西方欧美国家——英、美、法等</li><li>第二波：第二次世界大战之后：西方的一些卫星国</li><li>第三波：20世纪70年代中期开始的第三波民主化浪潮：速度和规模让人瞠目结舌</li></ul><p>民主衰退的起点——民主大跃进现象：民主代议制（5，6千年的时间逐渐行程），近两百年时间将这一制度发明传播到近40个国家，然后40多年的时间将这一制度扩散到大约100个国家</p><p>民主衰退的表现之一：民主崩溃</p><p>原因：制度的变化相对容易，但文化观念、社会习俗和经济结构的变迁往往需要好几代人。结果就是，出现了制度和习俗的脱节</p><p>排异反应的方式</p><ul><li>民主崩溃：一些国家刚刚步入民主转型，就因为政治斗争而政体崩溃<ul><li>透明公正的规则、可信的法制，政治势力之间的信任和妥协的机制的培育都需要时间</li><li>由于权威体制下的文化遗产，转型国家中的很多政治力量把一个可重复游戏，玩成了一次性游戏</li></ul></li><li>民主的伪劣化<ul><li>一些新兴民主虽然不至于民主崩溃，但是民主质量节节倒退，退到了一个既够不到明珠也不能算是专制的灰色地带。主要表现是：虽然还有周期性选举的形式，但是言论自由、新闻自由、结社自由都严重倒退，以致于选举成为了一种极其不公平的政治竞争</li></ul></li></ul><h4 id="7-民主韧性"><a href="#7-民主韧性" class="headerlink" title="7.民主韧性"></a>7.民主韧性</h4><p>从历史的角度来看，民主转型从来没有一帆风顺过，它往往是风风雨雨，跌宕起伏，进两步，退一步，有时候甚至是进两步，退三步</p><p>民主韧性的体现</p><ul><li>转型相对平稳，动荡程度相比历史较低</li><li>呈现出了相当程度的民主沉淀现象，转型留下来的成果大多被保留了</li><li>民主反弹现象，尽管不少国家存在民主崩溃，但是它们很多在民主崩溃后重新民主化</li></ul><p>民主韧性从何而来？</p><ul><li>经济发展。经济的发展蛋糕变大， 大家能不必再你死我活</li><li>国家格局。自由主义处于优势地位的时代</li><li>技术发展，互联网社交媒体的兴起，大大降低了社会动员的成本</li><li>最主要：观念的因素，民主已深入世界各国人民的内心</li></ul><h4 id="8-不自由的民主"><a href="#8-不自由的民主" class="headerlink" title="8.不自由的民主"></a>8.不自由的民主</h4><p>法国大革命</p><p>不自由的民主</p><ul><li>一方面具有民主的外壳：承认普选权，追求政治平等，热衷于大规模的社会动员</li><li>另一方面，通过民主途径产生的执政者又限制政治自由，以民主的名义打压反对派，压缩政治选项，从而取消民主政体的实验性特质</li></ul><p>善与恶的捆绑：人们放弃自由的时候从来不是因为热爱专制这种恶，而是因为人们在热爱自由的同时相信有更高的善值得去追求，比如平等、比如正义、比如认同，比如面包，比如救亡，以至自由作为次要的善可以暂时被舍弃，从而换取那个更高的善</p><p>这种交换可以被描述为：牺牲暂时的自由来获得长远的自由，牺牲形式的自由来获得实质的自由</p><h4 id="9-裂痕动员"><a href="#9-裂痕动员" class="headerlink" title="9.裂痕动员"></a>9.裂痕动员</h4><p>权威倒台 不等于 民主转型</p><p>一个权威政府的倒台更普遍和更常见的后果是另一个权威政权的建立，甚至是无政府状态或者战乱的出现</p><p>民主转型的常见困境：裂痕动员</p><p>民主意味着政治动员，政党需要发动群众才能吸引选票，但是，当发动群众发生再一个社会裂痕清晰而且深刻的社会，政治动员就可能意味着社会裂痕的夸大甚至撕裂（左右之争、民族之争、地区之争、宗教之争）</p><p>民主政体天然的自我颠覆潜质——政治动员+社会裂痕</p><h4 id="10-民主转型的软着陆"><a href="#10-民主转型的软着陆" class="headerlink" title="10.民主转型的软着陆"></a>10.民主转型的软着陆</h4><p>突破社会裂痕的诅咒走向软着陆——共同的底线</p><p>共同的底线：胜利者保持宽容，失败者保持耐心 ——&gt; 让可能性成为艺术</p><h4 id="11-政体有限论"><a href="#11-政体有限论" class="headerlink" title="11.政体有限论"></a>11.政体有限论</h4><p>民主最重要的功能是通过给民众制度化的发言权，来解决统治者任意妄为的问题，或者用现在的常见说法，是把”权力关进笼子里“</p><p>民主作为一种程序，体现对民意的尊重，但是民意的质量则取决于参与者的判断力和合作能力。一旦这种能力严重欠缺，没有理由认为民主一定会带来更好的治理绩效</p><p>民主是一种公共决策程序，但不是公共政策本身。作为一个程序，它输出的结果是什么，要看人们向它输入什么原料</p><h4 id="12-社会压迫"><a href="#12-社会压迫" class="headerlink" title="12.社会压迫"></a>12.社会压迫</h4><p>印度的：表亲的专制“：水平方向，社会习俗</p><p>当制度的发展超前于文化，文化必然会以暗度成仓的方式去把规则悄悄地扭曲成潜规则</p><p>社会的压迫为什么会导致民主机制的失灵？</p><ul><li>政治冲突的加剧</li><li>抵消选举的意义。选举时的认同逻辑压倒理性逻辑，民主的竞争机制就会失灵</li><li>将公民社会瓦解成部落社会。民众视野的狭隘化，一旦存在四分五裂的身份认同，民众的监督能力就会大大下降</li></ul><p>民主是一个试错的过程，特点是慢，依靠试错而不是强制来实现进步，试错依靠人心之变来实现变革</p><p>威权政体的特点是快，它靠自上而下的动员来实现目标，只要统治集团下定了决心，整个社会就破釜沉舟，它的结果要么是大治，要是是大乱</p><h4 id="13-威权浪漫主义"><a href="#13-威权浪漫主义" class="headerlink" title="13.威权浪漫主义"></a>13.威权浪漫主义</h4><p>权威浪漫主义包含着对政治强人的两种想象，一种是对其道德智识水平的想象，一种是对其通知能力的想象</p><p>民主的价值与时间的厚度有关，它倾向于随着时间流逝而逐渐浮现</p><h3 id="第三章-国家建构"><a href="#第三章-国家建构" class="headerlink" title="第三章 国家建构"></a>第三章 国家建构</h3><h4 id="14-国家的暴力垄断"><a href="#14-国家的暴力垄断" class="headerlink" title="14.国家的暴力垄断"></a>14.国家的暴力垄断</h4><p>国家的核心特征：暴力垄断</p><p>为何国家建构如此之难？—— 暴力的分散化才是自然状态，暴力要从分散走向垄断面临两大难题</p><ol><li>权力的集中化问题：暴力垄断如何获得内部承认</li><li>领土范围的清晰化问题：暴力垄断如何获得外部承认</li></ol><h4 id="15-国家能力的"><a href="#15-国家能力的" class="headerlink" title="15.国家能力的"></a>15.国家能力的</h4><p>国家能力</p><ol><li><p>缔造秩序</p></li><li><p>现代公共服务体系的前提</p></li><li><p>保护产权以促进经济发展</p></li><li><p>特定经济发展模式的发动机</p></li></ol><h4 id="16-战争缔造国家能力"><a href="#16-战争缔造国家能力" class="headerlink" title="16.战争缔造国家能力"></a>16.战争缔造国家能力</h4><p>战争推动政治结构中央集权化</p><p>战争缔造国家机制：</p><ol><li>常备军建设</li><li>财政国家建设</li><li>官僚体系建设</li></ol><p>国家能力从何而来？</p><ul><li>中国：春秋战国几百年的站长虽然残酷，却为高度集权的大一统政治结构奠定了基础</li><li>欧洲：一方面战争带来了国家建构的动力，另一方面，多元的政治结构又约束了国家建构的深度</li><li>非洲、拉美、印度等国：历史上战争相对稀疏，其意外后果则是缺乏国家建构的动力，以致于今天政府难以垄断暴力</li></ul><h4 id="17-中国的文官制"><a href="#17-中国的文官制" class="headerlink" title="17.中国的文官制"></a>17.中国的文官制</h4><p>治天下：文官制</p><p>中国强大的国家能力传统</p><p>1.官僚系统：细密的政治经纬线。把一个庞大的帝国捆到了一起，产生了巨大的组织红利</p><p>弱独裁者现象：孤家寡人的个人统治，而不是有组织有纪律的个人统治</p><p>2.文人当政：通过抑制武人、财阀、宗教力量等，把社会精英引流到了读书做官、为皇帝服务的道路上来。</p><p>封建性的回归：即权力分散化、碎片化、蜂巢化的自然趋势</p><p>文官制大大强化了古代中国的国家能力，并使得这种能力成为一种深厚的传统。王朝可以亡，政治文明却不会亡；国家可以改名换姓，但是国家主义却可以生生不息。但是，这种制度也在历史上长期抑制了中国社会其他维度的发展，工商业的萎靡，科技的落后，军事力量的萎缩，都与此有关。 所以，古代中国早期虽然秩序没有那么稳固，但是相对生机勃勃，越到后期越暮气沉沉</p><h4 id="18-美国的反国家主义源头"><a href="#18-美国的反国家主义源头" class="headerlink" title="18.美国的反国家主义源头"></a>18.美国的反国家主义源头</h4><p>立宪时刻：反国家主义的源头</p><p>美国在立国的过程中把独立战争前的英国作为假想敌来对待，无数制度设计都是为了防止另一个遥远的、高高在上的、中央集权的政府出现</p><p>费城会议：邦联-&gt;联邦</p><p>从一开始，美国人建立的就是一个反国家的国家，它把中央集权视为洪水猛兽，处处对之提防</p><p>国家银行之争、南北战争、面对金融危机的束手无策</p><h4 id="19-美国的社会运动推动国家建构"><a href="#19-美国的社会运动推动国家建构" class="headerlink" title="19.美国的社会运动推动国家建构"></a>19.美国的社会运动推动国家建构</h4><p>美国的国家能力壮大是指绝对国家能力的壮大，就相对国家能力而言，也就是以国家和社会的力量对比而言，美国仍然是个国家能力有限的国家</p><p>社会运动如何推动国家建构 ？</p><ol><li>进步主义时代。19世纪末到20世纪初，工业化、城市化开始，恶劣的劳工条件、巨大的贫富差距，不断扩大的贫民窟，无法控制的失业风险，在这个背景下开始兴起各种进步主义运动，反抗这个大漩涡，推动了社会的变革</li><li>罗斯福新政。联邦政府的职能大大扩展</li><li>民权运动时代。20世纪五六十年代的民权运动，确立了联邦权力干预州内事务的合法性。餐馆静坐运动、自由乘客运动、华盛顿大游行，马丁路德金的著名演说</li></ol><p>另类的国家建构道路：社会运动作为核心动力构建国家</p><p>社会运动需要制度空间，以自由为前提，以民主为传导机制，社会运动的本质是政治权力的力量。</p><p>启示：国家接纳民权，国家能力未必受损，它反而可能因为合法性上升而国家能力上升</p><h4 id="20-阿富汗国家建构的悲剧"><a href="#20-阿富汗国家建构的悲剧" class="headerlink" title="20.阿富汗国家建构的悲剧"></a>20.阿富汗国家建构的悲剧</h4><p>1.多山的地形使得中央集权式政府难以形成，造就了部落主义的政治传统</p><p>2.大国对冲的地缘位置使得内战往往成为大国的代理战争，战争难以打出胜负，暴力垄断格局难以形成</p><p>3.苏联入侵激起的宗教狂热主义，毒害了阿富汗的文化土壤，使得世俗政治力量难以建立</p><p>4.多民族的结构，又使得各方政治力量难以就权力分配的方案达成共识</p><p>5.苏联式的极左浪潮以及伊斯兰原教旨主义</p><p>备注：</p><ul><li>极左是一个政治术语。极左也就是把左派的思路推向极端，突破“自由的底限”。为获得无差别的公正，而取消绝大部分的自由，为取消绝大部分的自由，必须建立一个无比强大的国家机器，将人民的一切活动处于国家的控制之中</li><li>伊斯兰教的两种不同的形态和功能。一种是把伊斯兰教当作工具，当成组成一个国家、一个社区、甚至一个教派的工具。另一种是把它本身当作目的，当作全球性的目的，或者是完全的政纲。因此，伊斯兰兄弟会的创始人说，可</li></ul><h3 id="第四章-政治文化"><a href="#第四章-政治文化" class="headerlink" title="第四章 政治文化"></a>第四章 政治文化</h3><h4 id="21-观念与制度的变迁"><a href="#21-观念与制度的变迁" class="headerlink" title="21.观念与制度的变迁"></a>21.观念与制度的变迁</h4><p>观念的变迁引发制度的变迁。观念对于制度，具有一种引力作用，但社会观念领先制度太多，它会拉动制度前进；当制度超前于观念太多，社会观念又会将制度拽回它的水平</p><p>制度变革是建立在观念变革的基础上，它才是扎实的，可持续的，因为观念一旦形成，往往具有相当的韧性</p><p>观念如何影响制度的变迁：不断提高旧制度的运转成本，使其高到不可能再继续运转</p><p>观念从何而来？</p><ol><li>观念的变化本质上是经济发展的结果</li><li>政治机会理论。反抗并不与压迫成正比，而是与反抗的政治机会成正比</li></ol><h4 id="21-民主稳固的文化基础"><a href="#21-民主稳固的文化基础" class="headerlink" title="21.民主稳固的文化基础"></a>21.民主稳固的文化基础</h4><p>真正支撑民主运转的，未必是无节制的参与精神，而更可能是一种有限度的参与意识。</p><p>民主文化=参与精神+服从意识+政治冷淡</p><p>参与精神推动民主所需要的政治动员，服从意识则推动民主所需要的政治秩序，热情形成政治改革的动力，而一定的政治冷感则给过热的政治氛围降温</p><h4 id="22-平庸之恶"><a href="#22-平庸之恶" class="headerlink" title="22.平庸之恶"></a>22.平庸之恶</h4><p>邪恶政治的秘密，它把邪恶切成一小份一小份，小到每一份邪恶的实施者完全感受不到邪恶的分量，他们只是恪尽职守，把面前这一块画板画好，但是，但所有的画板都画好，汇聚成一块巨大的拼图时，一个极其恐怖的画面却出现了</p><p>集体作恶的1+N模式：权力+暴民</p><p>权力如何制造暴民？</p><ol><li>高压。暴力的普遍性甚至仪式化</li><li>利益。利益制造积极分子</li><li>意识形态。意识形态令人疯狂</li></ol><h4 id="23-政治文化差异"><a href="#23-政治文化差异" class="headerlink" title="23.政治文化差异"></a>23.政治文化差异</h4><p>特定历史时刻而言，政治文化差异真实存在</p><p>什么是政治文化的差异：政治价值排序的不同，或者说是价值权重的不同</p><p>一些常见的否定文化差异的场景</p><ol><li>以文化内部的多样性，去否认一个文化总体的价值倾向性</li><li>以每一个文化内部的演进性，去否认一个文化在特定历史时刻的倾向性</li><li>以普世价值去否认文化差异的存在</li></ol><p>政治文化差异可能带来冲突。在一个全球化加速的时代，文化差异可能带来激烈的冲突，哪怕我们都认为A比B重要，但是，但你相信A比B重要，而我相信B比A重要，你我生活在一起，就可能出现各种摩擦。实时上，相互遭遇不但可能呈现矛盾，还可能造成观念的两极化</p><h4 id="24-文化内战是文化冲突的主要形式"><a href="#24-文化内战是文化冲突的主要形式" class="headerlink" title="24.文化内战是文化冲突的主要形式"></a>24.文化内战是文化冲突的主要形式</h4><p>文化冲突越来越表现为各文明圈，各国内部的文化内战，而不是不同文明圈之间的斗争。在目前和可见的未来，历史文明圈并非文化冲突的主要组织者</p><h3 id="第五章-政治经济"><a href="#第五章-政治经济" class="headerlink" title="第五章 政治经济"></a>第五章 政治经济</h3><h4 id="26-政治转型与经济发展"><a href="#26-政治转型与经济发展" class="headerlink" title="26.政治转型与经济发展"></a>26.政治转型与经济发展</h4><p>本质而言，决定经济发展前景的，更可能是政策取向，而不是政体类型</p><p>政策取向来自于哪里？归根结底是来源于观念。简单而言，一个社会是更期待政府通过各种各样的管制和再分配成为拯救者，还是相信千千万万个体的创造力和生产力</p><h4 id="27-委内瑞拉的不自由民主"><a href="#27-委内瑞拉的不自由民主" class="headerlink" title="27.委内瑞拉的不自由民主"></a>27.委内瑞拉的不自由民主</h4><p>委内瑞拉走到今天，不是源自坏人的贪婪腐败，而恰恰是源自好人的道德激情。当正义感变得不容置疑，当平等成为唯一的宗教，恶的大门也可以被善的手指敲开</p><h4 id="28-经济不平等的问题"><a href="#28-经济不平等的问题" class="headerlink" title="28.经济不平等的问题"></a>28.经济不平等的问题</h4><p>在过去四十年，不平等在显著上升，无论是在美国、中国还是全球</p><p>不平等会带来很多问题</p><ol><li>道义上不公平。出世不平等、教育不平等所带来的天赋、才华被淹没的现象，同时，这种不平等还具有自我强化倾向</li><li>影响经济发展。如果一个社会中绝大多数人都很穷，也就是消费能力低下，那么经济发展就会失去动力，因为没有人消费。“边际消费倾向递减效应”</li></ol><h4 id="29-经济不平等的另一个视角"><a href="#29-经济不平等的另一个视角" class="headerlink" title="29.经济不平等的另一个视角"></a>29.经济不平等的另一个视角</h4><p>换一个视角看</p><ol><li>不平等是什么经济水平上的不平等。真正重要的，本质上是贫穷问题，而不是不平等问题本身</li><li>对贫困是否存在社会救济。扶贫项目和救济措施？</li><li>社会流动性。贫富差距和阶级固化是否同时出现？</li><li>消费不平等？</li></ol><p>贫富分化差距的形成机制？</p><h4 id="30-政治的可能与不可能"><a href="#30-政治的可能与不可能" class="headerlink" title="30.政治的可能与不可能"></a>30.政治的可能与不可能</h4><p>政治可能让一个国家成为地狱，但是它却不可能让它变成天堂。换句话说，政治所能达到的上限不会那么高，但是它所能抵达的下线却可以非常低、、</p><p>政治现实主义</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>王阳明心学及其现代意义</title>
      <link href="/2023/01/14/wang-yang-ming-xin-xue-ji-qi-xian-dai-yi-yi/"/>
      <url>/2023/01/14/wang-yang-ming-xin-xue-ji-qi-xian-dai-yi-yi/</url>
      
        <content type="html"><![CDATA[<ol><li>中国哲学的核心问题：人生的意义是什么，如何在有限的事物上安顿自己的无限心</li><li>如何安顿：超越现实世界——先出世，再入世，以出世的精神做入世的事情</li><li>西方哲学与中国哲学：西方哲学的主题是知识问题，中国哲学的主题是人生问题，心安顿不好就是烦恼来</li><li>儒家的出世而又入世：无所为而为。与无所为而为对应的是有所为而为——正在做的事情是达到另一件事情的手段和目的。所谓无所为而为是指我们之所以做这件事情，是因为这件事情本应当做，它自己就是自己的价值，它自己就是自己的目的。这样的人生将永不失败，我们之所以去努力的做这件事情，因为这件事情本身就是它的价值。它自己就是自己的价值，它自己就是自己的目的。所以我们去做了。我们甚至可能凭借我们的经验知道，这件事做了的后果对我们是不利的，我仍然去做。这叫知其不可为而为之。这就是儒家出世的精神和入世的统一。</li><li>道家：无为而无不为。人类生活的幸福来自与天，人类生活的麻烦和苦恼都来自于人自己。为道曰损，损之又损，减少人为的因素。吃饭是天道规定，但偏要吃山珍海味，这是人为。天道就是把人为的东西都拿掉，顺着天道走，幸福就来了</li><li>佛教：无心而为。人生在世，非做事情不可，而你做什么事情这件事情是有来历的。业力决定了人应该做怎样的事情。无心而为的意思不是教我们做事不认真，事情一定要认真去做，但是对它的结果不关心</li><li>人性善和人性恶。本恶（生物学层面）：道德使得利益纷争限定在一定范围之内。本善（心学层面）：道德来源于人心，四端之心人皆有之，侧隐之心，仁之端也，人心是人类社会存在的基础</li><li>怵惕恻隐之心打破形骸间隔，仁心感通，一体之仁</li><li>整个宇宙趋向于生命，生命趋向于它的真理，叫生命情感，人的生命情感的本真的存在叫仁。于是仁心感通万物。仁者与天地万物为一体</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>发展心理学</title>
      <link href="/2022/11/24/fa-zhan-xin-li-xue/"/>
      <url>/2022/11/24/fa-zhan-xin-li-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="发展心理学概述"><a href="#发展心理学概述" class="headerlink" title="发展心理学概述"></a>发展心理学概述</h3><h4 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h4><p>纵向  (1)一个过程：心理的毕生发展 —— 特点和规律</p><p>横向 (1)两个部分：认知过程和社会性发展  (2) 四个方面：外部、心理、动作活动、言语</p><h4 id="研发任务"><a href="#研发任务" class="headerlink" title="研发任务"></a>研发任务</h4><p>描述(最基本) + 解释 + 推断和预测 + 控制</p><h4 id="研究设计"><a href="#研究设计" class="headerlink" title="研究设计"></a>研究设计</h4><p>横段研究、纵向研究、聚合交叉设计</p><p>(优缺点)</p><p>双生子设计</p><h4 id="心理学的发展历史"><a href="#心理学的发展历史" class="headerlink" title="心理学的发展历史"></a>心理学的发展历史</h4><p>历史原因：教育 + 进化论</p><p>发展过程：</p><p>普儿创、霍青老</p><p>荣成年、艾全程</p><p>何先概、古发超</p><p>美年鉴、发作名</p><h3 id="心理发展的基本理论"><a href="#心理发展的基本理论" class="headerlink" title="心理发展的基本理论"></a>心理发展的基本理论</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/xinlililun.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在不确定性中寻找确定性</title>
      <link href="/2022/10/09/zai-bu-que-ding-xing-zhong-xun-zhao-que-ding-xing/"/>
      <url>/2022/10/09/zai-bu-que-ding-xing-zhong-xun-zhao-que-ding-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="关于该做什么事情：高价值与高确定性的事情"><a href="#关于该做什么事情：高价值与高确定性的事情" class="headerlink" title="关于该做什么事情：高价值与高确定性的事情"></a>关于该做什么事情：高价值与高确定性的事情</h4><p>​        半年以来一直在持续困惑也在持续思考的问题是：如果才能在持续变化无法稳定的业务方向中找到技术能做的事情和价值所在。暂时的答案是通过积极的态度和基于价值驱动去选择性的做事情，高价值与高确定性的事情优先做。</p><p>​        在各方的逻辑和价值评判的标准不尽相同的情况下，寻求双赢是目标，结果若是相互妥协并不可取，妥协伴往往随着落地的不确定性。如此，不如从一开始就聊个清楚明白，从目标到策略，到从策略到落地的逻辑路线。这一过程大多时候都伴随着争论，争论的目的是合作双方之间的相互理解，若无理解，事情本身从逻辑上就不具备可落地的良好土壤。</p><h4 id="关于该怎么做事情：踏踏实实"><a href="#关于该怎么做事情：踏踏实实" class="headerlink" title="关于该怎么做事情：踏踏实实"></a>关于该怎么做事情：踏踏实实</h4><p>​        当目标到策略，到从策略到落地的逻辑路线都明晰之后，更需要的是一个踏踏实实做事情的一线同学去考虑如何落地方案细节，着眼于目标，着脚于做事。</p><p>​        中间或许伴随着多次的沟通对焦，但只要合作双方在开始做事情前已经相互理解，做事过程的沟通对焦就是达成目标的康庄大道，否则就是泥泞沼泽。</p><h4 id="关于如何看待结果：得之我幸，失之我命"><a href="#关于如何看待结果：得之我幸，失之我命" class="headerlink" title="关于如何看待结果：得之我幸，失之我命"></a>关于如何看待结果：得之我幸，失之我命</h4><p>​        作为一个一线技术，能够掌控的事情实在太少，一件逻辑上可行的事情最终结果可能最终并不如人所愿，认知水平/市场环境/组织/人 等因素的存在决定了一件事情能拿到好结果的概率永远不可能是100%，人的主观能动性在于从一开始选择成功概率高的事情去做，做的过程中保障以及提高成功的概率，事情做完后积极乐观的反思与回顾，为未来做好准备。</p><p>​        以得之我幸，失之我命的态度看待结果，方能幸福长存。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高效能人士的七个习惯</title>
      <link href="/2022/09/12/gao-xiao-neng-ren-shi-de-qi-ge-xi-guan/"/>
      <url>/2022/09/12/gao-xiao-neng-ren-shi-de-qi-ge-xi-guan/</url>
      
        <content type="html"><![CDATA[<p>作者：（美）史蒂芬·柯维</p><p>出版年：2020-5</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/s4510907.jpg" style="zoom:100%;" /><h2 id="思维方式与原则"><a href="#思维方式与原则" class="headerlink" title="思维方式与原则"></a>思维方式与原则</h2><h3 id="从内到外改造自己"><a href="#从内到外改造自己" class="headerlink" title="从内到外改造自己"></a>从内到外改造自己</h3><ul><li><p>品格&gt;个人魅力</p></li><li><p>思维方式</p><ul><li>每个人看待世界的方式。由每个人的成长背景、经验以及选择决定</li><li>思维方式 决定 行动</li></ul></li><li><p>思维转换</p><ul><li>切换一种思维方式，质的改变</li></ul></li><li><p>身体力行</p></li><li><p>已原则为中心的思维方式</p><ul><li>深刻的、基本的、普遍的</li></ul></li></ul><h3 id="7个习惯概论"><a href="#7个习惯概论" class="headerlink" title="7个习惯概论"></a>7个习惯概论</h3><ul><li><p>习惯</p><ul><li><p>知识+技巧+意愿</p><ul><li>知识：做什么+为何做</li><li>技巧：如何做</li><li>意愿：想要做</li></ul></li></ul></li><li><p>成熟模式图</p><ul><li>依赖期：依赖他人</li><li>独立期：独立自主</li><li>互赖期：协作</li></ul></li><li><p>效能</p><ul><li>产出/产能 平衡原则</li></ul></li><li><p>7个习惯的简要定义</p><ul><li><p>积极主动 be proactive</p><ul><li>积极作出选择，并为之负责</li></ul></li><li><p>以终为始 begin with the end in mind</p><ul><li>先定目标再行动</li></ul></li><li><p>要事第一 put first things first </p><ul><li>按照事情的重要性来安排生活并行动</li></ul></li><li><p>双赢思维 think win win</p><ul><li>寻求双方获利、互相尊重</li></ul></li><li><p>知己知彼 seek first to understand,  then to be understood</p><ul><li>先理解别人，再争取别人的理解</li></ul></li><li><p>综合综效 synergize</p><ul><li>求同存异，非敌对，非妥协，非止于合作，而是创造式的合作 1+1&gt;2</li></ul></li><li><p>不断更新 sharpen the saw</p><ul><li>在生活的基本面上(身体、精神、智力、社会/情感)中，不断更新自己</li></ul></li></ul></li><li><p>低效能人士的七个习惯</p><ul><li>消极被动、漫无目的、要事最后、你输我赢思维、先谈论再倾听、成为一座孤岛、耗尽一切</li></ul></li></ul><h2 id="从依赖到独立"><a href="#从依赖到独立" class="headerlink" title="从依赖到独立"></a>从依赖到独立</h2><h3 id="积极主动——个人愿景的原则"><a href="#积极主动——个人愿景的原则" class="headerlink" title="积极主动——个人愿景的原则"></a>积极主动——个人愿景的原则</h3><ul><li><p>积极主动的定义</p><ul><li>不仅指行事的态度，还意味着人一定要对自己的人生负责。个人行为取决于自身的抉择，而不是外在的环境，人类应该有营造有力的外在环境的积极性和责任感</li></ul></li><li><p>采取主动，积极行动</p><ul><li>主动创造有利环境</li><li>积极态度面对现实与未来</li></ul></li><li><p>关注圈与影响圈</p><ul><li><p>关注圈</p><ul><li>一个人的时间和精力集中于哪些事物</li></ul></li><li><p>影响圈</p><ul><li><p>关注圈内的事物，可以被个人能力掌控的范围</p><ul><li>积极主动的人专注于影响圈，专心做自己力所能及的事，不断扩大影响圈</li></ul></li></ul></li></ul></li><li><p>问题的分类</p><ul><li>可直接控制的问题</li><li>可间接控制的问题</li><li>无法控制的问题</li></ul></li><li><p>积极的改变</p><ul><li><p>从 “如果”变成 “我可以”</p><ul><li>由内向外改变，即先改变个人行为，让自己变得更充实，更具创造力，然后再去施加影响，改变环境</li></ul></li><li><p>对于已经无法挽回的错误，积极承认错误，并加以改正</p></li><li><p>作出承诺并信守承诺</p></li></ul></li></ul><h3 id="以始为终——自我领导的原则"><a href="#以始为终——自我领导的原则" class="headerlink" title="以始为终——自我领导的原则"></a>以始为终——自我领导的原则</h3><ul><li><p>以始为终的定义</p><ul><li><p>做任何事情前，都要先认清方向</p></li><li><p>两次创造</p><ul><li>头脑中构思，智力上的或第一次的创造</li><li>付诸实践，体力上的或第二次的创造</li></ul></li></ul></li><li><p>原则</p><ul><li><p>主动设计</p><ul><li>自我意识，良知和想象力</li></ul></li><li><p>自我领导</p><ul><li>做正确的事情</li></ul></li></ul></li><li><p>个人使命宣言</p><ul><li><p>想成为什么样的人</p><ul><li>有趣</li><li>明辨是非</li><li>独立人格</li><li>智慧</li><li>精神世界丰满</li></ul></li><li><p>成就什么样的事业</p><ul><li>？</li></ul></li><li><p>为此奠基的价值观</p><ul><li>凡事第一要无害，其次要有趣</li><li>终身学习</li><li>自律</li></ul></li></ul></li><li><p>核心区</p><ul><li><p>安全感</p><ul><li>价值观、认同、情感的归宿、自尊自重与拥有个人的基本能力</li></ul></li><li><p>人生方向</p><ul><li>地图和内心的准绳，人类以此为解释外界事物的理据与行为的原则和内在的标准</li></ul></li><li><p>智慧</p><ul><li>人类对生命的认知、对平衡的感知和对事物间联系的理解，包括判断力、洞察力和理解力，是这些能力的统一体</li></ul></li><li><p>力量</p><ul><li>采取行动、达成目标的能力，是作出抉择的关键性力量，也包括培育更有效的习惯以替代顽固旧习的能力</li></ul></li></ul></li><li><p>以原则作为生活中心</p><ul><li><p>安全感</p><ul><li>原则是深刻的、实在的、经典的真理</li></ul></li><li><p>人生方向和智慧</p><ul><li>来源于正确的地图，反映事物的真实历史和现状。清晰了解到自己的目标和实施途径，能够基于正确的资料作出更有意义的更容易执行的决策</li></ul></li><li><p>力量</p><ul><li>来自自我意识、知识和积极的心态，因而能够摆脱环境及他人态度和行为的制约</li></ul></li></ul></li></ul><h3 id="要事第一——自我管理的原则"><a href="#要事第一——自我管理的原则" class="headerlink" title="要事第一——自我管理的原则"></a>要事第一——自我管理的原则</h3><ul><li><p>独立意志：前提</p><ul><li>指做出决定和主动选择，并根据这些决定和选择采取具体行动的能力</li></ul></li><li><p>自律：独立意志的外显</p><ul><li>控制自己的感情冲动以及情绪，服从这些价值观的约束</li></ul></li><li><p>时间管理矩阵</p><ul><li>重要&amp;紧急</li><li>重要&amp;不紧急</li><li>不重要&amp;紧急</li><li>不重要&amp;不紧急</li></ul></li><li><p>自我管理4步骤</p><ul><li><p>确认角色</p><ul><li>个体</li><li>子女</li><li>员工</li><li>朋友</li><li>etc</li></ul></li><li><p>选择目标</p><ul><li>每一个角色选定最想做的一两件事情作为目标</li></ul></li><li><p>安排进度</p><ul><li>为每一项目标安排具体的实施时间</li></ul></li><li><p>每日调整</p><ul><li>根据突发事件、人际关系的意外发展以及崭新的机会对每天的要务安排作出适当调整</li></ul></li></ul></li></ul><h2 id="从独立和互赖"><a href="#从独立和互赖" class="headerlink" title="从独立和互赖"></a>从独立和互赖</h2><h3 id="人际关系的本质"><a href="#人际关系的本质" class="headerlink" title="人际关系的本质"></a>人际关系的本质</h3><ul><li><p>情感账户</p><ul><li><p>理解他人</p><ul><li>了解他人的实际需要，然后据此给予帮助和支持</li></ul></li><li><p>注意小节</p></li><li><p>信守承诺</p></li><li><p>明确期望</p></li><li><p>正直诚信</p></li><li><p>无条件的爱</p></li></ul></li><li><p>问题</p><ul><li>增加情感账户的契机</li></ul></li></ul><h3 id="双赢思维——人际领导的原则"><a href="#双赢思维——人际领导的原则" class="headerlink" title="双赢思维——人际领导的原则"></a>双赢思维——人际领导的原则</h3><ul><li><p>从长远来看，只有双赢是相互依赖环境中唯一可行的交往模式</p></li><li><p>要领</p><ul><li><p>双赢品德</p><ul><li><p>诚信</p></li><li><p>成熟</p><ul><li>表达自己的情感和信念的同时又能体谅他人的想法和感受的能力</li></ul></li><li><p>知足</p><ul><li>相信资源充足，人人有份</li></ul></li></ul></li><li><p>双赢关系</p><ul><li>核心：情感账户</li></ul></li><li><p>双赢协议</p><ul><li>预期结果+指导原则+可用资源+个人为结果负责+自我评估</li></ul></li><li><p>双赢体系</p><ul><li>为双赢协议创造环境</li></ul></li><li><p>双赢过程</p><ul><li>从利益而非立场出发，寻求双方都能获利的方法， 但又不违背原则</li></ul></li></ul></li></ul><h3 id="知彼解己——移情沟通的原则"><a href="#知彼解己——移情沟通的原则" class="headerlink" title="知彼解己——移情沟通的原则"></a>知彼解己——移情沟通的原则</h3><ul><li><p>核心：寻求先了解对方，然后再争取让对方了解自己</p></li><li><p>知彼</p><ul><li><p>关键：让他人信任和开怀的人格</p></li><li><p>移情聆听</p><ul><li>以理解为目的的聆听，要求听者站在说话者的角度理解他人的思维方式和感受</li></ul></li><li><p>避免自传式回应</p><ul><li><p>价值判断</p><ul><li>对旁人的意见只有接受和不接受</li></ul></li><li><p>追根究底</p><ul><li>依照自己的价值观探查别人的隐私</li></ul></li><li><p>好为人师</p><ul><li>以自己的经验提供忠告</li></ul></li><li><p>自以为是</p><ul><li>根据自己的行为与动机衡量别人的行为和动机</li></ul></li></ul></li></ul></li><li><p>解己</p><ul><li>品德&gt;感情&gt;理性</li><li>在理解他人思路和担忧的前提下，清晰、具体地表达想法</li></ul></li></ul><h3 id="综合综效"><a href="#综合综效" class="headerlink" title="综合综效"></a>综合综效</h3><ul><li><p>核心：如果一位具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙，值得加以了解</p></li><li><p>综合综效的沟通</p><ul><li>敞开胸怀，接纳一切奇怪的想法， 同时也贡献自己的见地 </li></ul></li><li><p>沟通的层次</p><ul><li><p>互相提防</p></li><li><p>互相尊重</p><ul><li>保持礼貌，避免冲突，但并不了解背后的真正原因，也不可能完全开诚布公</li></ul></li><li><p>综合综效</p><ul><li>子主题 1</li></ul></li></ul></li></ul><h2 id="自我提升与完善"><a href="#自我提升与完善" class="headerlink" title="自我提升与完善"></a>自我提升与完善</h2><h3 id="不断更新——平衡的自我提升原则"><a href="#不断更新——平衡的自我提升原则" class="headerlink" title="不断更新——平衡的自我提升原则"></a>不断更新——平衡的自我提升原则</h3><ul><li><p>个人资产</p><ul><li><p>身体</p><ul><li>健康饮食，充足休息，定期锻炼</li></ul></li><li><p>精神</p><ul><li>人的本质、核心和对价值体系的坚持</li></ul></li><li><p>智力</p><ul><li>不断学习知识，磨砺心智，开拓视野</li></ul></li><li><p>社会/情感</p><ul><li>坚守原则，肯定自我，与人为善，双赢原则</li></ul></li></ul></li><li><p>螺旋式上升</p><ul><li>围绕目标与原则，不断自我提升</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode题解整理</title>
      <link href="/2022/08/07/leetcode-ti-jie/"/>
      <url>/2022/08/07/leetcode-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><h3 id="1-自定义排序"><a href="#1-自定义排序" class="headerlink" title="1.自定义排序"></a>1.自定义排序</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 按int[0]从小到大排序</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1.双指针"></a>1.双指针</h3><p>常用于遍历数组，两个指针指向不同的元素，协同完成任务</p><h4 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h4><p>一个指针从左往右，一个指针从右往左</p><p><strong>1.二分查找</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> middle<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                right <span class="token operator">=</span> middle<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                left <span class="token operator">=</span> middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p><strong>1.判断是否有环</strong></p><p>快指针一次走两步，慢指针一次走一步，若无环，快指针最终会走到null，若有环，快慢指针会相遇</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>slow<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2.判断是否有环，并找到环入口</strong></p><p>结论：当快慢指针相遇时，让任意一个指针指向head，二者再以相同速度前进，再次相遇的节点就是环开始的地方</p><p>证明：设链表长L，环起始点到head的距离为a，环长度为r，则L=a+r，快指针一次走P步，慢指针一次走Q步。假设快慢指针相遇时，相遇点距环起点的距离为X，慢指针走的距离为a+nr+X，快指针走的距离为a+mr+X，（a+nr+X）* P = （a+mr+X）* Q  ==》a = （（mr+X）<em>Q - （nr+X）</em>P）/（P-Q） </p><p>当Q = 1，P=2时，简化为 a = 2<em>（nr+X ）- （mr+X）= （2</em>n-m）r  - X  = （2n-m-1）*r + （r - X）</p><p>即：环入口距离head的距离a 和 环长度 - 相遇点距离环入口的距离，相差整数倍的环长度。</p><p>让慢指针回到head，快指针从快慢指针的相遇点出发，步长均为1，当慢指针走到环入口时，快指针走了（2n-m-1）*r + （r - X）步，二者正好在环起点相遇</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Node <span class="token function">findCycleBeginNode</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>slow<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>slow<span class="token operator">!=</span>fast<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>3.有序链表找中间数</strong></p><p>慢指针一次走一步，快指针一次走两步，当快指针走到终点时，慢指针就处于中间位置</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMiddle</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> slow<span class="token punctuation">.</span>value<span class="token punctuation">;</span>         <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>value <span class="token operator">+</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>4.输出链表倒数第K个节点</strong></p><p>让快指针先走K步，然后慢指针从head出发，当快指针达到链表末尾时，慢节点即处于倒数第K个节点</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Node <span class="token function">findKNode</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>一个可变的窗口，左右两端方向一致的向前滑动(右端固定，左端向前滑动；或左端固定，右端向前滑动；或左右两端同时向前滑动)</p><p>关键点1：如何判断当前窗口是否满足要求</p><p>关键点2：左右两端如何移动</p><p>易错点1：左右两端移动后，一些参数如何变化</p><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" >无重复字符的最长子串<i class="fas fa-external-link-alt"></i></a></strong></p><p>步骤1：初始化窗口的left和right</p><p>步骤2：增加right扩大窗口，直到窗口中的序列不再满足要求</p><p>步骤3：增加left缩小窗口，直到窗口中的序列满足要求。同时，每一次增加left前，都需要更新一轮结果</p><p>步骤3：重复2，3，直到left、right到达尽头</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character <span class="token punctuation">,</span> Character <span class="token operator">></span> charMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>charMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                charMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                size<span class="token operator">++</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">></span> maxSize<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                maxSize <span class="token operator">=</span> size<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            charMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>            size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> maxSize<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/longest-repeating-character-replacement/" >替换后的最长重复字符<i class="fas fa-external-link-alt"></i></a></strong></p><p>滑动窗口</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">characterReplacement</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> times <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxTimes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            times<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>            maxTimes <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxTimes<span class="token punctuation">,</span> times<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> maxTimes <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                times<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">--</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/" >删除最短的子数组使剩余数组有序<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public int findLengthOfShortestSubarray(int[] arr) &#123;        if(arr.length &lt;=1) &#123;            return 0;        &#125;        boolean[] fromLeft = new boolean[arr.length];        boolean[] fromRight = new boolean[arr.length];        int result = arr.length - 1;        fromLeft[0] = true;        for(int i=1; i&lt; arr.length; i++)&#123;            fromLeft[i] = (arr[i] &gt;= arr[i-1]) &amp;&amp; fromLeft[i-1];            if(fromLeft[i] &amp;&amp; arr.length-i-1&lt;result)&#123;                result = arr.length-i-1;            &#125;            if(!fromLeft[i])&#123;                break;            &#125;        &#125;        fromRight[arr.length-1] = true;        for(int i=arr.length-2;i&gt;=0;i--)&#123;            fromRight[i] = (arr[i]&lt;=arr[i+1]) &amp;&amp; fromRight[i+1];            if(fromRight[i] &amp;&amp; i&lt;result)&#123;                result = i;            &#125;            if(!fromRight[i])&#123;                break;            &#125;        &#125;        for(int i=0;i&lt;arr.length;i++)&#123;            if(!fromLeft[i])&#123;                continue;            &#125;            for(int j=i+result;j&gt;i;j--)&#123;                if(j-i-1 &gt;= result)&#123;                    continue;                &#125;                if(!fromRight[j])&#123;                    break;                &#125;                if(arr[i]&lt;=arr[j])&#123;                    result = Math.min(result, j-i-1);                &#125;            &#125;        &#125;        return result;    &#125;</code></pre><h3 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2.贪心算法"></a>2.贪心算法</h3><p>每次操作保证局部最优，从而使得最终结果全局最优</p><h4 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h4><p>需要根据实际情况判断按区间开头排序还是按区间结尾排序。</p><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/non-overlapping-intervals/" >无重叠区间<i class="fas fa-external-link-alt"></i></a></strong></p><p>为了给其他区间更大的选择空间，所以优先选择结尾小的区间。按区间结尾从小到大排序，从左往右看区间，区间不重叠则保留，重叠则排除</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span>  a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> position <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>position<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                result<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                position  <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" >用最少数量的箭引爆气球<i class="fas fa-external-link-alt"></i></a></strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 右边界从左往右排序, 箭每次尽量射到右边界</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>points<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                result<span class="token operator">++</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/candy/" >分发糖果<i class="fas fa-external-link-alt"></i></a></strong></p><p>约束条件：</p><ul><li>每个人至少分配一个糖果 —— 初始化糖果数为1</li><li>相邻孩子评分高的获得更多糖果 —— 从左往右看，评分高的孩子比左边孩子分配更多的糖果，从右往左看，评分高的孩子比右边孩子分配更多的糖果</li></ul><p>每个人首次分配一个糖果，</p><p>先从左往右遍历，评分大则分的糖果数更新为前一个孩子的糖果数+1，</p><p>再从右往左遍历，评分大并且当前糖果数小于等于前一个孩子，则分的糖果数更新为前一个孩子的糖果数+1</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ratings<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candyNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ratings<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        candyNum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ratings<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ratings<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> candyNum<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> result <span class="token operator">+</span> candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> ratings<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>candyNum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> result <span class="token operator">+</span> candyNum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span>candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> candyNum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h3><p>应用于有最优子结构的问题，保存字结构的解，避免重复计划</p><p>核心：状态转移方程</p><h4 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/climbing-stairs/" >斐波那契数列<i class="fas fa-external-link-alt"></i></a></strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        result<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>result<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/arithmetic-slices/" >等差数列划分<i class="fas fa-external-link-alt"></i></a></strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 定义dp[i] 为num[i] 结尾的等差数组的数量</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> result<span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/minimum-path-sum/" >最小路径和<i class="fas fa-external-link-alt"></i></a></strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/01-matrix/" > 01 矩阵<i class="fas fa-external-link-alt"></i></a></strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mat<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> mat<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向右向下</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向左向上</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/perfect-squares/" >完全平方数<i class="fas fa-external-link-alt"></i></a></strong></p><p>状态转移方程不依赖相邻位置，而是依赖于满足分割条件的位置</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">*</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/decode-ways/" >解码方法<i class="fas fa-external-link-alt"></i></a></strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 1.看作增加一位</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2.和前一位合并一起看</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'1'</span> <span class="token operator">||</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'2'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/word-break/" >单词拆分<i class="fas fa-external-link-alt"></i></a></strong></p><p>对字符串A进行分割后形成左右两个字符串B、C，A满足条件当且仅当B、C都满足条件，B是否能分割&lt;=&gt;dp[分割位置]，C满足条件&lt;=&gt;C在字典中</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDict<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>             <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/longest-increasing-subsequence/" >最长递增子序列<i class="fas fa-external-link-alt"></i></a></strong></p><p>子序列问题解法一：定义一个dp数组，dp[i] 表示以i结尾的子序列的性质。在处理好每一个位置的，在统计一遍每一个位置的结果即可得到题目要求的结果</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/longest-common-subsequence/" >最长公共子序列<i class="fas fa-external-link-alt"></i></a></strong></p><p>子序列问题解法二：定义一个dp数组，dp[i]表示到位置i为止的子序列的性质，并不必须以i结尾。这样dp数组的最后一位即为题目所求，不需要再统计每个位置</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>String text1<span class="token punctuation">,</span> String text2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// dp[i][j]定义为 第一个string长度最长为i，第二个string长度最长为j，最长公共子序列的长度</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>text1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> text2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" >最长重复子数组<i class="fas fa-external-link-alt"></i></a></strong></p><p>dp[i] [j] 第一个数组i位置，第二个数组j位置的重复子数组的长度</p><p>if a[i] = b[j]  then dp[i] [j] = dp[i-1] [j-1] + 1</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLength</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> nums2<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token operator">&lt;</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        result <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>4.<a class="link"   href="https://leetcode.cn/problems/uncrossed-lines/" >不相交的线<i class="fas fa-external-link-alt"></i></a></strong></p><p>dp[i] [j] 定义为a数组的i个数，b数组的第j个数，最大的连线数</p><p>if(a[i-1] == b[j-1])  dp[i] [j] = dp[i-1] [j-1] + 1</p><p>否则 dp[i] [j] = max(dp[i-1] [j], dp[i] [j-1])</p><p>题目等价于求最长公共子序列</p><pre><code>    public int maxUncrossedLines(int[] nums1, int[] nums2) &#123;        if(nums1.length &lt; 1 || nums2.length &lt; 1)&#123;            return 0;        &#125;        int[][] dp = new int[nums1.length+1][nums2.length+1];        for(int i = 1;i&lt;=nums1.length;i++)&#123;            for(int j = 1;j&lt;=nums2.length;j++)&#123;                if(nums1[i-1] == nums2[j-1])&#123;                    dp[i][j] = dp[i-1][j-1] + 1;                &#125; else &#123;                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[nums1.length][nums2.length];    &#125;</code></pre><p><strong>5.<a class="link"   href="https://leetcode.cn/problems/maximum-subarray/" >最大子数组和<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public int maxSubArray(int[] nums) &#123;        int length = nums.length;        if(length &lt; 1)&#123;            return 0;        &#125;        int[] dp = new int[length];        dp[0] = nums[0];        int result = nums[0];        for(int i=1;i&lt;length;i++)&#123;            if(dp[i-1]&gt;0)&#123;                dp[i] = dp[i-1] + nums[i];            &#125; else&#123;                dp[i] = nums[i];            &#125;            if(result &lt; dp[i])&#123;                result = dp[i];            &#125;        &#125;        return result;    &#125;</code></pre><p><strong>6.<a class="link"   href="https://leetcode.cn/problems/is-subsequence/" >判断子序列<i class="fas fa-external-link-alt"></i></a></strong></p><p>为true条件：dp[m] [n] = m;</p><pre><code>    public boolean isSubsequence(String s, String t) &#123;        int m = s.length();        int n =t.length();        int[][] dp = new int[m+1][n+1];        for(int i = 1;i&lt;=m;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                if(s.charAt(i-1) == t.charAt(j-1))&#123;                    dp[i][j] = dp[i-1][j-1] + 1;                &#125;else&#123;                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[m][n]==m;    &#125;</code></pre><p><strong>7.<a class="link"   href="https://leetcode.cn/problems/distinct-subsequences/" >不同的子序列<i class="fas fa-external-link-alt"></i></a></strong></p><p>定义dp[i] [j] 等于 以t[i-1]结尾的子序列 在 最长长度为j的s子序列中出现的个数</p><pre><code>    public int numDistinct(String s, String t) &#123;                int m = t.length();        int n = s.length();        if(n &lt; 1 || m &lt; 1)&#123;            return 0;        &#125;        int[][] dp = new int[m+1][n+1];        for(int i=0;i&lt;n;i++)&#123;            if(s.charAt(i) == t.charAt(0))&#123;                dp[0][i] = 1;            &#125;        &#125;        for(int i = 1;i&lt;=m;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                if(t.charAt(i-1) == s.charAt(j-1))&#123;                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1];                &#125;else &#123;                    dp[i][j] = dp[i][j-1];                &#125;            &#125;        &#125;        return dp[m][n];    &#125;</code></pre><p><strong>8.<a class="link"   href="https://leetcode.cn/problems/delete-operation-for-two-strings/" >两个字符串的删除操作<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public int minDistance(String word1, String word2) &#123;        int m = word1.length();        int n = word2.length();        int[][] dp = new int[m+1][n+1];        for(int i=0;i&lt;=m;i++)&#123;            dp[i][0] = i;        &#125;        for(int i=0;i&lt;=n;i++)&#123;            dp[0][i] = i;        &#125;        for(int i =1;i&lt;=m;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                if(word1.charAt(i-1) == word2.charAt(j-1))&#123;                    dp[i][j] = dp[i-1][j-1];                &#125;else&#123;                    // 删除                    dp[i][j] = Math.min(dp[i-1][j-1]+2, Math.min(dp[i-1][j]+1, dp[i][j-1]+1));                &#125;            &#125;        &#125;        return dp[m][n];    &#125;</code></pre><p><strong>9.<a class="link"   href="https://leetcode.cn/problems/edit-distance/" >编辑距离<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public int minDistance(String word1, String word2) &#123;        int m = word1.length();        int n = word2.length();        int[][] dp = new int[m+1][n+1];        for(int i = 0 ; i&lt;=m;i++)&#123;            dp[i][0] = i;        &#125;        for(int j =0;j&lt;=n;j++)&#123;            dp[0][j] = j;        &#125;        for(int i =1;i&lt;=m;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                if(word1.charAt(i-1) == word2.charAt(j-1))&#123;                    dp[i][j] = dp[i-1][j-1];                &#125; else &#123;                    //替换 、                     dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;                &#125;            &#125;        &#125;        return dp[m][n];    &#125;</code></pre><p><strong>10.<a class="link"   href="https://leetcode.cn/problems/palindromic-substrings/" >回文子串<i class="fas fa-external-link-alt"></i></a></strong></p><p>动态规划1</p><p>dp[i] 等于 dp[i-1] + 以位置i结尾的回文串的数量</p><pre><code>        int[] dp = new int[s.length()+1];        for(int i =1 ;i&lt;=s.length() ; i++)&#123;            dp[i] = dp[i-1];            for(int j = 1;j&lt;=i;j++)&#123;                if(isCycString(j,i,s))&#123;                    dp[i]++;                &#125;            &#125;        &#125;        return dp[s.length()];    &#125;    // aba a=1 b=1    private boolean isCycString(int a,int b, String s)&#123;        int n = (b-a)/2;        for(int i = 0 ;i&lt;=n;i++)&#123;            if(s.charAt(a+i-1) != s.charAt(b-i-1))&#123;                return false;            &#125;        &#125;        return true;    &#125;</code></pre><p>动态规划2</p><p>定义dp[i] [j]  第i个字符到第j个字符的子串是否为回文串</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>j<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> j <span class="token operator">||</span> i <span class="token operator">==</span> j<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">==</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        result <span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            result <span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>11.<a class="link"   href="https://leetcode.cn/problems/longest-palindromic-subsequence/" >最长回文子序列<i class="fas fa-external-link-alt"></i></a></strong></p><p>定义dp[i] [j] 为 第i个字符到第j个字符的子串最长的回文子序列的长度</p><pre><code>    public int longestPalindromeSubseq(String s) &#123;        int[][] dp = new int[s.length()+1][s.length()+1];        for(int j = 1;j&lt;=s.length();j++)&#123;            for(int i=j; i&gt;=1;i--)&#123;                if(s.charAt(j-1) == s.charAt(i-1))&#123;                    if( i==j)&#123;                        dp[i][j] = 1;                    &#125; else if(i+1 == j)&#123;                        dp[i][j] = 2;                    &#125; else&#123;                        dp[i][j] = dp[i+1][j-1] + 2;                    &#125;                &#125;else&#123;                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[1][s.length()];    &#125;</code></pre><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p><strong>1. 01背包理论基础</strong></p><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p>解：</p><p>1、定义dp数组: dp[i] [j]表示 从下标为[0-i]的物品中随意取，放进容量为j的背包，最大的value是多少</p><p>2、动态转移方程：</p><ul><li>如果装不下(weight[i]&gt;j)  dp[i] [j] = dp[i-1] [j] ;</li><li>如果装得下 dp[i] = max(dp[i-1] [j], dp[i-1] [j-weight[i]] + value[i])</li></ul><p>3、dp数组初始化：</p><ul><li>j=0时表示背包重量为0，所以dp[i] [0] = 0；</li><li>i=0时 如果 j&gt;=weight[0], 则dp[0] [j] = value[0] 否则 dp[0] [j] = 0</li></ul><p>4、确定遍历顺序</p><ul><li>动态转移方程是从右下遍历到左上，无论是先遍历背包还是物品均可</li></ul><pre><code>public int weightbagproblem(int[] weight, int[] value, int w)&#123;          int[][] dp = new int[weight.length][w+1];    for(int j = weight[0] ; j&lt;=w; j++)&#123;        dp[0][j] = value[0];    &#125;        for(int i = 1; i&lt;weight.length; i++)&#123;        for(int j = 1; j&lt;=w; j++)&#123;            if(weight[i]&gt;j)&#123;                dp[i][j] = dp[i-1][j];            &#125;else&#123;                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);            &#125;        &#125;    &#125;        return dp[weight.length-1][w];&#125;</code></pre><p><strong>2. 01背包问题的一维数组解法</strong></p><p>1、定义dp数组： dp[j]表示容量为j的背包，最大的value是多少</p><p>2、动态转移方程：dp[j] = max(dp[j], dp[j-weight[i]] + value[i])</p><p>3、dp数组初始化：dp[0] = 0;</p><p>4、确定遍历顺序: 从w到weight[i]</p><pre><code>public int weightbagproblem(int[] weight, int[] value, int w)&#123;          int[] dp = new int[w+1];        for(int i =0 ; i&lt;weight.length; i++)&#123;        for(int j=w;j&gt;=weight[i];j--)&#123;            dp[j] = Math.max(dp[j], dp[j-weight[i]] + value[i]);        &#125;    &#125;        return dp[w];&#125;</code></pre><p>问题1、为什么倒序遍历？</p><ul><li>从前往后遍历，每次取得的状态会和之前的状态重合，即随着背包容量的变大，存在可能性一个物品被重复放入多次。而从后往前遍历，每次取得的状态与之前的状态无关</li></ul><p>问题2、为什么二维数组不需要从后往前？</p><ul><li>二维dp i位置的状态由上一层的i-1 推导得到，本层的dp[i] [j]  和 dp[i] [j-1] 不会相互影响</li></ul><p><strong>3.完全背包理论基础</strong></p><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品可以用无限次，求解将哪些物品装入背包里物品价值总和最大。</p><p>和01背包的差别：每件物品可以使用多次； 01背包j从大到小遍历，防止物品被放入多次；而完全背包刚好相反，j从小到大遍历，使得每件物品尝试放入多次</p><pre><code>//遍历物品for(int i=0;i&lt;weight.length;i++)&#123;    //遍历背包    for(int j=weight[i];j&lt;=w;j++)&#123;        dp[j] = max(dp[j], dp[j-weight[i]]+value[i]);    &#125;&#125;//01背包只能先遍历物品，因为011背包要求背包倒序遍历，如果先遍历背包再遍历物品，那么每个背包最多只会放入一个物品//完全背包先遍历物品还是先遍历背包不影响结果//因为只要保证dp[j]是根据j之前的dp[j]计算出来的即可</code></pre><p><strong>4.多重背包理论基础</strong></p><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] ,第i种物品最多有m[i]件可用，求解将哪些物品装入背包里物品价值总和最大。</p><p>解法：将第i件物品展开，就变成了一个01背包问题</p><p><strong>5.能否装满背包(最多装多少)</strong> </p><p><a class="link"   href="https://leetcode.cn/problems/partition-equal-subset-sum/" >分割等和子集<i class="fas fa-external-link-alt"></i></a></p><p>weight[] = nums[] , value[] = nums[], 元素不可重复使用 =&gt; 01背包问题</p><p>题目求解 背包容量为j是能否刚好装满 =》 dp[j]表示容量为j时能装的最大价值，价值=重量 =&gt; dp[j] = j</p><pre><code>    public boolean canPartition(int[] nums) &#123;        int sum = 0;        for(int i = 0;i&lt;nums.length;i++)&#123;            sum = sum + nums[i];        &#125;        if(sum % 2 == 1)&#123;            return false;        &#125;        sum = sum/2;                int dp[] = new int[sum+1];        for(int i = 0; i&lt;nums.length;i++)&#123;            for(int j = sum; j&gt;=nums[i];j--)&#123;                dp[j] = Math.max(dp[j], dp[j-nums[i]]+nums[i]);            &#125;        &#125;        return dp[sum]==sum;    &#125;&#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/last-stone-weight-ii/" >最后一块石头的重量 II<i class="fas fa-external-link-alt"></i></a></p><p>weight[i]=stone[i], value[i]=stone[i]</p><p>dp[j] 容量为j时，最大的价值</p><p>最后一块石头最小 等价于 分成两个子数组，两个子数组差值最小，(sum-a)-a = sum - 2a，即使得a尽量接近sum/2 ， 若sum为偶数 a = dp[sum/2]  , 若sum为奇数 a=dp[(sum-1)/2]</p><pre><code>    public int lastStoneWeightII(int[] stones) &#123;                int sum = 0;        for(int i = 0;i&lt;stones.length;i++)&#123;            sum = sum + stones[i];        &#125;        int[] dp = new int[sum/2+1];        for(int i = 0; i&lt;stones.length;i++)&#123;            for(int j=sum/2;j&gt;=stones[i];j--)&#123;                dp[j] = Math.max(dp[j], dp[j-stones[i]]+stones[i]);            &#125;        &#125;        return sum - 2*dp[sum/2];    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/word-break/" >单词拆分<i class="fas fa-external-link-alt"></i></a></p><p>字典中的单词看作时物品，s看作是背包，题目问的是背包能否填满</p><p>dp[i]定义为长度为i的s子序列能否被填满</p><p>dp[i] = d[i-len] &amp; s.substr(i-len,i) in wordDict[]</p><pre><code>    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        boolean[] dp = new boolean[s.length()+1];        dp[0] = true;        for(int i=1;i&lt;=s.length();i++)&#123;            for(int j=0;j&lt;wordDict.size();j++)&#123;                int len = wordDict.get(j).length();                if(i&gt;=len)&#123;                    dp[i] = dp[i-len] &amp;&amp; wordDict.contains(s.substring(i-len, i));                &#125;                if(dp[i]==true)&#123;                    break;                &#125;            &#125;        &#125;        return dp[s.length()];    &#125;</code></pre><p><strong>6.装满背包有几种方法（组合/排列）</strong></p><p><strong>求组合数</strong></p><p>求组合数：外层for循环遍历物品，内层for遍历背包</p><p><a class="link"   href="https://leetcode.cn/problems/target-sum/" >目标和<i class="fas fa-external-link-alt"></i></a></p><p>题目等价于分成两个数组，两个数组差值为target的分法，设两个数组的和分别为 a 和 sum-a，差值即为：a-（sum-a） = 2a-sum = target =》 a = （target+sum）/2 。</p><p>当target+sum为奇数时无解，偶数时即求解：装满容量为a的背包的办法有多少种</p><p>定义dp[j] 为装满容量为j的背包有多少种方法</p><pre><code>    public int findTargetSumWays(int[] nums, int target) &#123;        int sum = 0;        for(int i = 0;i&lt;nums.length;i++)&#123;            sum = sum + nums[i];        &#125;        if((sum+target) % 2 != 0)&#123;            return 0;        &#125;        int bagWeight = (sum+target)/2;                if(bagWeight&lt;0)&#123;            return 0;        &#125;        int[] dp = new int[bagWeight+1];        dp[0] = 1;        for(int i =0;i&lt;nums.length;i++)&#123;            for(int j = bagWeight; j&gt;=nums[i];j--)&#123;                dp[j] = dp[j] + dp[j-nums[i]];            &#125;        &#125;        return dp[bagWeight];    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/coin-change-2/" > 零钱兑换 II<i class="fas fa-external-link-alt"></i></a></p><p>定义dp[j] 为金额总和为j的组合数</p><p>则 dp[j] = dp[j] + dp[j-coins[i]]</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> amount<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>amount<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>求排列数</strong></p><p>求排列数：外层for遍历背包，内层for循环遍历物品。</p><p>如何理解：如果物品放在外层，那么编号为i和i+1的物品，出现的顺序一定是 i再i+1，就会少了i+1再i这一种排列数，所以需要把物品放在内层遍历</p><p><a class="link"   href="https://leetcode.cn/problems/combination-sum-iv/" >组合总和 Ⅳ<i class="fas fa-external-link-alt"></i></a></p><p>定义dp[i]为和为i的排列个数</p><p>则：dp[i] = dp[i] + dp[i-nums[j]]</p><pre><code>    public int combinationSum4(int[] nums, int target) &#123;        int[] dp = new int[target+1];        dp[0]=1;        for(int i=1;i&lt;=target;i++)&#123;            for(int j=0;j&lt;nums.length;j++)&#123;                if(i&gt;=nums[j])&#123;                    dp[i] = dp[i] + dp[i-nums[j]];                &#125;            &#125;        &#125;        return dp[target];    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/climbing-stairs/" > 爬楼梯<i class="fas fa-external-link-alt"></i></a></p><p>换成完全背包的视角看这个问题，求得是和为n的排列数</p><pre><code>    public int climbStairs(int n) &#123;                int[] dp = new int[n+1];        dp[0]=1;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=2;j++)&#123;                if(i&gt;=j)&#123;                    dp[i] = dp[i] + dp[i-j];                &#125;            &#125;        &#125;        return dp[n];    &#125;</code></pre><p><strong>7.背包装满的最大价值</strong></p><p><a class="link"   href="https://leetcode.cn/problems/ones-and-zeroes/" >一和零<i class="fas fa-external-link-alt"></i></a></p><p>每一个字符串的weight有两个：0的数量和1的数量</p><p>每个字符串的value都为1：</p><p>求解在0的背包weight不大于m，1的背包weight不大于n的情况下，value的最大值</p><p>=》</p><p>定义dp[i] [j] 表示 0的个数最大为i，1的个数最大为j的情况下，放入字符串个数的最大值</p><p>转移方程： dp[i] [j] = max(dp[i] [j], d[i - 当前字符串0的个数] [当前字符串1的个数])</p><p>初始化：dp[i] [j] = 0</p><pre><code>    public int findMaxForm(String[] strs, int m, int n) &#123;        int[][] dp = new int[m+1][n+1];        for(int p = 0;p&lt;strs.length;p++)&#123;            int nums0 = 0;            int nums1 = 0;            for(int q = 0;q&lt;strs[p].length();q++)&#123;                if(strs[p].charAt(q) == &#39;0&#39;)&#123;                    nums0 ++;                &#125; else if(strs[p].charAt(q) == &#39;1&#39;)&#123;                    nums1 ++;                 &#125;            &#125;            for(int i=m;i&gt;=nums0;i--)&#123;                for(int j=n;j&gt;=nums1;j--)&#123;                    dp[i][j] = Math.max(dp[i][j], dp[i-nums0][j-nums1]+1);                &#125;            &#125;        &#125;        return dp[m][n];    &#125;</code></pre><p><strong>8.背包装满的最大价值</strong></p><p><strong>9.装满背包所有物品的最小个数</strong></p><p><a class="link"   href="https://leetcode.cn/problems/coin-change/" >零钱兑换<i class="fas fa-external-link-alt"></i></a></p><p>理解为value均为1，求装满背包后的value最小值</p><p>定义dp[j]为装满dp[j]的背包，value的最小值</p><p>则：dp[j] = min(dp[j], d[j-nums[i]]+1)</p><pre><code>    public int coinChange(int[] coins, int amount) &#123;        int[] dp = new int[amount+1];        for(int i = 1;i&lt;=amount;i++)&#123;            dp[i] = Integer.MAX_VALUE-1;        &#125;        for(int i=0;i&lt;coins.length;i++)&#123;            for(int j=coins[i];j&lt;=amount;j++)&#123;                dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);            &#125;        &#125;        if(dp[amount] == Integer.MAX_VALUE-1)&#123;            return -1;        &#125;        return dp[amount];    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/perfect-squares/" > 完全平方数<i class="fas fa-external-link-alt"></i></a></p><p>value=1，w=n，weight[i] = i*i，求容量为n的背包装满时value的最小值</p><pre><code>    public int numSquares(int n) &#123;        int[] dp = new int[n+1];        for(int i=1;i&lt;=n;i++)&#123;            dp[i]=Integer.MAX_VALUE-1;        &#125;        for(int i=0;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                if(j&gt;=i*i)&#123;                    dp[j] = Math.min(dp[j], dp[j-i*i]+1);                &#125;            &#125;        &#125;        return dp[n];    &#125;</code></pre><h4 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h4><p><a class="link"   href="https://leetcode.cn/problems/house-robber/" >打家劫舍<i class="fas fa-external-link-alt"></i></a></p><p> dp[i] 到编号为i的房屋时，能偷窃的最大金额</p><p>初始dp，dp[0] 即为nums[0] ，dp[1] 为nums[0]和nums[1]较大的那个</p><p>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</p><pre><code>    public int rob(int[] nums) &#123;        int[] dp = new int[nums.length];        if(nums.length == 1)&#123;            return nums[0];        &#125;        if(nums.length == 2)&#123;            return Math.max(nums[0],nums[1]);        &#125;        dp[0] = nums[0];        dp[1] = Math.max(nums[0],nums[1]);        for(int i =2;i&lt;nums.length;i++)&#123;            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);        &#125;        return dp[nums.length-1];    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/house-robber-ii/" >打家劫舍 II<i class="fas fa-external-link-alt"></i></a></p><p>分类讨论一下</p><p>包含第一间房：计算第一间房到倒数第二间房的最大值</p><p>不包含第一间房：计算第二间房到最后一间房的最大值</p><pre><code>    public int rob(int[] nums) &#123;        if(nums.length == 1)&#123;            return nums[0];        &#125;        if(nums.length == 2)&#123;            return Math.max(nums[0],nums[1]);        &#125;        return Math.max(rob(nums, 0 , nums.length -1),rob(nums, 1 , nums.length) );    &#125;    private int rob(int[] nums, int start, int end)&#123;        int length = end -start;        int[] dp = new int[length+1];        if(length == 1)&#123;            return nums[start];        &#125;        if(length == 2)&#123;            return Math.max(nums[start],nums[start+1]);        &#125;        dp[0] = nums[start];        dp[1] = Math.max(nums[start],nums[start+1]);        for(int i = 2;i&lt;length;i++)&#123;            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[start+i]);        &#125;        return dp[length-1];    &#125;&#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/house-robber-iii/" >打家劫舍 III<i class="fas fa-external-link-alt"></i></a></p><p>暴力递归（会超时）    </p><pre><code>    public int rob(TreeNode root) &#123;        if(root == null)&#123;            return 0;        &#125;        // 不偷head  left+right        int a = rob(root.left)+ rob(root.right);        // 偷head  head + left.left+left.right + right.left + right.right        int b = root.val;        if(root.left != null)&#123;            b = b + rob(root.left.left) + rob(root.left.right);        &#125;        if(root.right != null)&#123;            b = b + rob(root.right.left) + rob(root.right.right);        &#125;        return Math.max(a,b);            &#125;</code></pre><p>对暴力递归进行优化（记忆化递归）</p><pre><code>    // 对已经计算过的节点的value进行记录    Map&lt;TreeNode, Integer&gt; valueMap = new HashMap&lt;&gt;();    public int rob(TreeNode root) &#123;        if(root == null)&#123;            return 0;        &#125;        if(valueMap.get(root) != null)&#123;            return valueMap.get(root);        &#125;        // 不偷head  left+right        int a = rob(root.left)+ rob(root.right);        // 偷head  head + left.left+left.right + right.left + right.right        int b = root.val;        if(root.left != null)&#123;            b = b + rob(root.left.left) + rob(root.left.right);        &#125;        if(root.right != null)&#123;            b = b + rob(root.right.left) + rob(root.right.right);        &#125;        valueMap.put(root, Math.max(a,b));        return Math.max(a,b);            &#125;</code></pre><p>动态规划(树形dp)</p><p>定义 int[] dp = new int[2]</p><p>dp[0] 表示不偷head，那么dp[0] = 左子节点的最大值+右子节点的最大值 = Math.max(robLeft[0], robLeft[1])+Math.max(robright[0],robright[1]);</p><p>dp[1] 表示偷head，那么dp[0] = root的value + 不偷左节点head的value+ 不偷右节点head的value =  root.val + robLeft[0] + robright[0]</p><pre><code>    public int rob(TreeNode root) &#123;        int[] result =robNode(root);        return Math.max(result[0], result[1]);    &#125;    private int[] robNode(TreeNode root)&#123;        int result[] = new int[2];        if(root == null)&#123;            return result;        &#125;        int[] robLeft = robNode(root.left);        int[] robright = robNode(root.right);        //不偷head        result[0] = Math.max(robLeft[0], robLeft[1])+Math.max(robright[0],robright[1]);         //偷head        result[1] = root.val + robLeft[0] + robright[0];        return result;    &#125;</code></pre><h4 id="买卖股票问题"><a href="#买卖股票问题" class="headerlink" title="买卖股票问题"></a>买卖股票问题</h4><p><a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" >买卖股票的最佳时机<i class="fas fa-external-link-alt"></i></a></p><p><strong>股票只能买卖一次，问最大利润</strong>。</p><p>贪心：最左取最小，最右取最大</p><pre><code>    public int maxProfit(int[] prices) &#123;        //往右遍历 记录最小值        if(prices.length &lt;= 1)&#123;            return 0;        &#125;        int result = 0;        int min = prices[0];        for(int i = 0 ; i&lt;prices.length;i++)&#123;            if(prices[i] &gt; min)&#123;                result = Math.max(result, prices[i]-min);            &#125;                        if(prices[i] &lt; min)&#123;                min = prices[i];            &#125;        &#125;        return result;    &#125;</code></pre><p>动态规划</p><p>1.定义动态转移方程：</p><ul><li><p>定义dp[i] [0] 表示第i天持有股票所得的最多现金</p></li><li><p>dp[i] [1] 表示第i天不持有股票所得的最多现金</p></li></ul><p>2.确定递推公式</p><ul><li>第i天持有股票 dp[i] [0] = Max(dp[i-1] [0], -prices[i])<ul><li>若第i-1天也持有股票 则dp[i] [0] = dp[i-1] [0]</li><li>若第i-1天未持有股票 则dp[i] [0] = -price[i]<ul><li>之所以是-price[i]， 而不是 dp[i-1] [1] - price[i]， 是因为只能交易一次, 第i-1天未持有股票的情况下现金必定为0</li></ul></li></ul></li><li>第i天不持有股票 dp[i] [1] = Max(dp[i-1] [0] +  prices[i]， dp[i-1] [1])<ul><li>若第i-1天也持有股票, 就相当于在第i天卖出股票  则dp[i] [1] =dp[i-1] [0] +  prices[i]</li><li>若第i-1天不持有股票 则dp[i] [1] = dp[i-1] [1]</li></ul></li></ul><p>3.初始化</p><p>dp[0] [0] = -prices[0], dp[0] [1] = 0</p><p>4.遍历顺序 : 从前往后</p><pre><code>    public int maxProfit(int[] prices) &#123;        if(prices.length&lt;=1)&#123;            return 0;        &#125;        int[][] dp = new int[prices.length][2];        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i =1;i&lt;prices.length;i++)&#123;            // 持有            dp[i][0] = Math.max(dp[i-1][0], -prices[i]);            // 不持有            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);        &#125;        return dp[prices.length - 1][1];    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" >买卖股票的最佳时机 II<i class="fas fa-external-link-alt"></i></a></p><p><strong>可以多次买卖股票，问最大收益</strong></p><p>和上题唯一的区别就在于第i-1天未持有股票，第i天持有股票的情况下，第i天现金的最大值未第i-1天未持有股票的最大值减去第i天股票的价格</p><p>（股票可以多次买卖，第i-1天未持有股票的最大值可能不为0）</p><pre><code>    public int maxProfit(int[] prices) &#123;        if(prices.length&lt;=1)&#123;            return 0;        &#125;        int[][] dp = new int[prices.length][2];        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i =1;i&lt;prices.length;i++)&#123;            // 持有            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);            // 不持有            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);        &#125;        return dp[prices.length - 1][1];    &#125;&#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" >买卖股票的最佳时机 III<i class="fas fa-external-link-alt"></i></a></p><p><strong>最多买卖两次，问最大收益。</strong></p><p>定义dp[i] [5]</p><ul><li>dp[i] [0] 没有操作过 </li><li>dp[i] [1] 第一次买入股票(指的是状态，不是第i天买入)</li><li>dp[i] [2] 第一次卖出股票</li><li>dp[i] [3] 第二次买入股票</li><li>dp[i] [4] 第二次卖出股票</li></ul><p>动态转移方程</p><ul><li>dp[i] [0] = 0</li><li>dp[i] [1] = max(dp[i-1] [1],  - prices[i] )？</li><li>dp[i] [2] = max(dp[i-1] [2], dp[i-1] [1] + prices[i])</li><li>dp[i] [3] = max(dp[i-1] [3], dp[i-1] [2] - prices[i])</li><li>dp[i] [4] = max(dp[i-1] [4], dp[i-1] [3] + prices[i])</li></ul><p>初始化</p><p>dp[0] [0] = 0 ,dp[0] [1] = -prices[0] , dp[0] [2] =  0, dp[0] [3] = -prices[0] , dp[0] [4] =  0 </p><p>遍历</p><p>从左到右</p><pre><code>    public int maxProfit(int[] prices) &#123;        if(prices.length==0)&#123;            return 0;        &#125;        int[][] dp = new int[prices.length][5];        dp[0][1] = dp[0][3] = -prices[0];        for(int i = 1 ;i&lt;prices.length;i++)&#123;            dp[i][1] = Math.max(dp[i-1][1],  -prices[i]);            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);            dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);        &#125;        return Math.max(dp[prices.length-1][2], dp[prices.length-1][4]);    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" >买卖股票的最佳时机 IV<i class="fas fa-external-link-alt"></i></a></p><p><strong>最多买卖k笔交易，问最大收益。</strong></p><p>最多K次交易，也就是最多K次买入，K次卖出</p><p>定义dp[i] [2k+1]， dp[i] [2j+1] 为买入 dp[i] [2j+2] 为卖出</p><p>动态转移方程：</p><p>dp[i] [2j+1]  = max(dp[i-1] [2j+1], dp[i-1] [2j] - prices[i])</p><p>dp[i] [2j+2]  = max(dp[i-1] [2j+2], dp[i-1] [2j+1] + prices[i])</p><p>初始化：</p><p>dp[0] [2j+1] = -prices[0]</p><p>从左到右遍历</p><pre><code>    public int maxProfit(int k, int[] prices) &#123;        if(prices.length &lt; 1)&#123;            return 0;        &#125;                int length = prices.length;        int[][] dp = new int[length][2*k + 1];        for(int j=0;j&lt;k;j++)&#123;            dp[0][2*j+1] = -prices[0];        &#125;        for(int i = 1;i&lt;length;i++)&#123;            for(int j =0;j&lt;k;j++)&#123;                dp[i][2*j+1] = Math.max(dp[i-1][2*j+1], dp[i-1][2*j]-prices[i]);                dp[i][2*j+2] = Math.max(dp[i-1][2*j+2], dp[i-1][2*j+1]+prices[i]);            &#125;        &#125;        return dp[length-1][2*k];    &#125;&#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" >最佳买卖股票时机含冷冻期<i class="fas fa-external-link-alt"></i></a></p><p><strong>可以多次买卖但每次卖出有冷冻期1天。</strong></p><p>定义dp[i] [4]</p><ul><li><p>dp[i] [0]: 买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</p></li><li><p>dp[i] [1]: 两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</p></li><li><p>dp[i] [2]: 今天卖出股票</p></li><li><p>dp[i] [3]：今天为冷冻期状态</p></li></ul><p>动态转移</p><ul><li>dp[i] [0] = max(dp[i-1] [0], dp[i-1] [1] - prices[i], dp[i-1] [3] - prices[i])</li><li>dp[i] [1] = max(dp[i-1] [1], dp[i-1] [3])</li><li>dp[i] [2] = dp[i-1] [0] + prices[i]</li><li>dp[i] [3] = dp[i-1] [2]</li></ul><p>初始化</p><ul><li>dp[0] [0] = -prices[0]</li><li>dp[0] [1] = 0</li><li>dp[0] [2] = 0</li><li>dp[0] [3] = 0</li></ul><p>从左到右遍历</p><pre><code>    public int maxProfit(int[] prices) &#123;        if(prices.length &lt; 1)&#123;            return 0;        &#125;        int length = prices.length;        int[][] dp =new int[length][4];        dp[0][0] = -prices[0];        for(int i =1;i&lt;length;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1] [1] - prices[i], dp[i-1] [3] - prices[i]));            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);            dp[i][2] = dp[i-1][0] + prices[i];            dp[i][3] = dp[i-1][2];        &#125;        return Math.max(dp[length-1][1],Math.max(dp[length-1][2],dp[length-1][3]));    &#125;</code></pre><p><a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" > 买卖股票的最佳时机含手续费<i class="fas fa-external-link-alt"></i></a></p><p><strong>可以多次买卖，但每次有手续费</strong></p><p>卖出的时候减去一个手续费</p><p>所以不持有的情况下，动态方程变成了dp[i] [1] = Math.max(dp[i-1] [1], dp[i-1] [0] + prices[i] - fee);</p><pre><code>    public int maxProfit(int[] prices, int fee所以) &#123;        if(prices.length&lt;=1)&#123;            return 0;        &#125;        int[][] dp = new int[prices.length][2];        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i =1;i&lt;prices.length;i++)&#123;            // 持有            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);            // 不持有            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);        &#125;        return dp[prices.length - 1][1];    &#125;</code></pre><h4 id="状态压缩动态规划"><a href="#状态压缩动态规划" class="headerlink" title="状态压缩动态规划"></a>状态压缩动态规划</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/optimal-account-balancing/" >最优账单平衡<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>public int minTransfers(int[][] transactions) &#123;        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        for(int i =0; i&lt; transactions.length;i++)&#123;            if(!map.containsKey(transactions[i][0]))&#123;                map.put(transactions[i][0], transactions[i][2]);            &#125; else &#123;                map.put(transactions[i][0], map.get(transactions[i][0])+transactions[i][2]);            &#125;            if(!map.containsKey(transactions[i][1]))&#123;                map.put(transactions[i][1], -transactions[i][2]);            &#125; else &#123;                map.put(transactions[i][1], map.get(transactions[i][1])-transactions[i][2]);            &#125;        &#125;        List&lt;Integer&gt; a = new ArrayList&lt;&gt;(); // 收回多少钱        for(Integer value : map.values())&#123;            if(value != 0)&#123;                a.add(value);            &#125;        &#125;        int len =a.size();        int[] cnt = new int[len];        for(int i=0;i&lt;len;i++)&#123;            cnt[i] = a.get(i);        &#125;        int m = 1&lt;&lt;len; // 集合个数        int[] dp = new int[m];        for(int i=1;i&lt;m;i++)&#123; // 枚举每一个子集            // 子集求和            int sum =0;            for(int j=0;j&lt;len;j++)&#123;                // 第j个元素在集合中                if((i&gt;&gt;j &amp; 1) &gt; 0)&#123;                    sum = sum + cnt[j];                &#125;            &#125;            if(sum != 0 )&#123;                dp[i] = Integer.MAX_VALUE/2;            &#125; else &#123;                dp[i] = Integer.bitCount(i)-1; // 计算i的二进制中1的个数                // 枚举集合i的子集                for(int j=(i-1)&amp;i;j&gt;0; j=(j-1)&amp;i)&#123;                    dp[i] = Math.min(dp[i], dp[j]+dp[i^j]);                &#125;            &#125;                    &#125;        return dp[m-1];    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/smallest-sufficient-team/" >最小的必要团队<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public int[] smallestSufficientTeam(String[] req_skills, List&lt;List&lt;String&gt;&gt; people) &#123;        // 技能进行编码 技能1 -&gt; 0 技能2-&gt;1 技能3-&gt;2        // 每个人掌握的技能 二进制表达 111  101        // 把背包装满 所需要的最小人数        int n = req_skills.length;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        for(int i=0;i&lt;req_skills.length;i++)&#123;            map.put(req_skills[i], i);        &#125;        int[] skill = new int[people.size()];        for(int i=0;i&lt;people.size();i++)&#123;            List&lt;String&gt; hasSkill = people.get(i);            for(String s: hasSkill)&#123;                skill[i] = skill[i] | (1&lt;&lt;map.get(s));            &#125;        &#125;        // dp[state] 表示掌握技能的状态为state时，需要的最少人的组合        int[][] dp = new int[1&lt;&lt;n][];        dp[0] = new int[0];        for(int i=0;i&lt;skill.length;i++)&#123;            for(int j=0;j&lt;(1&lt;&lt;n);j++)&#123;                if(dp[j] == null)&#123;                    continue;                &#125;                int cur = skill[i] | j;                // 还未被赋值过 或者 存在更小的路径                if(dp[cur] == null || dp[j].length + 1 &lt; dp[cur].length)&#123;                    dp[cur] = Arrays.copyOf(dp[j], dp[j].length + 1);                    dp[cur][dp[j].length] = i;                &#125;            &#125;        &#125;        return dp[(1&lt;&lt;n) - 1];    &#125;</code></pre><h3 id="4-回溯法"><a href="#4-回溯法" class="headerlink" title="4.回溯法"></a>4.回溯法</h3><pre><code>void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>N个数里面按一定规则找出k个数的集合</p><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/combinations/" > 组合<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    private List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        dfs(n,k,1);        return result;    &#125;    private void dfs(int n, int k, int start)&#123;        // 2  n = 5 start = 4 k = 5        if(path.size() + n- start + 1 &lt; k)&#123;            return;        &#125;        if(path.size() == k)&#123;            result.add(new ArrayList&lt;Integer&gt;(path));            return;        &#125;        for(int i = start; i&lt;=n;i++)&#123;            path.add(i);            dfs(n,k,i+1);            path.remove(path.size()-1);        &#125;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/combination-sum-iii/" >组合总和 III<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    private List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;        dfs(k,n,1,0);        return result;    &#125;    private void dfs(int k , int n, int start,int sum)&#123;        if( sum == n &amp;&amp; path.size() == k)&#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        if( sum &gt; n || path.size()&gt;k)&#123;            return;        &#125;        for(int i = start;i&lt;=9;i++)&#123;            path.add(i);            sum = sum + i;            dfs(k,n,i+1, sum);            path.remove(path.size()-1);            sum = sum -i;        &#125;    &#125;&#125;</code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" >电话号码的字母组合<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    Map&lt;Character, String&gt; phoneMap = new HashMap&lt;Character, String&gt;() &#123;&#123;        put('2', "abc");        put('3', "def");        put('4', "ghi");        put('5', "jkl");        put('6', "mno");        put('7', "pqrs");        put('8', "tuv");        put('9', "wxyz");    &#125;&#125;;    private List&lt;String&gt; result = new ArrayList&lt;&gt;();    private List&lt;Character&gt; s = new ArrayList&lt;Character&gt;();    public List&lt;String&gt; letterCombinations(String digits) &#123;        if(digits.length() == 0)&#123;            return new ArrayList&lt;&gt;();        &#125;        dfs(digits, 0);        return result;    &#125;    private void dfs(String digits, int index)&#123;        if(index == digits.length())&#123;            StringBuilder sb = new StringBuilder();            for(int i=0;i&lt;index;i++)&#123;                sb.append(s.get(i));            &#125;            result.add(sb.toString());            return;        &#125;        String str = phoneMap.get(digits.charAt(index));        for(int j=0;j&lt;str.length();j++)&#123;            s.add(str.charAt(j));            dfs(digits, index+1);            s.remove(s.size()-1);        &#125;            &#125;</code></pre><p><strong>4.<a class="link"   href="https://leetcode.cn/problems/combination-sum/" >组合总和<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        dfs(candidates, 0, 0, target, new ArrayList&lt;Integer&gt;());        return result;    &#125;    private void dfs(int[] candidates, int start, int sum, int target, List&lt;Integer&gt; path)&#123;        if(sum == target)&#123;            result.add(new ArrayList&lt;Integer&gt;(path));            return;        &#125;        if(sum&gt;target)&#123;            return;        &#125;        for(int i=start;i&lt;candidates.length;i++)&#123;            sum = sum + candidates[i];            path.add(candidates[i]);            dfs(candidates, i, sum, target, path);            sum = sum - candidates[i];            path.remove(path.size()-1);        &#125;    &#125;</code></pre><p><strong>5.<a class="link"   href="https://leetcode.cn/problems/combination-sum-ii/" >组合总和 II<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        Arrays.sort(candidates);        dfs(candidates,0,0,target,new ArrayList&lt;Integer&gt;());        return result;    &#125;    private void dfs(int[] candidates, int start, int sum, int target, List&lt;Integer&gt; path)&#123;        if(sum == target)&#123;            result.add(new ArrayList&lt;Integer&gt;(path));            return;        &#125;        if(sum&gt;target)&#123;            return;        &#125;        for(int i=start;i&lt;candidates.length;i++)&#123;            // 同一层相同元素去重            if(i != start &amp;&amp; candidates[i] == candidates[i-1])&#123;                continue;            &#125;            sum = sum + candidates[i];            path.add(candidates[i]);            dfs(candidates, i+1, sum, target, path);            sum = sum - candidates[i];            path.remove(path.size()-1);        &#125;    &#125;</code></pre><h4 id="分割问题-1"><a href="#分割问题-1" class="headerlink" title="分割问题"></a>分割问题</h4><p>切割问题其实是一种组合问题</p><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/palindrome-partitioning/" >分割回文串<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;        dfs(s,0,new ArrayList&lt;String&gt;());        return result;    &#125;    private void dfs(String s, int start, List&lt;String&gt; path)&#123;                if(path.size() &gt;=1 &amp;&amp; !isCycStr(path.get(path.size()-1)))&#123;            return;        &#125;        if(start == s.length())&#123;            result.add(new ArrayList&lt;String&gt;(path));            return;        &#125;        for(int j=start+1;j&lt;=s.length();j++)&#123;            String subStr = s.substring(start, j);            path.add(subStr);            dfs(s, j, path);            path.remove(path.size()-1);        &#125;            &#125;    private boolean isCycStr(String s)&#123;        if(s.length() == 1)&#123;            return true;        &#125;        int n = s.length()/2;        for(int i=0;i&lt;n;i++)&#123;            if(s.charAt(i) != s.charAt(s.length()-i-1))&#123;                return false;            &#125;        &#125;        return true;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/restore-ip-addresses/" >复原 IP 地址<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;String&gt; result = new ArrayList&lt;&gt;();    public List&lt;String&gt; restoreIpAddresses(String s) &#123;        dfs(s, 0, 0, new ArrayList&lt;Integer&gt;());        return result;    &#125;    private void dfs(String s, int end, int k, List&lt;Integer&gt; path)&#123;        if(k &gt;= 1)&#123;            int start = path.size() == 1? 0:path.get(path.size()-2);            String str = s.substring(start, end);            if(!isValidIp(str))&#123;                return;            &#125;            if(end == s.length() &amp;&amp; k &lt; 4)&#123;                return;            &#125;            if(end == s.length() &amp;&amp; k == 4)&#123;                StringBuilder sb = new StringBuilder();                for(int i=0; i&lt;path.size();i++)&#123;                    if(i==0)&#123;                        sb = sb.append(s.substring(0, path.get(0)));                    &#125;else&#123;                        sb = sb.append(&quot;.&quot;).append(s.substring(path.get(i-1), path.get(i)));                    &#125;                &#125;                result.add(sb.toString());            &#125;                &#125;        for(int i = end + 1; i&lt;=s.length(); i++)&#123;            path.add(i);            k++;            dfs(s, i, k, path);            k--;            path.remove(path.size()-1);        &#125;    &#125;    private boolean isValidIp(String s)&#123;                if(s.length() == 1)&#123;            return true;        &#125;        if(s.length() &gt; 3)&#123;            return false;        &#125;        if(s.charAt(0) == &#39;0&#39;)&#123;            return false;        &#125;        int value = Integer.valueOf(s);        if(value &gt; 255)&#123;            return false;        &#125;        return true;    &#125;</code></pre><h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><p>组合和分割问题：记录叶子节点</p><p>子集问题：记录所有节点</p><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/subsets/" >子集<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        dfs(nums, 0, new ArrayList&lt;Integer&gt;());        return result;    &#125;    private void dfs(int[] nums, int start, List&lt;Integer&gt; path)&#123;        result.add(new ArrayList&lt;Integer&gt;(path));        for(int i=start; i&lt; nums.length;i++)&#123;            path.add(nums[i]);            dfs(nums, i+1, path);            path.remove(path.size()-1);        &#125;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/subsets-ii/" >子集 II<i class="fas fa-external-link-alt"></i></a></strong></p><p>遍历所有节点，同一高度下value相同的节点去重（树枝去重）</p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;        Arrays.sort(nums);        dfs(nums, 0, new ArrayList&lt;Integer&gt;());        return result;    &#125;    private void dfs(int[] nums, int start, List&lt;Integer&gt; path)&#123;        result.add(new ArrayList&lt;Integer&gt;(path));        for(int i=start; i&lt; nums.length;i++)&#123;            if(i!=start &amp;&amp; nums[i] == nums[i-1])&#123;                continue;            &#125;            path.add(nums[i]);            dfs(nums, i+1, path);            path.remove(path.size()-1);        &#125;    &#125; </code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/increasing-subsequences/" >递增子序列<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;        dfs(nums,0,new ArrayList&lt;Integer&gt;(),0);        return result;    &#125;    private void dfs(int[] nums, int start, List&lt;Integer&gt; path, int k)&#123;        if(k&gt;=2)&#123;            if(path.get(path.size()-1) &lt; path.get(path.size()-2))&#123;                return;            &#125;            result.add(new ArrayList&lt;Integer&gt;(path));        &#125;                // 同一层元素去重        Set&lt;Integer&gt; used = new HashSet&lt;&gt;();        for(int i=start; i&lt; nums.length;i++)&#123;            if(used.contains(nums[i]))&#123;                continue;            &#125;            used.add(nums[i]);            path.add(nums[i]);            dfs(nums, i+1, path, k+1);            path.remove(path.size()-1);        &#125;    &#125; </code></pre><h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/permutations/" >全排列<i class="fas fa-external-link-alt"></i></a></strong></p><p>记录path路径，元素去重</p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        dfs(nums, new ArrayList&lt;Integer&gt;(), new HashSet&lt;&gt;());        return result;    &#125;    private void dfs(int[] nums, List&lt;Integer&gt; path, Set&lt;Integer&gt; used)&#123;        if(path.size() == nums.length)&#123;            result.add(new ArrayList&lt;Integer&gt;(path));            return;        &#125;        for(int i=0;i&lt;nums.length;i++)&#123;            if(used.contains(nums[i]))&#123;                continue;            &#125;            path.add(nums[i]);            used.add(nums[i]);            dfs(nums, path, used);            path.remove(path.size()-1);            used.remove(nums[i]);        &#125;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/permutations-ii/" >全排列 II<i class="fas fa-external-link-alt"></i></a></strong></p><p>path和同一层同时去重</p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        dfs(nums, new ArrayList&lt;Integer&gt;(), new HashSet&lt;&gt;());        return result;    &#125;    private void dfs(int[] nums, List&lt;Integer&gt; path, Set&lt;Integer&gt; used)&#123;        if(path.size() == nums.length)&#123;            result.add(new ArrayList&lt;Integer&gt;(path));            return;        &#125;        Set&lt;Integer&gt; used2 = new HashSet&lt;&gt;();        for(int i=0;i&lt;nums.length;i++)&#123;            if(used.contains(i) || used2.contains(nums[i]))&#123;                continue;            &#125;            path.add(nums[i]);            used.add(i);            used2.add(nums[i]);            dfs(nums, path, used);            path.remove(path.size()-1);            used.remove(i);        &#125;    &#125;</code></pre><h4 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/n-queens/" >N 皇后<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>private List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;       dfs(n, new ArrayList&lt;Integer&gt;());       return result;     &#125;    private void dfs(int n, List&lt;Integer&gt; queens)&#123;        if(queens.size() == n)&#123;            result.add(buildRecord(n, queens));            return;        &#125;        int i = queens.size();        boolean[][] board = updateBoard(queens, n);        for(int j=0;j&lt;n;j++)&#123;            if(board[i][j] == true)&#123;                continue;            &#125;            queens.add(j);            dfs(n, queens);            queens.remove(queens.size()-1);        &#125;    &#125;    private boolean[][]  updateBoard(List&lt;Integer&gt; queens, int n)&#123;        boolean[][] board = new boolean[n][n];        for(int i=0;i&lt;queens.size();i++)&#123;            int j = queens.get(i);            for(int p=0;p&lt;n;p++)&#123;                for(int q=0;q&lt;n;q++)&#123;                    if(p==i || q==j || (i-j)==(p-q) || (i+j)==(q+p))&#123;                        board[p][q] = true;                    &#125;                &#125;            &#125;        &#125;        return board;    &#125;    private List&lt;String&gt; buildRecord(int n, List&lt;Integer&gt; queens)&#123;                List&lt;String&gt; record = new ArrayList&lt;&gt;();        for(int i=0;i&lt;queens.size();i++)&#123;            int queenPosition = queens.get(i);            StringBuilder sb = new StringBuilder();            for(int j=0;j&lt;n;j++)&#123;                if(queenPosition == j)&#123;                    sb.append(&quot;Q&quot;);                &#125;else&#123;                    sb.append(&quot;.&quot;);                &#125;            &#125;            record.add(sb.toString());        &#125;        return record;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/sudoku-solver/" >解数独<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private boolean findResult = false;    public void solveSudoku(char[][] board) &#123;         dfs(board, 0);         int a = 1;    &#125;    private void dfs(char[][] board, int positon)&#123;        if(positon == 9*9 || findResult==true)&#123;            findResult = true;            return;        &#125;        int m = positon/9;        int n = positon%9;        if(board[m][n] != &#39;.&#39;)&#123;            dfs(board, positon+1);            return;        &#125;        List&lt;Character&gt; choice = findChoice(board, m, n);        if(choice.size() == 0)&#123;            return;        &#125;        for(int i = 0;i &lt; choice.size(); i++)&#123;            board[m][n] = choice.get(i);            dfs(board, positon+1);            if(findResult == true)&#123;                return;            &#125;            board[m][n] = &#39;.&#39;;        &#125;    &#125;    private List&lt;Character&gt; findChoice(char[][] board, int m, int n)&#123;        boolean[] used = new boolean[10];        // m = 3 n = 0 p=1 q=0        int p = m/3; int q = n/3;        for(int i = 0 ; i &lt; 9; i++)&#123;            if(board[m][i] != &#39;.&#39;)&#123;                used[board[m][i] - &#39;0&#39;] = true;            &#125;            if(board[i][n] != &#39;.&#39;)&#123;                used[board[i][n] - &#39;0&#39;] = true;            &#125;            if(board[3*p + i/3][3*q + i%3] != &#39;.&#39;)&#123;                used[board[3*p + i/3][3*q + i%3] - &#39;0&#39;] = true;            &#125;        &#125;        List&lt;Character&gt; choice = new ArrayList&lt;&gt;();        for(int i=1 ; i&lt;=9;i++)&#123;            if(used[i] == false)&#123;                char b = (char)(i+48);                choice.add(b);            &#125;        &#125;        return choice;    &#125;</code></pre><h4 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/the-maze/" > 迷宫<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public boolean hasPath(int[][] maze, int[] start, int[] destination) &#123;                boolean[][] visited = new boolean[maze.length][maze[0].length];        visited[start[0]][start[1]] = true;        dfs(maze, start, visited);        return visited[destination[0]][destination[1]];    &#125;    private void dfs(int[][] maze, int[] start, boolean[][] visited)&#123;        int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;        for(int[] dir: dirs)&#123;            int x= start[0] + dir[0];            int y =start[1] + dir[1];            while(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;maze.length &amp;&amp; y&lt;maze[0].length &amp;&amp; maze[x][y] ==0)&#123;                x = x + dir[0];                y= y + dir[1];            &#125;            if(visited[x-dir[0]][y-dir[1]] == false)&#123;                visited[x-dir[0]][y-dir[1]] = true;                dfs(maze, new int[]&#123;x-dir[0], y-dir[1]&#125;, visited);            &#125;        &#125;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/the-maze-ii/" >迷宫 II<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private int result = Integer.MAX_VALUE;    public int shortestDistance(int[][] maze, int[] start, int[] destination) &#123;                int[][] len = new int[maze.length][maze[0].length];        for(int i=0;i&lt;maze.length;i++)&#123;            for(int j=0;j&lt;maze[0].length;j++)&#123;                len[i][j] = Integer.MAX_VALUE;            &#125;        &#125;        len[start[0]][start[1]] = 0;        dfs(maze, start, len);        return len[destination[0]][destination[1]] == Integer.MAX_VALUE? -1:len[destination[0]][destination[1]];    &#125;    private void dfs(int[][] maze, int[] position, int[][] len)&#123;        int m = maze.length;        int n = maze[0].length;        int[][] dirs=&#123;&#123;0,1&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;, &#123;1,0&#125;&#125;;        for(int[] dir : dirs)&#123;            int x = position[0] + dir[0];            int y = position[1] + dir[1];            int curlen=1;            while(x&gt;=0 &amp;&amp; x &lt;=m-1 &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=n-1 &amp;&amp; maze[x][y] == 0)&#123;                x = x+ dir[0];                y = y + dir[1];                curlen++;            &#125;            if(len[position[0]][position[1]] + curlen - 1 &lt; len[x-dir[0]][y-dir[1]])&#123;                len[x-dir[0]][y-dir[1]] = len[position[0]][position[1]] + curlen - 1;                dfs(maze, new int[]&#123;x-dir[0], y-dir[1]&#125;, len);            &#125;        &#125;    &#125;</code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/the-maze-iii/" >迷宫 III<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private String result = &quot;impossible&quot;;    public String findShortestWay(int[][] maze, int[] ball, int[] hole) &#123;                int[][] len = new int[maze.length][maze[0].length];        for(int i=0;i&lt;maze.length;i++)&#123;            for(int j=0;j&lt;maze[0].length;j++)&#123;                len[i][j] = Integer.MAX_VALUE;            &#125;        &#125;        len[ball[0]][ball[1]] = 0;        dfs(maze, ball, hole, len, new ArrayList&lt;String&gt;());        return result;    &#125;    private void dfs(int[][] maze, int[] ball, int[] hole, int[][] len, List&lt;String&gt; path)&#123;                        //  d l r u        int[][] dirs = &#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;        Map&lt;Integer, String&gt; dirMap = new HashMap&lt;&gt;();        dirMap.put(0, &quot;d&quot;);dirMap.put(1, &quot;l&quot;);dirMap.put(2, &quot;r&quot;);dirMap.put(3, &quot;u&quot;);        for(int i=0;i&lt;=3;i++)&#123;            int[] dir = dirs[i];            String dirch = dirMap.get(i);            int x = ball[0] + dir[0];            int y = ball[1] + dir[1];            int curlen = 0;            while(x&gt;=0 &amp;&amp; y &gt;=0 &amp;&amp; x &lt; maze.length &amp;&amp; y&lt;maze[0].length &amp;&amp; maze[x][y]==0)&#123;                if((x == hole[0] &amp;&amp; y== hole[1]) &amp;&amp; len[ball[0]][ball[1]]+curlen+1&lt;len[x][y])&#123;                                        len[x][y] = len[ball[0]][ball[1]]+curlen+1;                    StringBuffer sb = new StringBuffer();                    for(String s : path)&#123;                        sb = sb.append(s);                    &#125;                    sb.append(dirch);                    result = sb.toString();                    return;                &#125;                x=x+dir[0];                y=y+dir[1];                curlen++;            &#125;            if(len[ball[0]][ball[1]] + curlen &lt; len[x-dir[0]][y-dir[1]])&#123;                                path.add(dirch);                len[x-dir[0]][y-dir[1]] = len[ball[0]][ball[1]] + curlen;                if(x-dir[0] == hole[0] &amp;&amp; y-dir[1] == hole[1])&#123;                                        StringBuffer sb = new StringBuffer();                    for(String s : path)&#123;                        sb = sb.append(s);                    &#125;                    result = sb.toString();                    return;                &#125;                dfs(maze, new int[]&#123;x-dir[0], y-dir[1]&#125;, hole, len, path);                path.remove(path.size()-1);            &#125;        &#125;    &#125;</code></pre><p><strong>4.<a class="link"   href="https://leetcode.cn/problems/escape-a-large-maze/" >逃离大迷宫<i class="fas fa-external-link-alt"></i></a></strong></p><p>广度优先搜索</p><p>队列：Queue 操作：add() poll() peek()</p><p>双端队列：Deque 操作: add()  pollFirst() pollLast() peekFirst() peekLast()</p><p>抛出队首元素</p><pre><code>    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) &#123;        long EDGE = (int)1e6;        if(blocked.length&lt;2)&#123;            return true;        &#125;                boolean a = bfs(blocked, source, target);        boolean b = bfs(blocked, target, source);        return a&amp;&amp;b;    &#125;    private boolean bfs(int[][] blocked, int[] source, int[] target)&#123;        long EDGE = (int)1e6;        int n = blocked.length;        int max = (n)*(n-1)/2;        Set&lt;Long&gt; visited = new HashSet&lt;&gt;();        visited.add(source[0]*EDGE + source[1]);        Deque&lt;Long&gt; deque = new ArrayDeque&lt;&gt;();        deque.add(source[0]*EDGE + source[1]);        while(!deque.isEmpty() &amp;&amp; visited.size()&lt;=max)&#123;            long p = deque.pollFirst();            long x =  p / EDGE;            long y = p - x*EDGE;            int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;            for(int[] dir : dirs)&#123;                long nx = x + dir[0];                long ny = y + dir[1];                if(nx == target[0] &amp;&amp; ny == target[1])&#123;                    return true;                &#125;                if(nx&gt;=0 &amp;&amp; ny&gt;=0 &amp;&amp; nx&lt;EDGE&amp;&amp;ny&lt;EDGE &amp;&amp; notInBlock(nx, ny, blocked) &amp;&amp; visited.contains(nx * EDGE + ny) == false)&#123;                    visited.add(nx * EDGE + ny);                    deque.add(nx * EDGE + ny);                &#125;;            &#125;        &#125;        return visited.size()&gt;max;    &#125;      private boolean notInBlock(long nx , long ny , int[][] blocked)&#123;        for(int[] block : blocked)&#123;            if(block[0] == nx &amp;&amp; block[1] == ny)&#123;                return false;            &#125;        &#125;        return true;    &#125;</code></pre><h4 id="二维网格搜索问题"><a href="#二维网格搜索问题" class="headerlink" title="二维网格搜索问题"></a>二维网格搜索问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/detect-cycles-in-2d-grid/" >二维网格图中探测环<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>class Solution &#123;    public boolean containsCycle(char[][] grid) &#123;        if(grid.length&lt;=1 || grid[0].length&lt;=1)&#123;            return false;        &#125;        boolean[][] visited = new boolean[grid.length][grid[0].length];        // 环：从任意一个点出发 上下左右移动 能回到原点        for(int i=0;i&lt;grid.length;i++)&#123;            for(int j=0;j&lt;grid[0].length;j++)&#123;                if(visited[i][j] == false)&#123;                    if(dfs(grid, i,j, grid[i][j], visited,-1,-1))&#123;                        return true;                    &#125;                &#125;            &#125;        &#125;        return false;    &#125;    private  boolean dfs(char[][] grid, int x, int y, char ch,  boolean[][] visited, int oldx ,int oldy)&#123;        if (visited[x][y]) return true;        visited[x][y] = true;        int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;        for(int[] dir : dirs)&#123;            int curx = x + dir[0];            int cury =y + dir[1];            if(curx&gt;=0&amp;&amp;cury&gt;=0&amp;&amp;curx&lt;grid.length&amp;&amp;cury&lt;grid[0].length&amp;&amp;grid[curx][cury]==ch &amp;&amp; (curx!=oldx || cury!=oldy))&#123;                if(dfs(grid, curx, cury, ch, visited, x,y))&#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h3><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>前中后遍历方式，指的就是中间节点的遍历顺序</p><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" >二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;Integer&gt; result = new ArrayList&lt;&gt;();    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        // 左中右        dfs(root);        return result;    &#125;       private void dfs(TreeNode node)&#123;        if(node == null)&#123;            return;        &#125;        dfs(node.left);        result.add(node.val);        dfs(node.right);    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" >二叉树的前序遍历<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;Integer&gt; result = new ArrayList&lt;&gt;();    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        // 中左右        dfs(root);        return result;    &#125;    private void dfs(TreeNode node)&#123;        if(node == null)&#123;            return;        &#125;        result.add(node.val);        dfs(node.left);        dfs(node.right);    &#125;</code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" >二叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;Integer&gt; result = new ArrayList&lt;&gt;();    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        // 左右中        dfs(root);        return result;    &#125;    private void dfs(TreeNode node)&#123;        if(node == null)&#123;            return;        &#125;        dfs(node.left);        dfs(node.right);        result.add(node.val);    &#125;</code></pre><p><strong>4.<a class="link"   href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" >二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        if(root==null)&#123;            return result;        &#125;        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();        que.offer(root);        while(que.size()&gt;0)&#123;            List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;();            int size = que.size();            for(int i=0;i&lt;size;i++)&#123;                TreeNode node = que.poll();                valueList.add(node.val);                if(node.left!=null)&#123;                    que.offer(node.left);                &#125;                if(node.right!=null)&#123;                    que.offer(node.right);                &#125;            &#125;            result.add(valueList);        &#125;        return result;    &#125;</code></pre><p><strong>5.<a class="link"   href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" >二叉树的层序遍历 II<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;       List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        if(root==null)&#123;            return result;        &#125;        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();        que.offer(root);        while(que.size()&gt;0)&#123;            List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;();            int size = que.size();            for(int i=0;i&lt;size;i++)&#123;                TreeNode node = que.poll();                valueList.add(node.val);                if(node.left!=null)&#123;                    que.offer(node.left);                &#125;                if(node.right!=null)&#123;                    que.offer(node.right);                &#125;            &#125;            result.add(valueList);        &#125;        List&lt;List&lt;Integer&gt;&gt; resultNew = new ArrayList&lt;&gt;();        for(int i=0;i&lt;result.size();i++)&#123;            resultNew.add(result.get(result.size()-i-1));        &#125;            return resultNew;    &#125;</code></pre><p><strong>6.<a class="link"   href="https://leetcode.cn/problems/binary-tree-right-side-view/" >二叉树的右视图<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if(root==null)&#123;            return result;        &#125;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while(queue.size()&gt;0)&#123;            int size = queue.size();            for(int i=0;i&lt;size;i++)&#123;                TreeNode node = queue.poll();                if(i==size-1)&#123;                    result.add(node.val);                &#125;                if(node.left!=null)&#123;                    queue.offer(node.left);                &#125;                if(node.right!=null)&#123;                    queue.offer(node.right);                &#125;            &#125;        &#125;        return result;    &#125;</code></pre><p><strong>7.<a class="link"   href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" >二叉树的层平均值<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;        List&lt;Double&gt; result = new ArrayList&lt;&gt;();        if(root==null)&#123;            return result;        &#125;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while(queue.size()&gt;0)&#123;            int size = queue.size();            double sum = 0;            for(int i=0;i&lt;size;i++)&#123;                TreeNode node = queue.poll();                sum = sum + node.val;                if(node.left!=null)&#123;                    queue.offer(node.left);                &#125;                if(node.right!=null)&#123;                    queue.offer(node.right);                &#125;            &#125;            result.add(sum/size);        &#125;        return result;    &#125;</code></pre><p><strong>8.<a class="link"   href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" >N 叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;                List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        if(root==null)&#123;            return result;        &#125;        Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;();        que.offer(root);        while(que.size()&gt;0)&#123;            List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;();            int size = que.size();            for(int i=0;i&lt;size;i++)&#123;                Node node = que.poll();                valueList.add(node.val);                if(node.children == null || node.children.size()==0)&#123;                    continue;                &#125;                for(Node childrenNode: node.children)&#123;                    if(childrenNode!=null)&#123;                        que.offer(childrenNode);                    &#125;                &#125;            &#125;            result.add(valueList);        &#125;         return result;    &#125;</code></pre><p><strong>9.<a class="link"   href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" >在每个树行中找最大值<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if(root==null)&#123;            return result;        &#125;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while(queue.size()&gt;0)&#123;            int size = queue.size();            int max = Integer.MIN_VALUE;            for(int i=0;i&lt;size;i++)&#123;                TreeNode node = queue.poll();                if(node.val&gt;max)&#123;                    max = node.val;                &#125;                if(node.left!=null)&#123;                    queue.offer(node.left);                &#125;                if(node.right!=null)&#123;                    queue.offer(node.right);                &#125;            &#125;            result.add(max);        &#125;        return result;    &#125;</code></pre><p><strong>10.<a class="link"   href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" >填充每个节点的下一个右侧节点指针<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public Node connect(Node root) &#123;        if(root==null)&#123;            return root;        &#125;        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while(queue.size()&gt;0)&#123;            // 获取size一定要在poll操作前面，因为poll操作是删除并获取一个元素，会导致queue size 变化            int size = queue.size();            Node node = queue.poll();            if(node.left!=null)&#123;                queue.offer(node.left);            &#125;            if(node.right!=null)&#123;                queue.offer(node.right);            &#125;            for(int i=0;i&lt;size-1;i++)&#123;                Node nodeNext = queue.poll();                                if(nodeNext.left!=null)&#123;                    queue.offer(nodeNext.left);                &#125;                if(nodeNext.right!=null)&#123;                    queue.offer(nodeNext.right);                &#125;                node.next = nodeNext;                node = nodeNext;            &#125;        &#125;        return root;    &#125;</code></pre><h4 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/symmetric-tree/" >对称二叉树<i class="fas fa-external-link-alt"></i></a></strong></p><p>左子树的右边和右子树的左边比</p><p>左子树的左边和右子树的右边比</p><pre><code>    public boolean isSymmetric(TreeNode root) &#123;        if(root == null)&#123;            return true;        &#125;        return compare(root.left, root.right);    &#125;    private boolean compare(TreeNode left, TreeNode right)&#123;        if(left == null &amp;&amp; right == null)&#123;            return true;        &#125;        if(left != null &amp;&amp; right != null)&#123;            return (right.val==left.val) &amp;&amp; compare(left.right, right.left) &amp;&amp; compare(left.left, right.right);        &#125;        return false;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" >二叉树的最大深度<i class="fas fa-external-link-alt"></i></a></strong></p><p>深度搜索</p><pre><code>    private int result = 0;    public int maxDepth(TreeNode root) &#123;        dfs(root, 0);        return result;    &#125;    private void dfs(TreeNode root, int depth)&#123;        if(root == null)&#123;            result = Math.max(result, depth);            return;        &#125;        depth++;        dfs(root.left, depth);        dfs(root.right, depth);    &#125;</code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" >二叉树的最小深度<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>   private int result = Integer.MAX_VALUE;    public int minDepth(TreeNode root) &#123;        if(root == null)&#123;            return 0;        &#125;        dfs(root, 1);        return result;    &#125;    private void dfs(TreeNode root, int depth)&#123;        if(root.left == null &amp;&amp; root.right == null)&#123;            result = Math.min(result, depth);            return;        &#125;        if(root.left!=null)&#123;            dfs(root.left, depth+1);        &#125;        if(root.right!=null)&#123;            dfs(root.right, depth+1);        &#125;    &#125;</code></pre><p><strong>4.<a class="link"   href="https://leetcode.cn/problems/count-complete-tree-nodes/" >完全二叉树的节点个数<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public int countNodes(TreeNode root) &#123;        return dfs(root);    &#125;    private int dfs(TreeNode root)&#123;        if(root == null)&#123;            return 0;        &#125;        return 1 + dfs(root.left) + dfs(root.right);    &#125;</code></pre><p><strong>5.<a class="link"   href="https://leetcode.cn/problems/balanced-binary-tree/" >平衡二叉树<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    Map&lt;TreeNode, Integer&gt; depth = new HashMap&lt;&gt;();    public boolean isBalanced(TreeNode root) &#123;        if(root == null)&#123;            return true;        &#125;        depth.put(root, calDepth(root));                return isAvg(root);    &#125;    private int calDepth(TreeNode root)&#123;        if(root == null)&#123;            return 0;        &#125;        int leftDepth = 0;        int rightDepth = 0;        if(root.left!=null)&#123;            leftDepth = calDepth(root.left);            depth.put(root.left, leftDepth);        &#125;        if(root.right!=null)&#123;            rightDepth = calDepth(root.right);            depth.put(root.right, rightDepth);        &#125;        return 1 + Math.max(leftDepth, rightDepth);    &#125;    private boolean isAvg(TreeNode root)&#123;        if(root == null)&#123;            return true;        &#125;        int leftDepth = 0;        if(root.left != null)&#123;            leftDepth = depth.get(root.left);        &#125;        int rightDepth = 0;        if(root.right != null)&#123;            rightDepth = depth.get(root.right);        &#125;        return isAvg(root.left) &amp;&amp; isAvg(root.right) &amp;&amp; Math.abs(leftDepth-rightDepth)&lt;=1;     &#125;</code></pre><p><strong>6.<a class="link"   href="https://leetcode.cn/problems/binary-tree-paths/" >二叉树的所有路径<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;String&gt; result = new ArrayList&lt;&gt;();    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        dfs(root, new ArrayList&lt;Integer&gt;());        return result;    &#125;    private void dfs(TreeNode root, List&lt;Integer&gt; path)&#123;        path.add(root.val);        if(root.left == null &amp;&amp; root.right == null)&#123;            StringBuilder sb = new StringBuilder();            sb.append(String.valueOf(path.get(0)));            for(int i=1;i&lt;path.size();i++)&#123;                sb.append(&quot;-&gt;&quot;).append(String.valueOf(path.get(i)));            &#125;            result.add(sb.toString());            return;        &#125;        if(root.left!=null)&#123;            dfs(root.left, path);            path.remove(path.size()-1);        &#125;                if(root.right!=null)&#123;            dfs(root.right, path);            path.remove(path.size()-1);        &#125;    &#125;</code></pre><p><strong>7.<a class="link"   href="https://leetcode.cn/problems/sum-of-left-leaves/" > 左叶子之和<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public int sumOfLeftLeaves(TreeNode root) &#123;        if(root.left == null &amp;&amp; root.right == null)&#123;            return 0;        &#125;        return dfs(root);    &#125;    private int dfs(TreeNode root)&#123;        if(root.left == null &amp;&amp; root.right == null)&#123;            return root.val;        &#125;        int sum = 0;        if(root.left != null)&#123;            sum = sum + dfs(root.left);        &#125;        if(root.right != null &amp;&amp; (root.right.left!=null || root.right.right!=null))&#123;            sum = sum + dfs(root.right);        &#125;        return sum;    &#125;</code></pre><p><strong>8.<a class="link"   href="https://leetcode.cn/problems/find-bottom-left-tree-value/" >找树左下角的值<i class="fas fa-external-link-alt"></i></a></strong></p><p>同一高度优先用左节点的value</p><pre><code>    private int result;    private int depth=0;    public int findBottomLeftValue(TreeNode root) &#123;        dfs(root, 1);        return result;    &#125;    private void dfs(TreeNode root, int curDepth)&#123;        if(root.left == null &amp;&amp; root.right == null)&#123;            if(curDepth &gt; depth)&#123;                result = root.val;                depth = curDepth;            &#125;        &#125;        if(root.left!=null)&#123;            dfs(root.left, curDepth+1);        &#125;        if(root.right!= null)&#123;            dfs(root.right, curDepth+1);        &#125;    &#125;</code></pre><p><strong>9.<a class="link"   href="https://leetcode.cn/problems/path-sum/" >路径总和<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public boolean hasPathSum(TreeNode root, int targetSum) &#123;        if(root == null)&#123;            return false;        &#125;        return dfs(root, root.val, targetSum);    &#125;    private boolean dfs(TreeNode root, int curSum, int targetSum)&#123;        if(root.left == null &amp;&amp; root.right == null)&#123;            return curSum==targetSum;        &#125;        boolean leftResult = false;        if(root.left!=null)&#123;            leftResult = dfs(root.left, curSum+root.left.val, targetSum);        &#125;        boolean rightResult = false;        if(root.right!=null)&#123;            rightResult = dfs(root.right, curSum+root.right.val, targetSum);        &#125;        return leftResult || rightResult;    &#125;</code></pre><p><strong>10.<a class="link"   href="https://leetcode.cn/problems/path-sum-ii/" >路径总和 II<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;        if(root == null)&#123;            return result;        &#125;        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();        path.add(root.val);        dfs(root, root.val, targetSum, path);        return result;    &#125;    private void dfs(TreeNode root, int curSum, int targetSum, List&lt;Integer&gt; path)&#123;        if(root.left == null &amp;&amp; root.right == null)&#123;            if(curSum==targetSum)&#123;                result.add(new ArrayList&lt;Integer&gt;(path));            &#125;        &#125;        if(root.left!=null)&#123;            path.add(root.left.val);            dfs(root.left, curSum+root.left.val, targetSum, path);            path.remove(path.size()-1);        &#125;        if(root.right!=null)&#123;            path.add(root.right.val);            dfs(root.right, curSum+root.right.val, targetSum, path);            path.remove(path.size()-1);        &#125;    &#125;</code></pre><h4 id="二叉树的修改和构造"><a href="#二叉树的修改和构造" class="headerlink" title="二叉树的修改和构造"></a>二叉树的修改和构造</h4><p><strong>1.</strong><a class="link"   href="https://leetcode.cn/problems/invert-binary-tree/" > 翻转二叉树<i class="fas fa-external-link-alt"></i></a></p><pre><code>    public TreeNode invertTree(TreeNode root) &#123;                if(root == null || (root.left == null &amp;&amp; root.right == null))&#123;            return root;        &#125;        dfs(root);        return root;    &#125;    private void dfs(TreeNode root)&#123;        if(root.left == null &amp;&amp; root.right == null)&#123;            return;        &#125;        if(root.left != null)&#123;            dfs(root.left);        &#125;        if(root.right != null)&#123;            dfs(root.right);        &#125;        if(root.left != null)&#123;            TreeNode node = new TreeNode(root.left.val, root.left.left, root.left.right);            root.left = root.right;            root.right = node;        &#125; else &#123;            TreeNode node = new TreeNode(root.right.val, root.right.left, root.right.right);            root.right = root.left;            root.left = node;        &#125;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" >从中序与后序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;         //inorder 左中右 9 3 15 20 7        //postorder 左右中 9 15 7 20 3        return traversal(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1);    &#125;    private TreeNode traversal(int[] inorder, int start1, int end1, int[] postorder, int start2, int end2)&#123;        // 找跟根节点        int rootVal = postorder[end2];        TreeNode root = new TreeNode(rootVal);        if(start2 == end2)&#123;            return root;        &#125;        // 分割inorder 左子树start1到rootPosition-1 右子树rootPosition+1到end1        int rootPosition=-1;        for(int i=start1;i&lt;=end1;i++)&#123;            if(inorder[i] == rootVal)&#123;                rootPosition = i;                break;            &#125;        &#125;        //分割postOrder start2到start2+rootPosition-1-start1为左子树   start2+rootPosition-start1到end2-1为右子树          //左节点递归        if(rootPosition-1&gt;= start1)&#123;            root.left = traversal(inorder, start1, rootPosition-1, postorder, start2, start2+rootPosition-1-start1);        &#125;        //右节点递归        if(rootPosition+1&lt;=end1)&#123;            root.right = traversal(inorder, rootPosition+1, end1, postorder, start2+rootPosition-start1, end2-1);        &#125;        return root;    &#125;</code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        //preorder 中左右 3,9,20,15,7        //inorder  左中右 9,3,15,20,7        return traversal(preorder,0,preorder.length-1, inorder, 0, inorder.length-1);    &#125;    private TreeNode traversal(int[] preorder, int start1, int end1, int[] inorder, int start2, int end2)&#123;        // 找根节点        int rootval = preorder[start1];        TreeNode root= new TreeNode(rootval);        if(start1 == end1)&#123;            return root;        &#125;        // 找根节点位置        int rootPosition = -1;        for(int i=start2;i&lt;=end2;i++)&#123;            if(inorder[i] == rootval)&#123;                rootPosition = i;                break;            &#125;        &#125;        //分割inorder start2-&gt;rootPosition-1  rootPosition+1-&gt;end2        //分割preorder  start1+1-&gt; start1+rootPosition-start2  start1+rootPosition-start2+1-&gt;end1        if(start2&lt;=rootPosition-1)&#123;            root.left = traversal(preorder, start1+1, start1+rootPosition-start2, inorder, start2,rootPosition-1);        &#125;        if(rootPosition+1&lt;=end2)&#123;            root.right = traversal(preorder, start1+rootPosition-start2+1, end1, inorder,rootPosition+1, end2);        &#125;        return root;    &#125;</code></pre><p><strong>4.<a class="link"   href="https://leetcode.cn/problems/maximum-binary-tree/" >最大二叉树<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;        return traversal(nums, 0, nums.length-1);    &#125;    private TreeNode traversal(int[] nums, int start, int end)&#123;        int position = -1;        int maxValue = -1;        for(int i=start;i&lt;=end;i++)&#123;            if(nums[i]&gt;=maxValue)&#123;                position = i;                maxValue = nums[i];            &#125;        &#125;        TreeNode root = new TreeNode(maxValue);        if(start==end)&#123;            return root;        &#125;        if(start&lt;=position-1)&#123;            root.left = traversal(nums, start, position-1);        &#125;        if(end&gt;=position+1)&#123;            root.right = traversal(nums, position+1, end);        &#125;        return root;    &#125;</code></pre><p><strong>5.<a class="link"   href="https://leetcode.cn/problems/merge-two-binary-trees/" >合并二叉树<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;                if(root1 == null &amp;&amp; root2==null)&#123;            return null;        &#125;        if(root1 == null &amp;&amp; root2 != null)&#123;            return root2;        &#125;        if(root1 != null &amp;&amp; root2 == null)&#123;            return root1;        &#125;        TreeNode root = new TreeNode(root1.val + root2.val);        root.left = mergeTrees(root1.left, root2.left);        root.right = mergeTrees(root1.right, root2.right);        return root;    &#125;</code></pre><h4 id="二叉搜索树的属性"><a href="#二叉搜索树的属性" class="headerlink" title="二叉搜索树的属性"></a>二叉搜索树的属性</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" >二叉搜索树中的搜索<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode searchBST(TreeNode root, int val) &#123;        if(root == null)&#123;            return null;        &#125;        if(root.val == val)&#123;            return root;        &#125;        if(root.val &gt; val)&#123;            return searchBST(root.left, val);        &#125;        return searchBST(root.right, val);    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/validate-binary-search-tree/" >验证二叉搜索树<i class="fas fa-external-link-alt"></i></a></strong></p><p>二叉搜索树的中序遍历是递增序列</p><pre><code>    private Long max = Long.MIN_VALUE;    public boolean isValidBST(TreeNode root) &#123;        if(root == null)&#123;            return true;        &#125;        boolean left = isValidBST(root.left);        if(max&lt;root.val)&#123;            max = Long.valueOf(root.val);        &#125; else &#123;            return false;        &#125;        boolean right = isValidBST(root.right);        return left &amp;&amp; right;    &#125;&#125;</code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" >二叉搜索树的最小绝对差<i class="fas fa-external-link-alt"></i></a></strong></p><p>转化为中序遍历的数组，求有序数组的元素差的最小值</p><pre><code>    private List&lt;Integer&gt; array = new ArrayList&lt;&gt;();    public int getMinimumDifference(TreeNode root) &#123;        traversal(root);        int result = Integer.MAX_VALUE;        for(int i=1;i&lt;array.size();i++)&#123;            if(array.get(i)-array.get(i-1) &lt; result)&#123;                result = array.get(i)-array.get(i-1);            &#125;        &#125;        return result;    &#125;    private void traversal(TreeNode root)&#123;        if(root == null)&#123;            return;        &#125;        traversal(root.left);        array.add(root.val);        traversal(root.right);    &#125;</code></pre><p><strong>4.<a class="link"   href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" >二叉搜索树中的众数<i class="fas fa-external-link-alt"></i></a></strong></p><p>中序遍历， resultlist 放入当前出现次数最多的元素，每出现一个频率相同的元素，就放入resultlist，若出现一个频率更高的元素，清空resultlist并放入新元素，并更新最大频率</p><pre><code>    private ArrayList&lt;Integer&gt; resList = new ArrayList&lt;&gt;();    int count;    int maxCount;    TreeNode pre;    public int[] findMode(TreeNode root) &#123;        trasersal(root);        int[] result = new int[resList.size()];        for(int i=0;i&lt;resList.size();i++)&#123;            result[i] = resList.get(i);        &#125;        return result;    &#125;    private void trasersal(TreeNode root)&#123;        if(root==null)&#123;            return;        &#125;        trasersal(root.left);        if(pre == null || root.val != pre.val)&#123;            count = 1;        &#125; else &#123;            count++;        &#125;        if(count&gt;maxCount)&#123;            resList.clear();            resList.add(root.val);            maxCount = count;        &#125; else if(count == maxCount)&#123;            resList.add(root.val);        &#125;        pre = root;        trasersal(root.right);    &#125;</code></pre><p><strong>5.<a class="link"   href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" >把二叉搜索树转换为累加树<i class="fas fa-external-link-alt"></i></a></strong></p><p>等同于中序遍历从后往前累加，右中左的方式遍历，sum记录当前累加值</p><pre><code>    private int sum = 0;    public TreeNode convertBST(TreeNode root) &#123;                traversal(root);        return root;    &#125;     private void traversal(TreeNode root)&#123;        if(root == null)&#123;            return;        &#125;        traversal(root.right);        sum = sum + root.val;        root.val = sum;                traversal(root.left);    &#125;</code></pre><h4 id="二叉树的公共祖先问题"><a href="#二叉树的公共祖先问题" class="headerlink" title="二叉树的公共祖先问题"></a>二叉树的公共祖先问题</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" > 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;                if(root == null || root == p || root == q)&#123;            return root;        &#125;        TreeNode left = lowestCommonAncestor(root.left, p , q);        TreeNode right = lowestCommonAncestor(root.right,p,q);        if(left != null &amp;&amp; right != null)&#123;            return root;        &#125;        if(left == null &amp;&amp; right != null)&#123;            return right;        &#125;        return left;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" >二叉搜索树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;                if(root == null || root == p || root == q)&#123;            return root;        &#125;        if((root.val &gt; p.val &amp;&amp; root.val &lt; q.val) || (root.val &lt; p.val &amp;&amp; root.val &gt; q.val) )&#123;            return root;        &#125;        if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;            return lowestCommonAncestor(root.right, p, q);        &#125;                return lowestCommonAncestor(root.left, p, q);    &#125;</code></pre><h4 id="二叉搜索树的构造与修改"><a href="#二叉搜索树的构造与修改" class="headerlink" title="二叉搜索树的构造与修改"></a>二叉搜索树的构造与修改</h4><p><strong>1.<a class="link"   href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" >二叉搜索树中的插入操作<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        if(root == null)&#123;            return new TreeNode(val);        &#125;        if(root.val &lt; val)&#123;            root.right = insertIntoBST(root.right, val);        &#125;        if(root.val&gt;val)&#123;            root.left = insertIntoBST(root.left, val);        &#125;        return root;    &#125;</code></pre><p><strong>2.<a class="link"   href="https://leetcode.cn/problems/delete-node-in-a-bst/" >删除二叉搜索树中的节点<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>public TreeNode deleteNode(TreeNode root, int key) &#123;                if(root == null)&#123;            return null;        &#125;        if(root.val == key)&#123;            if(root.left == null &amp;&amp; root.right == null)&#123;                return null;            &#125;            if(root.left != null &amp;&amp; root.right == null)&#123;                return root.left;            &#125;            if(root.left == null &amp;&amp; root.right != null)&#123;                return root.right;            &#125;            if(root.left != null &amp;&amp; root.right != null)&#123;                TreeNode rightMinNode = root.right;                while(rightMinNode.left != null)&#123;                    rightMinNode = rightMinNode.left;                &#125;                rightMinNode.left = root.left;                return root.right;             &#125;        &#125;        if(root.val &lt; key)&#123;            root.right = deleteNode(root.right, key);        &#125;        if(root.val &gt; key)&#123;            root.left = deleteNode(root.left, key);        &#125;        return root;    &#125;</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/trim-a-binary-search-tree/" >修剪二叉搜索树<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>public TreeNode trimBST(TreeNode root, int low, int high) &#123;        if(root == null)&#123;            return null;        &#125;        if(root.val &gt;= low &amp;&amp; root.val &lt;= high )&#123;            root.left = trimBST(root.left, low, high);            root.right =trimBST(root.right, low, high);            return root;        &#125;        if(root.val &gt; high)&#123;            return trimBST(root.left, low, high);        &#125;        if(root.val &lt; low)&#123;            return trimBST(root.right, low, high);        &#125;        return root;    &#125;</code></pre><p><strong>3.<a class="link"   href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" >将有序数组转换为二叉搜索树<i class="fas fa-external-link-alt"></i></a></strong></p><pre><code>    public TreeNode sortedArrayToBST(int[] nums) &#123;                return build(nums, 0, nums.length - 1);    &#125;    private TreeNode build(int[] nums,int start,int end)&#123;        if(start == end)&#123;            return new TreeNode(nums[start]);        &#125;        int middle = (start + end) / 2;        TreeNode root = new TreeNode(nums[middle]);        if(middle&gt;start)&#123;            root.left = build(nums, start, middle-1);        &#125;        if(middle&lt;end)&#123;            root.right = build(nums, middle+1, end);        &#125;        return root;    &#125;</code></pre><h3 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a>2.并查集</h3><p>初始化</p><pre><code>// 每个人的parent是自己parent[i] = i;</code></pre><p>找根节点</p><pre><code>if(parent[i] == i)&#123;    return i;&#125; else &#123;    return find(parent[i]);&#125;</code></pre><p>合并</p><pre><code>parent[find(i)] = find(j)</code></pre><p>带路径压缩的查找</p><pre><code>if(find[i] == i)&#123;    return i;&#125; else &#123;    parent[i] = find(parent[i]);    return parent[i];&#125;</code></pre><p>带秩的初始化</p><pre><code>parent[i] = i;rank[i] = 1;</code></pre><p>带秩的合并</p><pre><code>//小的往大的上面合并if(rank[i] &gt; rank[j])&#123;    parent[j] = i;&#125;else &#123;    parent[i] = j;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一性原理</title>
      <link href="/2022/07/25/di-yi-xing-yuan-li/"/>
      <url>/2022/07/25/di-yi-xing-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>作者：李善友</p><p>出版年：2021-1</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/diyixingyuanli.jpg" style="zoom: 67%;" /><h1 id="第一性原理"><a href="#第一性原理" class="headerlink" title="第一性原理"></a>第一性原理</h1><h2 id="第一性原理-1"><a href="#第一性原理-1" class="headerlink" title="第一性原理"></a>第一性原理</h2><h3 id="归纳法"><a href="#归纳法" class="headerlink" title="归纳法"></a>归纳法</h3><ul><li><p>是什么：通过实践推导结论，把连续性的经验推广到一切时空。</p></li><li><p>归纳法发现的结论成立的前提：归纳结果的独立可重复性</p></li><li><p>隐含假设：连续性假设</p><ul><li>时间连续性</li><li>空间连续性</li></ul></li><li><p>只能证伪，不能证明</p></li><li><p>求存不求真：用较小的认知成本获取我们生存所需要的信息量。归纳法不能得到真理，但可以帮助人类生存下来（人类的最小作用力原理）</p></li></ul><h3 id="演绎法"><a href="#演绎法" class="headerlink" title="演绎法"></a>演绎法</h3><ul><li><p>演绎三段论</p><ul><li>大前提</li><li>小前提</li><li>结论</li></ul></li><li><p>隐含假设：前提的准确性，即前提不能来自归纳法</p></li><li><p>演绎法的基石，即一个能够自正确的原起点，第一性原理</p></li></ul><h3 id="第一性原理-2"><a href="#第一性原理-2" class="headerlink" title="第一性原理"></a>第一性原理</h3><ul><li><p>理性系统</p><ul><li>第一性原理+演绎法-&gt;理性系统</li></ul></li><li><p>第一性原理不是系统的中心思想，而是来源于系统之外，之前的原前提</p></li><li><p>第一性原理的层级之分：大系统的中心思想可以作为小系统的第一性原理</p></li></ul><h2 id="公理化思维"><a href="#公理化思维" class="headerlink" title="公理化思维"></a>公理化思维</h2><h3 id="欧式几何"><a href="#欧式几何" class="headerlink" title="欧式几何"></a>欧式几何</h3><ul><li>公设+公理+演绎法=》平面几何系统</li></ul><h3 id="公理化思维的应用"><a href="#公理化思维的应用" class="headerlink" title="公理化思维的应用"></a>公理化思维的应用</h3><ul><li>形而上学的第一性原理：我思故我在</li><li>牛顿力学：惯性假设、引力假设</li><li>自然选择进化论：遗传变异、生存竞争</li><li>狭义相对论：相对性原则、光速不变</li><li>广义相对论：等效原理、广义协变</li></ul><h2 id="破界创新"><a href="#破界创新" class="headerlink" title="破界创新"></a>破界创新</h2><h3 id="什么是破界创新"><a href="#什么是破界创新" class="headerlink" title="什么是破界创新"></a>什么是破界创新</h3><ul><li>不破不立，破的是系统得以形成的第一性原理，立的是新的第一性原理</li><li>理性思维是帮助我们看到世界真相的一种助力，但也是把我们禁锢在某一个边界里的一种束缚</li></ul><h3 id="破界创新三部曲"><a href="#破界创新三部曲" class="headerlink" title="破界创新三部曲"></a>破界创新三部曲</h3><ul><li><p>破隐含假设</p><ul><li>跳出系统看系统的边界</li></ul></li><li><p>立基石假设</p><ul><li>比原有的第一性原理层次更深，强度更大，这决定了新系统的边界和强度</li></ul></li><li><p>见全新系统</p><ul><li>在新的基石假设上，通过公理化方法演绎出新系统的第一性原理</li></ul></li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul><li><p>关键和难点就在于发现和打破隐含假设</p><ul><li>最常见的群体假设就是群体信念，包含你与周围人的共识，也有行业的常规</li></ul></li></ul><h2 id="组织刷新"><a href="#组织刷新" class="headerlink" title="组织刷新"></a>组织刷新</h2><h3 id="破解创新的难点在于发现并打破隐含假设"><a href="#破解创新的难点在于发现并打破隐含假设" class="headerlink" title="破解创新的难点在于发现并打破隐含假设"></a>破解创新的难点在于发现并打破隐含假设</h3><ul><li>隐含假设对应到组织时，往往表现为使命，文化，所以发现并打破隐含假设的过程，往往是重建使命、文化和战略的过程</li></ul><h2 id="第一创新"><a href="#第一创新" class="headerlink" title="第一创新"></a>第一创新</h2><h3 id="第一创新的关键词是立，从一个抽象的第一性原理出发，用逻辑思维将其拆解，进而推导出这个系统的基本原理，打破原有认知，寻找并建立新系统的过程"><a href="#第一创新的关键词是立，从一个抽象的第一性原理出发，用逻辑思维将其拆解，进而推导出这个系统的基本原理，打破原有认知，寻找并建立新系统的过程" class="headerlink" title="第一创新的关键词是立，从一个抽象的第一性原理出发，用逻辑思维将其拆解，进而推导出这个系统的基本原理，打破原有认知，寻找并建立新系统的过程"></a>第一创新的关键词是立，从一个抽象的第一性原理出发，用逻辑思维将其拆解，进而推导出这个系统的基本原理，打破原有认知，寻找并建立新系统的过程</h3><h2 id="万物至理"><a href="#万物至理" class="headerlink" title="万物至理"></a>万物至理</h2><h3 id="宇宙的第一性原理：大一统理论（万物至理）"><a href="#宇宙的第一性原理：大一统理论（万物至理）" class="headerlink" title="宇宙的第一性原理：大一统理论（万物至理）"></a>宇宙的第一性原理：大一统理论（万物至理）</h3><h2 id="从众效应"><a href="#从众效应" class="headerlink" title="从众效应"></a>从众效应</h2><h3 id="在组织中，我们很容易被群众的信念影响，甚至会因此怀疑并改变自己的观点，与他人保持一致寻求安心，这就是从众效应。破界创新的难点就是隐含假设，而最重要的隐含假设就是从众效应。对我们来说，只有认识到了这个桎梏，才有机会从中跳出"><a href="#在组织中，我们很容易被群众的信念影响，甚至会因此怀疑并改变自己的观点，与他人保持一致寻求安心，这就是从众效应。破界创新的难点就是隐含假设，而最重要的隐含假设就是从众效应。对我们来说，只有认识到了这个桎梏，才有机会从中跳出" class="headerlink" title="在组织中，我们很容易被群众的信念影响，甚至会因此怀疑并改变自己的观点，与他人保持一致寻求安心，这就是从众效应。破界创新的难点就是隐含假设，而最重要的隐含假设就是从众效应。对我们来说，只有认识到了这个桎梏，才有机会从中跳出"></a>在组织中，我们很容易被群众的信念影响，甚至会因此怀疑并改变自己的观点，与他人保持一致寻求安心，这就是从众效应。破界创新的难点就是隐含假设，而最重要的隐含假设就是从众效应。对我们来说，只有认识到了这个桎梏，才有机会从中跳出</h3><h3 id="真相符合论"><a href="#真相符合论" class="headerlink" title="真相符合论"></a>真相符合论</h3><ul><li>通常认为自己相信的真理都是符合事实的，但事实并非如此。任何一个客观事实都是与人脑中的某些主观意识融合在一起的产物</li></ul><h3 id="真理连贯论"><a href="#真理连贯论" class="headerlink" title="真理连贯论"></a>真理连贯论</h3><ul><li>如果某个信念和群体信念一致，那么这个信念就被认为是真理</li></ul><h3 id="群体心理学"><a href="#群体心理学" class="headerlink" title="群体心理学"></a>群体心理学</h3><ul><li>群体无智慧</li><li>群体无逻辑</li><li>群体无意识</li></ul><h2 id="批判性思维"><a href="#批判性思维" class="headerlink" title="批判性思维"></a>批判性思维</h2><h3 id="批判性思维是创新精神的第一特征，也是打破认知边界的必要条件，只有学会独立思考，普遍怀疑，愿意承认自己的无知，敢于质疑群体共识的观点，才可以打破原有的认知樊篱，突破创新"><a href="#批判性思维是创新精神的第一特征，也是打破认知边界的必要条件，只有学会独立思考，普遍怀疑，愿意承认自己的无知，敢于质疑群体共识的观点，才可以打破原有的认知樊篱，突破创新" class="headerlink" title="批判性思维是创新精神的第一特征，也是打破认知边界的必要条件，只有学会独立思考，普遍怀疑，愿意承认自己的无知，敢于质疑群体共识的观点，才可以打破原有的认知樊篱，突破创新"></a>批判性思维是创新精神的第一特征，也是打破认知边界的必要条件，只有学会独立思考，普遍怀疑，愿意承认自己的无知，敢于质疑群体共识的观点，才可以打破原有的认知樊篱，突破创新</h3><h3 id="逻辑三恰"><a href="#逻辑三恰" class="headerlink" title="逻辑三恰"></a>逻辑三恰</h3><ul><li><p>逻辑自洽</p><ul><li>自圆其说</li><li>逻辑与相关事实之间可以相互印证</li></ul></li><li><p>逻辑他恰</p><ul><li>逻辑系统与周边相关的逻辑系统以及更深层次的逻辑系统保持一致</li></ul></li><li><p>逻辑续恰</p><ul><li>被证明暂时正确，在时代和场景发生变化后，依然可以保持逻辑正确</li></ul></li></ul><h3 id="主体性认同"><a href="#主体性认同" class="headerlink" title="主体性认同"></a>主体性认同</h3><h3 id="群体信念"><a href="#群体信念" class="headerlink" title="群体信念"></a>群体信念</h3><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>认知觉醒</title>
      <link href="/2022/07/19/ren-zhi-jue-xing/"/>
      <url>/2022/07/19/ren-zhi-jue-xing/</url>
      
        <content type="html"><![CDATA[<p>作者：周岭</p><p>出版年：2020-10</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/renzhijuexing.jpg" style="zoom:50%;" /><h1 id="认知觉醒"><a href="#认知觉醒" class="headerlink" title="认知觉醒"></a>认知觉醒</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h3 id="醒着的睡着的人"><a href="#醒着的睡着的人" class="headerlink" title="醒着的睡着的人"></a>醒着的睡着的人</h3><ul><li>不了解世界的运行规则</li><li>不知道事物的构成</li><li>不知道努力的路径、方法</li><li>不知道自己想要什么、能做什么，最后会成为什么</li></ul><h3 id="真正的觉醒"><a href="#真正的觉醒" class="headerlink" title="真正的觉醒"></a>真正的觉醒</h3><ul><li>每天有事情做不代表觉醒，每天都努力不代表觉醒，真正的觉醒是一种发自内心的渴望，立足长远，保持耐心，运用认知的力量与时间做朋友；我发现人与人之间的根本差异是认知能力上差异，因为认知影响选择，而选择改变命运。所以成长的本质是让大脑的认知变得更加清晰</li></ul><h2 id="内观自己，拜托焦虑"><a href="#内观自己，拜托焦虑" class="headerlink" title="内观自己，拜托焦虑"></a>内观自己，拜托焦虑</h2><h3 id="认识大脑"><a href="#认识大脑" class="headerlink" title="认识大脑"></a>认识大脑</h3><ul><li><p>大脑</p><ul><li><p>三重大脑</p><ul><li>本能脑：主管本能。源于爬行动物时代</li><li>情绪脑：主管情绪。源于哺乳动物时代</li><li>理智脑：主观认知。源于灵长动物时代</li></ul></li><li><p>对大脑的控制能力：本能脑&gt;情绪脑&gt;理智脑</p><ul><li>进化的年代</li><li>发育成熟的时间</li><li>拥有神经元的数量</li><li>运行速度</li></ul></li><li><p>生活的大部分决策源于本能和情绪，而非理智-&gt;目光短浅，即时满足（避难趋易，急于求成）</p></li><li><p>成长：克服天性的过程</p><ul><li>让理智脑变强：经常思考，习惯反思</li><li>运用理智脑，驱动情绪和本能</li></ul></li></ul></li><li><p>焦虑</p><ul><li><p>安全感</p><ul><li>源于自己在某一方面拥有的独特优势：或能力、或财富、或权力、或影响力</li></ul></li><li><p>焦虑的类型</p><ul><li>完成焦虑：事情做不完导致焦虑</li><li>定位焦虑：错误定位自己</li><li>选择焦虑：选择太多</li><li>环境焦虑：外在环境限制了自己</li><li>难度焦虑：完成事情的难度太高导致焦虑</li></ul></li><li><p>焦虑的根源</p><ul><li>急于求成，想同时做很多事</li><li>避难趋易：想不怎么努力就立即看到效果</li></ul></li></ul></li><li><p>耐心</p><ul><li><p>向内：正确认识耐心</p><ul><li>缺乏耐心是人类的天性</li><li>耐心对人的发展至关重要</li></ul></li><li><p>向外：认知规律，增强耐心</p><ul><li>复利曲线：前期增长非常缓慢，但到了一个拐点后会飞速增长</li><li>舒适区边缘：无论个体还是群体，其能力都在舒适区-拉伸区-困难区的形式分布，要想让自己高效成长，必须让自己始终处在舒适区的边缘</li><li>成长权重对比：改变量&gt;行动量&gt;思考量&gt;学习量</li><li>学习的平台期：学习进展和时间的关系不是线性关系，而是呈现一种波浪式上升曲线</li></ul></li><li><p>怎么拥有耐心</p><ul><li>缺乏耐心是天性，首要接受自己缺乏耐心这一事实</li><li>面对诱惑，学会延迟满足，变对抗为沟通</li><li>面对困难，改变视角，赋予行动意义</li><li>让本能脑和情绪脑感受到困难事物的乐趣并上瘾</li></ul></li></ul></li></ul><h3 id="潜意识"><a href="#潜意识" class="headerlink" title="潜意识"></a>潜意识</h3><ul><li><p>模糊</p><ul><li><p>模糊的产生</p><ul><li><p>意识分层</p><ul><li>好处：潜意识负责生理系统，意识负责社会系统。意识得以全力投入更高级的社会活动</li><li>坏处：信息处理速度不对等，潜意识能够轻松影响意识，在潜意识的影响下，总是在做着自己不理解的事情，也就是模糊</li></ul></li></ul></li><li><p>消除模糊</p><ul><li><p>（内部）消除认知模糊</p><ul><li>学习知识：学习知识的目的是消除模糊，而获取知识的目的也是消除模糊，目的与方法相统一</li></ul></li><li><p>（外部）消除情绪模糊</p><ul><li>面对痛苦，正视它，拆解它，化解它，不给他进入潜意识，变模糊的机会。即时已经进入潜意识，也想办法将其挖出来。让情绪透明化，知道情绪产生的原因是什么</li></ul></li><li><p>（内部+外部）消除行动模糊</p><ul><li>行动模糊的真正原因是选择模糊，选择模糊就是一种不确定性，人类面对不确定性时会不自觉逃避</li><li>要消除行动模糊，必须让自己拥有足够清晰的目标</li></ul></li></ul></li></ul></li><li><p>感性</p><ul><li><p>潜意识的优势</p><ul><li>处理信息速度极快，能够极其敏锐感知到很多不易察觉的部分</li></ul></li><li><p>借助感觉去学习</p><ul><li><p>运用感性去做选择</p><ul><li>天性：选择舒适区</li><li>感谢：选择拉伸区</li><li>理性：选择困难区</li></ul></li></ul></li><li><p>凭感觉寻找人生目标</p><ul><li>理性：权衡利弊，不愿承认或刻意忽视自己原有的梦想</li><li>感性：守护和珍藏理想</li></ul></li><li><p>如何捕捉感性</p><ul><li>最字法：关注那些最触动自己的点</li><li>总字法：总是会出现的念头</li><li>无意识的第一反应：第一次做某个事情，心中的瞬间反应</li><li>梦境：潜意识传递信息的一种方法</li><li>身体：身体的反馈</li><li>直觉：关注来历不明，无法解释的信息</li></ul></li></ul></li></ul><h3 id="元认知"><a href="#元认知" class="headerlink" title="元认知"></a>元认知</h3><ul><li><p>元认知-自我察觉</p><ul><li><p>什么是元认知</p><ul><li>普通认知：认知事物，思考事物</li><li>元认知：是最高级别的认知，能对自身的思考过程进行认知和理解（反思能力）</li></ul></li><li><p>元认知的分类</p><ul><li><p>被动元认知</p><ul><li>不得已的情况下被迫启用（面临批评、指责、威胁）</li></ul></li><li><p>主动元认知</p><ul><li>主动开启第三视角，开始持续反观自己的思维和行为</li></ul></li></ul></li><li><p>元认知如何影响我们</p><ul><li>人类认知能力的反馈回路</li><li>元认知榜之我们意识到自己在想什么，进而意识到这些想法是否明智，再进一步纠正那些不明智的想法，最终做出更好的选择</li></ul></li><li><p>获取元认知能力</p><ul><li><p>监控自己的注意力，然后将其集中到自己需要关注的地方</p><ul><li>学习前人的智慧</li><li>反思自身的经历</li><li>时刻自我反思，自我监控，自我警醒</li><li>冥想</li></ul></li></ul></li></ul></li><li><p>元认知-自我控制</p><ul><li><p>从实用角度看元认知</p><ul><li>自我审视+主动控制+防止被潜意识左右</li></ul></li><li><p>理智脑的成长</p><ul><li>侧重学习、理解、记忆、运算的认知能力</li><li>侧重观察、反思、判断、选择的元认知能力</li></ul></li><li><p>元时间</p><ul><li><p>用来做选择的时间</p><ul><li>在选择节点审视自己的第一反应，并产生明确的主张</li><li>针对全天的日程，保持清醒，时刻明确下一步要做的事情</li><li>针对长远的目标，保持思考，想清楚长远意义和内在动机</li></ul></li></ul></li></ul></li></ul><h2 id="外观世界，借力前行"><a href="#外观世界，借力前行" class="headerlink" title="外观世界，借力前行"></a>外观世界，借力前行</h2><h3 id="专注力"><a href="#专注力" class="headerlink" title="专注力"></a>专注力</h3><ul><li><p>情绪专注</p><ul><li><p>身心分离模式</p><ul><li><p>原因</p><ul><li>觉得当下太无聊，所以追求更有意思的事情</li><li>觉得当下太痛苦，于是追求更舒适的事情</li></ul></li><li><p>危害</p><ul><li>生命的质量变差，走神可以让我活在任何时候，唯独不能让我们活在当下</li><li>造成拖延和低效，因为情绪滞后于行为，所以人们做事情时进入状态更慢，需要情绪过度</li></ul></li></ul></li><li><p>收回感受回归当下</p><ul><li>感受回归行动，不管在做什么时候，认真感受做这件事情的过程</li><li>身体感受是进入当下状态的最好媒介，感受事物消失的过程是一种很好的专注力训练</li></ul></li></ul></li><li><p>学习专注</p><ul><li><p>人类情绪和能力优劣的差异原因</p><ul><li>主动选择信息的能力（入口）</li><li>深度沉浸（关键）</li></ul></li><li><p>深度沉浸的方法</p><ul><li>定义明确的目标：具体、精细</li><li>练习时极度专注：100%投入一件事情</li><li>能获得有效反馈：哪里存在不足，以及为什么存在不足</li><li>始终在拉伸区练习：感到有些困难，但又可以通过努力来完成的事情</li></ul></li><li><p>走向卓越=正确的方法+正确的练习</p></li></ul></li></ul><h3 id="学习力"><a href="#学习力" class="headerlink" title="学习力"></a>学习力</h3><ul><li><p>舒适区边缘</p><ul><li><p>通过舒适区边缘的练习成长最快</p><ul><li>舒适区边缘的练习，不通扩大舒适区，拉伸区也不断扩大， 成长是必然的</li></ul></li><li><p>速成是不可能的</p><ul><li>能力圈只能慢慢变大</li></ul></li></ul></li><li><p>深度学习</p><ul><li><p>什么是深度学习</p><ul><li><p>学习金字塔</p><ul><li>被动学习：听讲、阅读、视听、演示</li><li>主动学习：讨论、实践、教授他人</li></ul></li><li><p>缝接知识</p><ul><li>动用已有的知识去解释新知识，当能够将新学的东西解释清楚时，就意味着把它纳入了自己的知识体系，同时达到了可以教授他人的水平，并可能创造新的知识</li></ul></li></ul></li><li><p>如何深度学习</p><ul><li>获取高质量的知识（知道信息）</li><li>深度缝接新的知识（关联信息）</li><li>输出成果去教授（行动和改变）</li></ul></li><li><p>深度学习的好处</p><ul><li>不再浮躁，磨练理智，跨界能力的提升</li><li>灵感</li><li>更容易看到不同事物间的关联，产生洞见</li></ul></li><li><p>浅学习</p><ul><li>基于深度学习下的广度才是有效的</li><li>专注于深度学习，同时对浅学习保持开放</li></ul></li></ul></li><li><p>关联</p><ul><li><p>获取关联能力</p><ul><li>手中有“锤子”：对某件事情有足够的热爱和投入，有极致的专注和思考</li><li>输入足够多：阅读、现实经历</li><li>保持好奇心</li><li>常说一句话：这个道理还能被用在什么地方</li></ul></li></ul></li><li><p>体系</p><ul><li><p>知识与认知</p><ul><li>真正的知识不是你知道了它，而是能运用他帮助自己做出正确的判断和选择，解决实际问题</li></ul></li><li><p>体系的本质</p><ul><li>用独特的视角，将一些零散的、独立的知识、概念或观点整合为这个世界的方法和技巧</li></ul></li><li><p>建立自己的认知体系</p><ul><li><p>打碎各家的认知体系，只取其中最触动自己的点或块，然后将其拼接成自己的认知网络</p></li><li><p>触动学习法</p><ul><li>运用感性的情绪触动去识别与自身需求最紧密的内容</li></ul></li><li><p>与触动产生连接</p><ul><li>能用自己的语言解释清楚</li><li>在需要的时候能够提取出来</li><li>在生活中经常练习或者使用</li></ul></li></ul></li></ul></li><li><p>不要迷恋打卡</p><ul><li><p>动机转移，动力扭曲</p><ul><li>坚持的动机，不知不觉地从学习本身转移到完成任务上，由内在需求转移到了外在形式上</li></ul></li><li><p>认知闭合，效能降低</p><ul><li>一件事情若迟迟没有完成，心里就总是记挂，期盼着能早点结束；此事一旦完成，做这件事情的动机就会趋向于0</li></ul></li><li><p>任务心态，身心分裂</p><ul><li>任务心态使得注意力分散，很难全身心投入事物本身，从而体会其中的要领和乐趣</li></ul></li><li><p>用记录代替打卡</p><ul><li>专注于学习成长本身，体会其中的乐趣，就能保持强烈的学习动机，化被动学习为主动学习</li><li>设下限，不设上限</li></ul></li></ul></li><li><p>反馈</p><ul><li><p>科学的学习策略</p><ul><li><p>产出作品，获取反馈</p><ul><li>驱动本能脑和情绪脑感到快乐，而不是一味坚持努力，让理智脑苦苦去学</li></ul></li></ul></li></ul></li><li><p>休息</p><ul><li><p>精力变化曲线</p><ul><li>持续刻苦，不舍得休息，精力总量呈现一条持续下降的曲线</li><li>精力不足，主动休息，精力水位迅速回升，精力曲线呈现波浪式</li><li>轻松者比刻苦者的高效学习区要大得多</li></ul></li><li><p>极度专注效果&gt;意志力支撑</p></li><li><p>极度专注，主动休息，循环往复</p><ul><li>番茄工作法</li></ul></li></ul></li></ul><h3 id="行动力"><a href="#行动力" class="headerlink" title="行动力"></a>行动力</h3><ul><li><p>清晰力</p><ul><li><p>注意力的增强回路</p><ul><li>每天醒来注意力会重启</li><li>如果起床后能避开轻松和娱乐的吸引，精力就会呈现聚合状态，并自动增强</li><li>增强回路的起点，做出有利选择的自制力是最小的，等到负向的增强回路形成，再想改变就难了</li></ul></li><li><p>知道并不代表做到</p><ul><li>对要做什么只有一个模糊的概念</li></ul></li><li><p>建立清晰力</p><ul><li>想清楚，并把要做什么写下来</li></ul></li><li><p>热爱才是第一</p><ul><li>有了热情，就会自带要事第一和提高清晰力属性，所以除了清晰力，还需要寻找目标的感知力，掌握自由的匹配力，指导万物的元认知能力</li></ul></li></ul></li><li><p>做一个傻瓜</p><ul><li><p>成长的悖论</p><ul><li>想先看到结果再行动的人往往无法看到结果。因为结果不明朗，担心付出没有回报，所以不愿行动，以致于永远停留在原地</li><li>当自己从没有主动做成过一件事情的时候，总会以为做成一件事情很容易，于是生出很多不切实际的想法和欲望，而欲望越多，就越做不成事</li></ul></li><li><p>打破悖论</p><ul><li><p>不计得失地先行动起来</p><ul><li>行动量需要突破阈值</li></ul></li></ul></li><li><p>做一个有理有据的傻瓜</p><ul><li>有原理，有依据的坚定</li><li>如果你觉得别人讲的道理有理有据，而暂时无法反驳，碰巧自己很想去做这件事情，那就相信他们说的是对的，然后笃定的行动</li><li>实践过程中，保持思考，用行动反复验证理论，不适则改，适则用</li></ul></li></ul></li><li><p>知行合一</p><ul><li><p>认知的建立</p><ul><li><p>大脑中的神经细胞在建立连接</p></li><li><p>技能学习</p><ul><li>大量的练习，让大脑中的神经元形成强关联</li></ul></li><li><p>认知学习</p><ul><li>知道道理后，实践形成正反馈</li><li>不发生真正改变的都是无效的练习</li></ul></li></ul></li></ul></li></ul><h3 id="情绪力"><a href="#情绪力" class="headerlink" title="情绪力"></a>情绪力</h3><ul><li><p>心智带宽</p><ul><li><p>是什么</p><ul><li>心智的容量，它支撑着人的认知力、行动力和自控力。心智带宽一旦降低，人很容易丧失判断力，做出不明智的选择，或急于求成，做事缺乏耐心，难以抵挡享乐的诱惑</li></ul></li><li><p>心智带宽的降低</p><ul><li>任何能制造压力的事件都会挤占我们的心智带宽</li><li>焦虑。急于求成，同时面临很多任务时，心智带宽被占据</li></ul></li><li><p>保持心智富足</p><ul><li>保持对环境的觉知，理智选择</li><li>保持目标觉知，少即是多</li><li>保持欲望觉知，审视决策</li><li>保持情绪觉知，谨慎决定</li><li>保持闲余觉知，自我设限</li></ul></li></ul></li><li><p>避免单一视角</p><ul><li><p>世界多维，而视角单一</p><ul><li>世界是多维的，我们观察到的只是其中一个角度，如果不能强烈的意识到这一点，就容易以偏概全对待世界，产生各种偏差</li><li>保持视角觉知，清醒意识到自己的视角偏误，时刻做好向上升级，向下兼容的准备</li><li>无论目前处于何种情绪漩涡，总会有更好的视角</li></ul></li><li><p>避免单一视角</p><ul><li>勤移动，尝试用不同的视角看问题</li><li>善学习，借助其他人的视角来观察世界</li><li>要开放，保持客观，不臆断，开放心态去接受客观真相</li><li>寻帮助，寻找其他人提供外部视角</li><li>多运动，运动会提升体内多巴胺的含量，提升创造力和多角度思考能力</li><li>常反思，反思自己，梳理自己的烦恼</li></ul></li></ul></li><li><p>游戏心态</p><ul><li><p>自我决定理论</p><ul><li>关系需求。有良好的人际关系，得到别人的爱与尊敬</li><li>能力需求。有独特的本领，技能，为别人带来独特价值</li><li>自主需求。有自主选择的权力，能做自己想做的事情</li></ul></li><li><p>动机转移：自主选择</p><ul><li>事情本身并不重要，我们只是在通过它获取另外一种快乐，顺便把这件事情做了</li><li>子主题 2</li></ul></li><li><p>产生内部动机</p><ul><li>立足于让自己变得更好</li></ul></li><li><p>这个世界的模样取决于我们看待它的角度</p></li></ul></li></ul><h3 id="早冥读写跑"><a href="#早冥读写跑" class="headerlink" title="早冥读写跑"></a>早冥读写跑</h3><ul><li><p>早起</p><ul><li><p>早起的理由</p><ul><li>每天的时间变长，生命的长度也随之变长</li><li>在睡眠节点时醒来，精神更加</li><li>闹钟叫醒，给精神带来痛苦</li><li>大脑工作的高峰期在早上</li></ul></li><li><p>早起干些什么</p><ul><li>规划一天的工作</li><li>跑步</li><li>反思</li><li>读书或写作</li><li>困难的工作</li></ul></li><li><p>注意事项</p><ul><li>初期会有一个相对痛苦的适应期</li><li>循序渐进，难度匹配</li><li>按状态起床，醒来时迷糊就继续睡一个周期（1.5h），感觉神清气爽就可以起床</li><li>中午需要午休一次</li><li>不打扰他人</li><li>提前准备</li><li>明确遇到哪些情况可以不早起</li></ul></li></ul></li><li><p>冥想</p><ul><li><p>冥想的原因</p><ul><li>普通人与聪明人的差异在于长时间保持极度专注的能力</li><li>冥想把注意力集中到呼吸上，坚持这种习惯，能帮助养成专注的习惯，将专注变成无意识的行为</li></ul></li></ul></li><li><p>阅读</p><ul><li><p>阅读的原因</p><ul><li><p>决定的层次</p><ul><li>情绪决定：倾向于半途而废</li><li>理智决定：想好了为什么要做，怎么去做，以及可能遇到的困难</li></ul></li><li><p>阅读相当于和某个行业里最顶尖的专家对话，是最低廉的成本获取最高级的成长策略</p></li><li><p>文字可以带我们前往脚步不能走到的地方，眼睛无法看到的地方，超越空间和时间的限制</p></li><li><p>读好书相当于和古今中外的顶级思想家对话，借助他们的视角提升自己的选择能力</p></li><li><p>阅读让人保持高密度的思考</p></li></ul></li><li><p>阅读的关键</p><ul><li>选书比读书更重要。什么是自己当前最迫切，最需要解决的问题？选择难度刚好在自己舒适区的书</li><li>阅读是为了改变。积累知识没有意义，读书是为了让自己发生改变</li><li>关注阅读时产生的关联，形成知识网络</li><li>读写不分家</li></ul></li></ul></li><li><p>写作</p><ul><li><p>费曼技巧</p><ul><li><p>通过自己的语言，用最简单的话把一件事情讲清楚，最好能让外行人也能听懂</p><ul><li>简单的语言</li><li>用自己的语言</li></ul></li></ul></li><li><p>感性与理性</p><ul><li>先用合适的故事引起对方感性小人的兴趣和注意，然后把想要表达的道理通过感性小人转达给理性小人</li></ul></li></ul></li><li><p>运动</p><ul><li><p>运动的原因</p><ul><li>运动能调节人身体的各种激素，使身体充满活力和能量</li><li>运动让大脑长出更多的神经元，这意味着让人在物理上更聪明</li></ul></li><li><p>运动+学习的模式</p><ul><li>运动后的学习使得运动时生长的神经元，长出神经轴突和树突</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/renzhijuexing.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>平凡的世界</title>
      <link href="/2022/07/11/ping-fan-de-shi-jie/"/>
      <url>/2022/07/11/ping-fan-de-shi-jie/</url>
      
        <content type="html"><![CDATA[<p>作者：路遥</p><p>出版年：2021-06</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/pingfandeshijie.jpg" style="zoom:50%;" /><p>一九七五年的二三月间，一个平平常常的日子，细濛濛的雨丝夹着一星半点的雪花，正纷纷淋淋地向大地飘撒着。时令已快要到惊蛰，雪当然不会存留，往往还没等落地，就已经消失得无影无踪了。黄土高原严寒而漫长的冬天看来就要过去，但那真正温暖的春天还远远没有到来</p><p>而最重要的是，他现在朦胧地意识到，不管什么样的人，或者不管再什么样的情况下，都可以活得多么好啊！</p><p>不管别人对她丈夫怎么看，这个忠厚善良的农家姑娘，始终在心里热爱着这个被世人嫌弃的人——因为在这个世界上，只有这个男人，曾在她那没有什么光彩的青春岁月里，第一次给过她爱情的欢乐啊</p><p>他慢慢懂得，人活着，就得随时准备经受苦难、他已经看过一些书，知道不论是普通人还是了不起的人，都要在自己的一生中经受许多的磨难</p><p>是的，生活就是这样。在我们都是小孩子的时候，一个人和一个人可能有家庭条件的区别，但孩子们本身的差别并不明显。可一旦长大， 每个人的生活道路会有多大的差别呀，有的甚至是天壤之别</p><p>人活着，这种亲人之间的感情是多么重要，即使人的一生充满了坎坷和艰辛，只要有这种感情存在，也会感到一种温暖的慰藉。假如没有这种感情，我们活在这世界上会有多么悲哀啊</p><p><em>普通并不等于庸俗。他也许一辈子就是个普通人，但他要做一个不平庸的人。在许许多多平平常常的事情中，应该表现出不平常的看法和做法来</em></p><p><em>在最平常的事情中都可以显示出一个人人格的伟大来！</em></p><p>一切都毫无办法。对于一个普通人来说，只好听命于生活的裁决。这不是宿命，而是无法超越客观条件。在这个世界上，不是所有合理的和美好的都能按照自己的愿望存在或者实现</p><p>所有这些都给孙少平精神上带来了从未有过的满足。他现在可以用比较广阔一些的目光来看待自己和周围的事物，因而对生活增加了一些自信和审视的能力，并且开始用各种角度从不同的侧面来观察某种情况和某种现象了。当然，从表面上看，他目前和以前并没有什么不同，但他实际在很大程度上已不再是原来的他了。他本质上仍然是农名的儿子，但他竭力想挣脱和超越他出身的阶层</p><p>人们宁愿去关系一个蹩脚演员的吃喝拉撒和鸡毛蒜皮，也不愿了解一个普通人波涛汹涌的内心世界</p><p>在以前，他总觉得自己是个娃娃，得依靠大人。现在，即使没有大人。他也感觉能在这个世界上生活下去。他得另一个成熟的标志，就是对大人的行为开始具备批判的眼光</p><p>知识就是力量——他父亲告诉他说，这句话是英国著名哲学家培根说的。是的，知识这种力量可以改变一个人，甚至可以重新塑造一个人</p><p>她开始动摇了。她的力量使她无法支撑如此巨大的精神压力。当然除过客观的压力以外，她主观上的素养本来也不够深厚。是的，她现在无法从更高意义上来理解自身和社会。尽管她是一个正直善良的人，懂事，甚至也有较鲜明的个性，但并不具有深刻的思想和广阔的眼界。因此，最终她还是不能掌握自己的命运</p><p>牺牲自己而全力支撑这个穷家，这是他多年来的一贯信念，已经成了他的生活哲学。也正因为如此，他才没有从无数艰难困苦中垮下来，甚至因而感到自己活得还有点意思</p><p>如果他当初不知道这世界如此之大，反正双水村和石圪节就是他的世界。但现在他通过书本，已经走了那么多地方，他的思想怎么会再仅仅局限在原来那个小天地呢？</p><p>在人的一生中，最美好的时光也许正是在自己的中学时代。那时我们多么年轻、纯洁、真挚、内心充满了生活的诗意</p><p>活在这世上，有人爱你，这总不是一件坏事</p><p>在一个人思想还没有强大到自己能完全把握自己的时候，就需要在精神上依托另一个比自己更强的人。也许有一天，学生会变成自己老师的老师——这是常常会有的——但人在壮大过程的中的每一个阶段，都需要求得当时比自己的认识更高明的指教</p><p>年轻人走点弯路不是什么了不起的事情。能反省自己，这是一个人成熟的表现</p><p>谁让你读了那么些书，又知道了双水村以外还有一个大世界…如果你从小就在这个天地里日出而作，日落而息，那你现在就会和众乡亲抱同一理想：经过几年的辛劳，像大哥一样娶一个满意的媳妇，生个胖儿子，加上你的体魄，会成为一名相当出色的庄稼人。不幸的是，你知道得太多了，思考得太多了，因此才有了这种不能为周围人所理解的苦恼</p><p>不论在什么年代，只有年轻的血液才会如此沸腾和激荡。每一个人都不同程度有过自己的少年意气，有过青春的梦想和冲动</p><p>你知道：幸福不仅仅是吃饱穿暖，而是勇敢地去战胜困难</p><p>孙少平在这期间更强烈的认识到：只要自己诚心待人，别人也才可能对自己以诚相待。加深如此重大的人生经验，对一个刚入世的青年来说，也许要比赚许多钱更为重要</p><p>是的，他在我们的时代属于这样的青年：有文化，但没有幸运地进入大学或参加工作，因此似乎没有充分的条件直接参与到目前社会发展的主潮之中。而另一方面，他们又不甘心把自己局限在狭小的生活天地里。因此，他们往往带着一种悲壮的激情，在一条最为艰难的道路上进行人生的搏斗。他们顾不得高谈阔论或愤世嫉俗地忧患人类的命运。他们首先得改变自己的生存条件，同时也不放弃最主要的精神追求；他们既不鄙视普通人的世俗生活，但又竭力使自己对生活的认识达到更深的层次</p><p>是的，她和他尽管社会地位和生活处境不同，但在人格上是平等的——这种关系只有在共同探讨的基础上才能形成。或许他们各自都有需要对方改造的地方；改造别人也就是对自己本身的改造</p><p>只有努力工作，才能叫人尊重</p><p>生活不能等待别人来安排，要自己去争取和奋斗；而不论其结果是喜是悲，你总不枉在这世界上活了一场人。有了这样的认识，你就珍重生活，而不会玩世不恭；同时也会给人自身注入一种强大的内在力量</p><p>痛苦啊，往往是人走向成熟的最好课程</p><p>她喜欢孙少平的正是他不伪装自己，并不因生活的窘迫就感到自己活得没有意义。她看的出来，少平甚至对苦难有一种骄傲——只有更深邃地理解了生活的人才会在精神上如此强大</p><p><em>有了希望，人就会产生激情，并可以义无反顾地为之而付出代价；在这样的过程中，才能真正体会到人生的意义。什么是人生，人生就是永不休止的奋斗！只有选定了目标并在奋斗中感到自己的努力没有虚掷，这样的生活才是充实的，精神也会永远年轻！</em></p><p>我们出生于贫困的农民家庭——永远不要鄙薄我们的出生，它将给我们带来的好处一生受用不尽；但我们一定又要从我们的出身的局限中解脱出来，从意识上彻底背叛农民的狭隘性，追求更高的生活意义</p><p>首先要自强自立，勇敢地面对我们不熟悉的世界，不要怕苦难！如果能深刻理解苦难，苦难就会给人带来崇高感。我亲爱的妹妹，我多么希望你的一生充满欢乐。可是，如果生活需要你忍受苦难，你一定要咬紧牙关坚持下去。有位了不起的人说过：痛苦难道是白忍受的吗？它应该使我们伟大！</p><p>这是人生的心酸，在我们短促而又漫长的一生中，我们在苦苦地追寻人生的幸福。可幸福往往又于我们失之交臂。当我们为此耗尽宝贵的清楚年华，皱纹也悄悄爬上了眼角的时候，我们或许才能稍稍懂得生活实际上意味着什么</p><p>哪怕他今生一世暗淡无光，可他在自己生命的历程中，仍然还有值得骄傲和怀恋的东西啊！</p><p><em>生活包含着更广阔的意义，而不在于我们实际得到了什么；关键在于我们的心灵是否充实。对于生活理想，应该像对待宗教一样充满虔诚与热情</em></p><p>我要扼住命运的咽喉，它绝不使我完全屈服</p><p>只要有人的地方，世界就不会是冰冷的。他不由得再一次思想：我们活在人世界，最为珍视的应该是什么？金钱？权力？荣誉？是的，有这些东西也并不坏。但是，没有什么东西比得上温暖的人情更为珍贵——你感受到的生活的真正美好，莫过于这一点了</p><p><em>没有爱情，人的生活就不堪设想。爱情啊！它使荒芜变为繁荣，平庸变为伟大；使死去的复活，活着的闪闪发光，即使爱情是不尽的煎熬，不尽的折磨，像冰霜般严厉，烈火般烤灼，但爱情对心理和身体健康的男女永远是那样的自然；同时又永远让我们感到惊奇、神秘和不可思议……</em></p><p>一个人的命运不是自己想改变就能改变了的。至于所谓的理想，我认为这不是职业好坏的代名词。一个人精神是否充实，或者说活得有无意义，主要取决与他对劳动的态度</p><p>在生活中，因为你而使周围的人充满希望和快乐，这会给你带来多大的满足！</p><p>不要以为一个人一时正确，就认为他永远正确。也不要因为一个人犯过错误，就断定他永远不可能再加入优秀者的队伍。道理是如此简单，事实又不断佐证，可是生活中用不变的眼光看待人的现象却是常常存在的</p><p>他永远是这样一种人：既不懈地追求生活，又不敢奢望生活过多的酬报和宠爱，理智而清醒地面对现实，这也许是所有从农村走出来的知识阶层所共有的一种心态</p><p>命运总是不如人愿。但往往是在无数的痛苦中，在重重的矛盾和艰难中，才使人成熟起来，坚强起来；虽然这些东西在实际感受中带给人的并都是快乐</p><p>爱情，应该是建立在现实生活坚实的基础上，否则，它就是在活生生的生活之树上盛开的一朵不结果实的花</p><p><em>真正的爱情不应该是利己的，而应该是利他的，是心甘情愿地与爱人一起奋斗并不断自我更新的过程；是融合在一起——完全融合在一起的共同斗争！你有没有决心为他（她）而付出自己的最大牺牲，这是衡量是不是真正爱情的标准，否则就是被自己的感情所欺骗</em></p><p>生活总是美好的，生命在其间又是如此的短暂；既然或者，就应该好好地活，思恋早逝的亲人，应该更珍惜自己生命的每个时刻。精神上的消沉无异于自杀。像往日一样，正常的投入生活吧！即便是痛苦，也应该看作是人的正常情感；甚至它是组成我们人生幸福的一个不可或缺的部分呢！</p><p>无论精神多么独立的人，感情却总是在寻找一种依附，寻找一种归宿</p><p>感情啊，常常会令人难以置信地决定一个人的行为！正如男女结合，决定的因素往往不仅仅是因为对方漂亮，而正是那种说不清道不明的刻骨铭心的感情</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>科学地看爱情</title>
      <link href="/2022/07/05/ke-xue-di-kan-ai-qing/"/>
      <url>/2022/07/05/ke-xue-di-kan-ai-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="科学地看爱情"><a href="#科学地看爱情" class="headerlink" title="科学地看爱情"></a>科学地看爱情</h1><h2 id="1-恋爱的诀窍"><a href="#1-恋爱的诀窍" class="headerlink" title="1.恋爱的诀窍"></a>1.恋爱的诀窍</h2><h3 id="严肃而靠谱的爱情"><a href="#严肃而靠谱的爱情" class="headerlink" title="严肃而靠谱的爱情"></a>严肃而靠谱的爱情</h3><ul><li><p>真情实感</p></li><li><p>承诺与责任心</p></li><li><p>高质量的交流互动</p><ul><li>核心命题</li></ul></li></ul><h3 id="对于关系的经营"><a href="#对于关系的经营" class="headerlink" title="对于关系的经营"></a>对于关系的经营</h3><ul><li>自我认知</li><li>如何定位靠谱的恋爱对象</li><li>如何通过和谐的交流从浅入深的培养感情</li><li>如何表白成功</li></ul><h3 id="对于的资本经营"><a href="#对于的资本经营" class="headerlink" title="对于的资本经营"></a>对于的资本经营</h3><ul><li><p>个体的外在资本</p><ul><li>学历、长相、收入等等</li></ul></li><li><p>个体的内在资本</p><ul><li>脾气秉性、审美情趣、三观等等</li></ul></li><li><p>伴侣的外在资本</p><ul><li>共同的经历</li></ul></li><li><p>伴侣的内在资本</p><ul><li>共同的三观、心有灵犀的交流基础、长期相处培养出的相似性和熟悉感</li></ul></li></ul><h2 id="2-爱情始于同一个圈子的交集"><a href="#2-爱情始于同一个圈子的交集" class="headerlink" title="2.爱情始于同一个圈子的交集"></a>2.爱情始于同一个圈子的交集</h2><h3 id="交流与熟悉的程度"><a href="#交流与熟悉的程度" class="headerlink" title="交流与熟悉的程度"></a>交流与熟悉的程度</h3><ul><li>熟人交互</li><li>准熟人交互</li><li>寻找契机：准熟人交互-&gt;熟人交互</li></ul><h3 id="在圈子中寻找潜在恋爱对象"><a href="#在圈子中寻找潜在恋爱对象" class="headerlink" title="在圈子中寻找潜在恋爱对象"></a>在圈子中寻找潜在恋爱对象</h3><ul><li><p>重点圈子</p><ul><li>同学、同事、家人或同事组织的活动、俱乐部等等</li></ul></li><li><p>引荐人</p></li><li><p>在正确的圈子里与其他人进行互动</p><ul><li><p>开放型场景</p><ul><li><p>不需要特定交互，不强调个体互动</p><ul><li>马路上、操场上</li></ul></li></ul></li><li><p>闭合型场景</p><ul><li><p>如果没有深入交互与互动，就很难达成场合存在的终极目的</p><ul><li>读书分享会、面试、打麻将</li></ul></li></ul></li></ul></li></ul><h3 id="总结：找到正确的闭合型场景，与圈子中的他人进行高质量的互动"><a href="#总结：找到正确的闭合型场景，与圈子中的他人进行高质量的互动" class="headerlink" title="总结：找到正确的闭合型场景，与圈子中的他人进行高质量的互动"></a>总结：找到正确的闭合型场景，与圈子中的他人进行高质量的互动</h3><h2 id="3-相貌偏好：恋爱开始的敲门砖"><a href="#3-相貌偏好：恋爱开始的敲门砖" class="headerlink" title="3.相貌偏好：恋爱开始的敲门砖"></a>3.相貌偏好：恋爱开始的敲门砖</h2><h3 id="外貌在交往初期，作用特别重要"><a href="#外貌在交往初期，作用特别重要" class="headerlink" title="外貌在交往初期，作用特别重要"></a>外貌在交往初期，作用特别重要</h3><ul><li>人会爱上一个人的内涵，但人的外貌是深入理解内涵的敲门砖</li></ul><h3 id="提升外在吸引力"><a href="#提升外在吸引力" class="headerlink" title="提升外在吸引力"></a>提升外在吸引力</h3><ul><li><p>男性</p><ul><li><p>成熟度</p><ul><li>能够胜任恋人身份的心智水平</li></ul></li><li><p>安全感</p><ul><li>不同异性有不同的倾向：成熟稳重、孔武有力、博学多才等等</li></ul></li></ul></li><li><p>女性</p><ul><li>投资感</li></ul></li></ul><h3 id="相貌水平差不多的人，彼此选择的概率更高"><a href="#相貌水平差不多的人，彼此选择的概率更高" class="headerlink" title="相貌水平差不多的人，彼此选择的概率更高"></a>相貌水平差不多的人，彼此选择的概率更高</h3><h2 id="4-信任：靠谱爱情的基础"><a href="#4-信任：靠谱爱情的基础" class="headerlink" title="4.信任：靠谱爱情的基础"></a>4.信任：靠谱爱情的基础</h2><h3 id="真实感：有血有肉的真诚"><a href="#真实感：有血有肉的真诚" class="headerlink" title="真实感：有血有肉的真诚"></a>真实感：有血有肉的真诚</h3><ul><li>不装，真诚待人</li></ul><h3 id="逻辑感：有理有据的靠谱"><a href="#逻辑感：有理有据的靠谱" class="headerlink" title="逻辑感：有理有据的靠谱"></a>逻辑感：有理有据的靠谱</h3><ul><li>保持情绪稳定，接纳与对方的不一样</li></ul><h3 id="同理心：做到让对方觉得你懂TA"><a href="#同理心：做到让对方觉得你懂TA" class="headerlink" title="同理心：做到让对方觉得你懂TA"></a>同理心：做到让对方觉得你懂TA</h3><ul><li>多听：交流中保持专注的倾听</li><li>多问：及时与恰当地征询对方的意见</li><li>多关注：保持对双方需求的敏感</li></ul><h2 id="5-关系发展的纵深理论"><a href="#5-关系发展的纵深理论" class="headerlink" title="5.关系发展的纵深理论"></a>5.关系发展的纵深理论</h2><h3 id="核心：不同的关系层级，有不同的交互倾向。对关系层级保持敏感，对行为标准保持相对应的克制"><a href="#核心：不同的关系层级，有不同的交互倾向。对关系层级保持敏感，对行为标准保持相对应的克制" class="headerlink" title="核心：不同的关系层级，有不同的交互倾向。对关系层级保持敏感，对行为标准保持相对应的克制"></a>核心：不同的关系层级，有不同的交互倾向。对关系层级保持敏感，对行为标准保持相对应的克制</h3><h3 id="关系发展的阶段"><a href="#关系发展的阶段" class="headerlink" title="关系发展的阶段"></a>关系发展的阶段</h3><ul><li><p>社会关联关系</p><ul><li>是一切个人之间关系的基础，在这种关系内，一方的具体行为会对另一方的具体行为产生影响</li></ul></li><li><p>个体关系</p><ul><li>在关联关系基础上，个体之间认为彼此具有一定的特殊性和不可替代性</li></ul></li><li><p>紧密关系</p><ul><li>在个体关系基础上，个体之间有着更为频繁的互动，而且彼此影响的程度更为激烈</li></ul></li><li><p>亲密关系</p><ul><li>在紧密关系的基础上，有着更加富于激情的性互动，并且双方在分享行为之外，也高度分享各种感受</li></ul></li></ul><h3 id="相亲"><a href="#相亲" class="headerlink" title="相亲"></a>相亲</h3><ul><li><p>相亲的弊病</p><ul><li>生硬地跳过了亲密关系常规发展的社会关联关系、个体关系，直接进入了紧密关系，这是一种感情发展的揠苗助长</li></ul></li><li><p>结合关系发展的纵深理论看相亲</p><ul><li><p>第一次见面，培养出个体关系</p><ul><li>别人对方把你当其他的相亲对象或者普通路人，在保持礼貌的基础上，尽量展示出自己的独特资源</li></ul></li><li><p>关系深化</p><ul><li>分享双方共有的积极体验</li></ul></li><li><p>确定要更进一步</p><ul><li>适当释放负面信号，将对方变成自己人</li></ul></li><li><p>进入紧密关系</p></li></ul></li></ul><h2 id="6-一见钟情的核心是交互场景"><a href="#6-一见钟情的核心是交互场景" class="headerlink" title="6.一见钟情的核心是交互场景"></a>6.一见钟情的核心是交互场景</h2><h3 id="一见钟情如何打造"><a href="#一见钟情如何打造" class="headerlink" title="一见钟情如何打造"></a>一见钟情如何打造</h3><ul><li>要素1：能激活情绪情感的邂逅场景</li><li>要素2：起码一方所能展现的具体资源</li><li>要素3：双方的交集</li><li>总结：选取一个能激活情感情绪的邂逅场景，用精心装扮来展现自我的资源以及想方设法与对方产生交集</li></ul><h3 id="一见钟情后的感情发展"><a href="#一见钟情后的感情发展" class="headerlink" title="一见钟情后的感情发展"></a>一见钟情后的感情发展</h3><ul><li><p>一见钟情的本质：场景误读</p><ul><li>脱离场景后更难维持</li></ul></li><li><p>跳出感情的舒适区，全面和立体的接触彼此，了解对方</p></li></ul><h2 id="7-利用话轮技术高效聊天"><a href="#7-利用话轮技术高效聊天" class="headerlink" title="7.利用话轮技术高效聊天"></a>7.利用话轮技术高效聊天</h2><h3 id="话轮技术：二到多人交流时，每个人在自己轮次里面的连续表达"><a href="#话轮技术：二到多人交流时，每个人在自己轮次里面的连续表达" class="headerlink" title="话轮技术：二到多人交流时，每个人在自己轮次里面的连续表达"></a>话轮技术：二到多人交流时，每个人在自己轮次里面的连续表达</h3><h3 id="相当原则"><a href="#相当原则" class="headerlink" title="相当原则"></a>相当原则</h3><ul><li><p>时长相当</p><ul><li><p>不要说太多，也不要听太多</p><ul><li>公式化表达：表述自身的资源和观点，再以好奇心抛出一个半开放性问题</li></ul></li></ul></li><li><p>注意力投入相当</p><ul><li><p>保持高投入，引导对方也拥有高投入</p><ul><li>表露观点，而不是陈述太多内容</li></ul></li></ul></li><li><p>地位相当</p><ul><li><p>不要高姿态，也不要低姿态</p><ul><li>减少锁闭型发问</li><li>不要出让所有的选择权</li></ul></li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>环境单一，不要嘈杂</p><ul><li>西餐厅、咖啡厅</li></ul></li><li><p>选择无意识加工就能完成的事情</p></li><li><p>手机收起来，放进包里</p></li></ul><h3 id="所有这些交流，乃至所有跟对方的谈话，都是为了一个目的：和对方达成一定程度的共识"><a href="#所有这些交流，乃至所有跟对方的谈话，都是为了一个目的：和对方达成一定程度的共识" class="headerlink" title="所有这些交流，乃至所有跟对方的谈话，都是为了一个目的：和对方达成一定程度的共识"></a>所有这些交流，乃至所有跟对方的谈话，都是为了一个目的：和对方达成一定程度的共识</h3><h2 id="8-爱情赋予物质意义"><a href="#8-爱情赋予物质意义" class="headerlink" title="8.爱情赋予物质意义"></a>8.爱情赋予物质意义</h2><h3 id="物质不能直接兑换爱情，而是爱情让物质的存在和分享拥有了更深层次的含义"><a href="#物质不能直接兑换爱情，而是爱情让物质的存在和分享拥有了更深层次的含义" class="headerlink" title="物质不能直接兑换爱情，而是爱情让物质的存在和分享拥有了更深层次的含义"></a>物质不能直接兑换爱情，而是爱情让物质的存在和分享拥有了更深层次的含义</h3><h3 id="不依赖物质来弥补安全感的缺失，而是通过一段让人享受的爱情，来维系生活中的从容不迫"><a href="#不依赖物质来弥补安全感的缺失，而是通过一段让人享受的爱情，来维系生活中的从容不迫" class="headerlink" title="不依赖物质来弥补安全感的缺失，而是通过一段让人享受的爱情，来维系生活中的从容不迫"></a>不依赖物质来弥补安全感的缺失，而是通过一段让人享受的爱情，来维系生活中的从容不迫</h3><h3 id="恋爱中好好花钱"><a href="#恋爱中好好花钱" class="headerlink" title="恋爱中好好花钱"></a>恋爱中好好花钱</h3><ul><li><p>花在体验上&gt;花在实物上</p><ul><li>彼此投入时间、情感、精力，共同的体验</li></ul></li><li><p>花在关爱上&gt;花在享受上</p><ul><li>爱好的投资、健康的投资、个人精进的投资、家庭的投资</li></ul></li><li><p>一起省钱&gt;一起花钱</p></li><li><p>两人一起花</p><ul><li><p>全包圆</p><ul><li>对方感到被动</li></ul></li><li><p>一点也不出</p><ul><li>造成双方地位的进一步不平等</li></ul></li></ul></li></ul><h2 id="9-暗恋不值当"><a href="#9-暗恋不值当" class="headerlink" title="9.暗恋不值当"></a>9.暗恋不值当</h2><h3 id="社会交换理论"><a href="#社会交换理论" class="headerlink" title="社会交换理论"></a>社会交换理论</h3><ul><li><p>盈利=回报-支出</p><ul><li><p>两层含义：物质与情感</p></li><li><p>暗恋</p><ul><li>支出：心血、时间、财富</li><li>回报：或积极或积极的心理感受</li></ul></li></ul></li><li><p>关系满意度=盈利-对比度</p><ul><li><p>对比度（强势与弱势）：指这段关系中，双方在关系主导权上的差异</p></li><li><p>暗恋</p><ul><li><p>地位很低、弱势明显、对比度数值很高</p><ul><li>微薄的盈利无法提升关系满意度</li></ul></li></ul></li></ul></li><li><p>排他性=盈利-候选对比度</p><ul><li><p>候选对比度</p><ul><li>指情感状态中，一方与另一方不可替代的程度的差异</li></ul></li><li><p>暗恋</p><ul><li><p>候选对比度很高</p><ul><li>排他性很低</li></ul></li></ul></li></ul></li><li><p>情感承诺度=满意度+排他性</p><ul><li><p>情感承诺度：指一个人在当下关系中继续坚持的可能性</p></li><li><p>暗恋</p><ul><li><p>满意度低、排他性低-&gt;情感承诺度低</p><ul><li>成功率和靠谱率低</li></ul></li></ul></li></ul></li></ul><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul><li>要么默默离开</li><li>要么勇敢摊牌</li></ul><h3 id="如何解析爱情"><a href="#如何解析爱情" class="headerlink" title="如何解析爱情"></a>如何解析爱情</h3><ul><li>盈利越高越好、对比度越低要好、关系满意度越高越好、候选对比度越低越好、排他性越高越好、情感承诺度越高越好</li></ul><h2 id="10-爱情需要相似性"><a href="#10-爱情需要相似性" class="headerlink" title="10.爱情需要相似性"></a>10.爱情需要相似性</h2><h3 id="互补性可以带来魅力，相似性是爱情的必要条件"><a href="#互补性可以带来魅力，相似性是爱情的必要条件" class="headerlink" title="互补性可以带来魅力，相似性是爱情的必要条件"></a>互补性可以带来魅力，相似性是爱情的必要条件</h3><h3 id="缘分：因为相似性，所以相识的心理学效益"><a href="#缘分：因为相似性，所以相识的心理学效益" class="headerlink" title="缘分：因为相似性，所以相识的心理学效益"></a>缘分：因为相似性，所以相识的心理学效益</h3><h3 id="存在哪些相似性"><a href="#存在哪些相似性" class="headerlink" title="存在哪些相似性"></a>存在哪些相似性</h3><ul><li><p>地理上的相似性</p></li><li><p>社会阶层上的</p></li><li><p>先天相似性不足，也可以培养后天的相似性：熟悉感</p><ul><li>长期交流与共处培养</li></ul></li></ul><h3 id="拿相似性督促自己的进度与成长"><a href="#拿相似性督促自己的进度与成长" class="headerlink" title="拿相似性督促自己的进度与成长"></a>拿相似性督促自己的进度与成长</h3><h2 id="19-走出情感舒适区，克服恋爱恐惧症"><a href="#19-走出情感舒适区，克服恋爱恐惧症" class="headerlink" title="19.走出情感舒适区，克服恋爱恐惧症"></a>19.走出情感舒适区，克服恋爱恐惧症</h2><h3 id="情感舒适区"><a href="#情感舒适区" class="headerlink" title="情感舒适区"></a>情感舒适区</h3><ul><li>舒适区是一种人际关系和心理状态，当你身处其中时，总是感觉舒服一点。舒适区中能获得安全感</li></ul><h3 id="跳出舒适区的正确认知"><a href="#跳出舒适区的正确认知" class="headerlink" title="跳出舒适区的正确认知"></a>跳出舒适区的正确认知</h3><ul><li><p>跳出舒适区可能收获收益，也有可能遭遇风险</p></li><li><p>需要设立跳出后的目标</p></li><li><p>要想跳出舒适却，需要学会反驳自我</p><ul><li>搜集证据</li><li>做出选择</li><li>化解灾难</li></ul></li></ul><h2 id="18-如何表白"><a href="#18-如何表白" class="headerlink" title="18.如何表白"></a>18.如何表白</h2><h3 id="需要避免的表白方式"><a href="#需要避免的表白方式" class="headerlink" title="需要避免的表白方式"></a>需要避免的表白方式</h3><ul><li><p>讲排场的表白</p><ul><li>会给对方带来很负面的感受，容易让对方感觉到是绑架而非表白</li></ul></li><li><p>马拉松式的表白</p><ul><li>软磨硬泡，死缠烂打</li></ul></li><li><p>生硬与直接地让对方给句话</p></li><li><p>拿钱砸的表白</p><ul><li>物质属性强烈，缺乏情感作为爱情核心驱动力</li></ul></li></ul><h3 id="构建简约而不简单的表白"><a href="#构建简约而不简单的表白" class="headerlink" title="构建简约而不简单的表白"></a>构建简约而不简单的表白</h3><ul><li><p>关系基础</p><ul><li>足够的共同经历、体验与生命的相似性</li></ul></li><li><p>良好体验</p><ul><li>站在对方的角度思考，无论同意还是拒绝，让对方舒适地做出决策</li></ul></li><li><p>未来愿景</p><ul><li>对于未来发展的共识</li></ul></li></ul><h2 id="17-正确认识表白"><a href="#17-正确认识表白" class="headerlink" title="17.正确认识表白"></a>17.正确认识表白</h2><h3 id="评估表白是否成功的标准"><a href="#评估表白是否成功的标准" class="headerlink" title="评估表白是否成功的标准"></a>评估表白是否成功的标准</h3><ul><li>双方对于关系的下一步发展是否达成了共识。做恋人？继续做朋友？再发展着看一看呢？</li></ul><h3 id="表白的类型"><a href="#表白的类型" class="headerlink" title="表白的类型"></a>表白的类型</h3><ul><li><p>水到渠成的表白</p><ul><li>足够的共同经历、体验与生命的相似性，水到渠成走向了恋爱关系</li></ul></li><li><p>激情诱发的表白</p><ul><li>情感爆炸</li><li>减低了门槛，但容易同意后后悔</li></ul></li><li><p>青梅竹马的积淀</p><ul><li>长期的共同相处和共同经历，生命存在足够的相似性，有足够的表白基础</li><li>收获了一个爱人，但失去了一个最好的朋友。需要认识到：从朋友升级到爱人，并没有失去一个好朋友，而是收获了一个更贴心的朋友</li></ul></li><li><p>情急下的表白</p><ul><li>紧张氛围下，共患难后的表白</li></ul></li><li><p>自我感动式的表白</p><ul><li>磅礴气势，自我感动。成功率最低</li></ul></li><li><p>不求结果的表白</p><ul><li>全盘托出自我，依靠表白表达自己的情绪</li></ul></li></ul><h2 id="16-爱情中的安全感"><a href="#16-爱情中的安全感" class="headerlink" title="16.爱情中的安全感"></a>16.爱情中的安全感</h2><h3 id="安全感不是看给的多不多，而要看恋爱双方各自有着怎样的依恋风格"><a href="#安全感不是看给的多不多，而要看恋爱双方各自有着怎样的依恋风格" class="headerlink" title="安全感不是看给的多不多，而要看恋爱双方各自有着怎样的依恋风格"></a>安全感不是看给的多不多，而要看恋爱双方各自有着怎样的依恋风格</h3><h3 id="依恋风格跟什么因素相关？"><a href="#依恋风格跟什么因素相关？" class="headerlink" title="依恋风格跟什么因素相关？"></a>依恋风格跟什么因素相关？</h3><ul><li>基因</li><li>原生家庭</li><li>以及曾经的巨大创伤</li></ul><h3 id="依恋风格类型"><a href="#依恋风格类型" class="headerlink" title="依恋风格类型"></a>依恋风格类型</h3><ul><li><p>安全型</p><ul><li>建立了对自我的肯定，和对外界的肯定</li><li>对别人投注的安全感，高效转化，对伴侣充满信任</li></ul></li><li><p>关注型</p><ul><li>难以名状的自卑和唯唯诺诺，需要时刻与恋人粘在一起，时常缺乏安全感</li><li>需要提高对自我的认同感</li></ul></li><li><p>冷模型</p><ul><li>认为外界不可靠，不情愿接受和认可他人的帮助，同时也很吝啬向恋人提供安全感</li><li>提高对他人的认同感</li></ul></li><li><p>恐惧型</p><ul><li>经历了非常困苦的环境，萌生了对自身评价不高，对外界评价也很低的依恋状态，对社会和恋人都充满了不信任，没法建立起长期的情谜关系</li><li>先处理好自己的心理短板</li></ul></li></ul><h2 id="15-如何面对爱情中的舆论压力"><a href="#15-如何面对爱情中的舆论压力" class="headerlink" title="15.如何面对爱情中的舆论压力"></a>15.如何面对爱情中的舆论压力</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ul><li>树立科学的恋爱标准，在舆论中保持自我</li><li>坚守自己的底线不动摇，也就是保持定力</li><li>帮助自己确定一个自己能够接受的亲密关系，而非一段病急乱投医的凑合感情</li></ul><h3 id="基本底线"><a href="#基本底线" class="headerlink" title="基本底线"></a>基本底线</h3><ul><li><p>谈恋爱不一定就非得结婚</p><ul><li>寻找恋爱对象是在一种进入一段长期稳定的亲密关系的可能性</li><li>约会并不意味着一定要关系要深入发展下去，如果气场不和，不需要浪费彼此的时间</li></ul></li><li><p>谈恋爱应该能够让你享受其中</p><ul><li>如果发现不那么喜欢和对方相处，即使很多人担保你和对方合适，也应该保持有意识的清醒，而非被舆论绑架</li></ul></li><li><p>好的恋情一定不会让你萌生更多孤独</p><ul><li>寻找恋人是希望藉由对方看到一个更广阔和更美好的世界，如果对方成了蜗壳，而你是一只步履蹒跚而内心孤独的蜗牛，那么就有必要考虑抛弃这套枷锁</li></ul></li><li><p>了解你以及对方是否打算不打算结婚</p><ul><li>若双方都本着以结婚和目的的态度投入这段感情，亲密关系的众多正向指标都会稳定的多</li><li>若两个人在是否以结婚为恋爱目的这件事情上貌离神合，那恋情容易出问题</li></ul></li></ul><h2 id="14-如何处理好爱情的矛盾"><a href="#14-如何处理好爱情的矛盾" class="headerlink" title="14.如何处理好爱情的矛盾"></a>14.如何处理好爱情的矛盾</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>别让愤怒或委屈冲昏了脑袋，要理智表达，不要刻薄相待</li><li>处理矛盾的核心：即使面对矛盾，我们依然要好好说话</li></ul><h3 id="矛盾的特性"><a href="#矛盾的特性" class="headerlink" title="矛盾的特性"></a>矛盾的特性</h3><ul><li>不可避免性</li><li>中立性</li></ul><h3 id="禁忌话题"><a href="#禁忌话题" class="headerlink" title="禁忌话题"></a>禁忌话题</h3><ul><li><p>地漏问题</p><ul><li>不管为什么争执，总能兜兜转转到某个具体问题</li></ul></li><li><p>试图总结对方</p><ul><li>是不是这个意思？balabala 听着像总结，实际上充满了自以为是的曲解</li></ul></li><li><p>预先归因</p><ul><li>对方话还没说完，就提前打断对话，扣个大帽子</li></ul></li><li><p>封闭性问题</p><ul><li>例如：你到底有没有给我打电话？ 别说别的，你就说有没有打！</li></ul></li><li><p>把问题转化为骂街</p><ul><li>例如：你这个人是不是有病？</li></ul></li><li><p>不断翻旧账</p><ul><li>把一个问题变成一堆问题，例如：上次，上上次，还有上上次！</li></ul></li><li><p>好为人师的说教</p><ul><li>例如：你闭嘴，你听我说，你什么都不懂</li></ul></li></ul><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul><li>憋不住火了，先吃糖</li></ul><h2 id="13-如何管理好爱情中的磨合"><a href="#13-如何管理好爱情中的磨合" class="headerlink" title="13.如何管理好爱情中的磨合"></a>13.如何管理好爱情中的磨合</h2><h3 id="处理争执的原则"><a href="#处理争执的原则" class="headerlink" title="处理争执的原则"></a>处理争执的原则</h3><ul><li><p>原则：一定要让矛盾与争执有价值，有价值的矛盾是让爱情双方越来越来越契合的保障</p></li><li><p>有价值的矛盾</p><ul><li>在亲密关系中，会不会因为同一个话题，频繁的反复争执</li><li>不同的争执主题：说明双方在改变、在磨合、亲密关系在进步</li></ul></li></ul><h3 id="需要避免的交流陷阱"><a href="#需要避免的交流陷阱" class="headerlink" title="需要避免的交流陷阱"></a>需要避免的交流陷阱</h3><ul><li><p>蔑视</p><ul><li>把对方放在了一个比自己更低的地位，或者认为对方的言行不可理愈</li></ul></li><li><p>讥讽</p><ul><li>刻意的、对他人特质的错误评价和错误衍生</li></ul></li><li><p>无端的戒心</p><ul><li>把身边大多数人当作了假想敌，预先假设别人对自己有所图谋</li></ul></li><li><p>消极的沉默</p><ul><li>对方说了不爱听的话，不选择反驳或辩解，只选择了七分怒火和三分委屈的沉默</li></ul></li><li><p>没来由的调戏</p><ul><li>对他人客观能力、正当权益或者实际地位的挑战</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>自我约束</li><li>时刻给交流足够的优先级</li><li>未必认可对方的观点，但一定要认可对方观点存在的合理性</li><li>积极分享自身的个人能力</li><li>用积极的词汇提出要求</li></ul><h2 id="12-高情商表述"><a href="#12-高情商表述" class="headerlink" title="12.高情商表述"></a>12.高情商表述</h2><h3 id="情商能力模型"><a href="#情商能力模型" class="headerlink" title="情商能力模型"></a>情商能力模型</h3><ul><li><p>情绪感知能力</p><ul><li>解读情绪和从当下环境中最大化感性信息获取的重要基础</li><li>主要依靠它来识别自身和他人的情绪，以调整和优化自己的情绪、表达与行为</li></ul></li><li><p>情绪运用能力</p><ul><li>促进自己与群体认知加工的能力</li><li>通过情绪运用，营造出充满治愈感的温暖气场</li></ul></li><li><p>情绪理解能力</p><ul><li>能不能理解对方当下复杂情绪的组成成分和强度水平</li><li>情绪对另一种情绪的诱发关系</li></ul></li><li><p>情绪管理能力</p><ul><li>指的是对或好或坏的情绪都能抱有开放的心态，监控和反思自身情绪，还能够保留或摆脱某种情绪状态</li><li>不以物喜，不以己悲</li></ul></li></ul><h3 id="情绪脚本"><a href="#情绪脚本" class="headerlink" title="情绪脚本"></a>情绪脚本</h3><ul><li><p>什么场合？</p><ul><li>约会？朋友聚餐？看电影？</li></ul></li><li><p>什么关系？</p><ul><li>普通的个体关系？恋爱关系？追求对象？</li></ul></li><li><p>有什么情绪？</p><ul><li>我高兴？他羞涩？我愤怒？我开心？</li></ul></li><li><p>强迫自己的意识和认知参与到行为与话语的调控过程</p></li></ul><h2 id="11-从友谊到爱情"><a href="#11-从友谊到爱情" class="headerlink" title="11.从友谊到爱情"></a>11.从友谊到爱情</h2><h3 id="友谊升级成爱情，有着天然的优势和基础"><a href="#友谊升级成爱情，有着天然的优势和基础" class="headerlink" title="友谊升级成爱情，有着天然的优势和基础"></a>友谊升级成爱情，有着天然的优势和基础</h3><ul><li>朋友一般属于个体关系和紧密关系的层次，更容易向亲密关系发展</li></ul><h3 id="友谊-gt-爱情的要素"><a href="#友谊-gt-爱情的要素" class="headerlink" title="友谊-&gt;爱情的要素"></a>友谊-&gt;爱情的要素</h3><ul><li>彼此间分享的生活交集</li><li>共同经历的事件演变</li></ul><h3 id="恋人与朋友的差别"><a href="#恋人与朋友的差别" class="headerlink" title="恋人与朋友的差别"></a>恋人与朋友的差别</h3><ul><li>更深的信任，这来自于彼此高水平的交互</li><li>强烈的浪漫，这来自于共有体验中对情感的高度激活</li></ul><h3 id="评估双方关系"><a href="#评估双方关系" class="headerlink" title="评估双方关系"></a>评估双方关系</h3><ul><li><p>彼此的性吸引</p></li><li><p>剧烈的排他性</p><ul><li>适当的时间点，营造独处的机会</li><li>非言语信息：击破友谊的界限的核心指标</li></ul></li></ul><h3 id="朋友-gt-恋人"><a href="#朋友-gt-恋人" class="headerlink" title="朋友-&gt;恋人"></a>朋友-&gt;恋人</h3><ul><li><p>心有灵犀，步调一致</p><ul><li>打交道时，少点自我，多点共鸣</li><li>培养更多一致的行为，相似的做事风格和表达习惯</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/kexuekanaiqing.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>战后日本经济史</title>
      <link href="/2022/06/22/zhan-hou-ri-ben-jing-ji-shi/"/>
      <url>/2022/06/22/zhan-hou-ri-ben-jing-ji-shi/</url>
      
        <content type="html"><![CDATA[<p>作者：[日] 野口悠纪雄</p><p>出版年：2018-4</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/zhanhouribenjingjishi.jpg" style="zoom: 50%;" /><h4 id="1945-1959-战后日本经济开始复苏"><a href="#1945-1959-战后日本经济开始复苏" class="headerlink" title="1945-1959 战后日本经济开始复苏"></a>1945-1959 战后日本经济开始复苏</h4><p>战后日本的政府经济部门和金融体制都没有收到沉重打击</p><p>1.日本的政府经济部门被基本保留。由于占领军对日官僚系统的不了解（战时操纵日本经济运行的正是这些日本经济部门），战后日本的经济部门被保留了下来，战后继续操纵日本的经济</p><p>2.日本战时形成的以银行为中心的日本金融部门被完整的保留了下来。占领君按照战前美国的逻辑推测日本，对日本的财阀、家族统治消除了，却保留了银行等金融部门</p><p>日本经济复兴的原因</p><p>1.日本的战时体制优势，集中力量办大事政府倾斜资源划分给煤炭和钢铁等基础产业，恢复生产设备。能做到这一点的前提是战争时期形成的金融体系，这些体系原本是以向军需产业集中资源，到了战后变成向基础产业集中资源</p><p>2.美国的直接帮助和扶持。朝鲜战争，美国将日本作为补给基地</p><p>3.利用占领军能快速有效推行经济政策</p><p>战后史观和1940体制史观</p><ul><li><p>战后史观：日本因为摆脱了军费的沉重负担，从而实现了经济增长。大企业被分割，企业经验民主化。索尼本田等企业成为了战后日本经济的引擎。工会得以成长，开始影响企业经验。所以是工会的民主化和企业的民主化激活了企业的活力</p></li><li><p>1940体制史观：对日本战后起到最重要作用的，是通过统制方式进行的资金重点分配。生产力得以快速恢复，为接下来的高速增长做好了准备。实现这一基础，是战争时期形成的以支援战争为目的的经济体制，也就是1940体制</p></li></ul><h4 id="1960-1970-高速增长"><a href="#1960-1970-高速增长" class="headerlink" title="1960-1970 高速增长"></a>1960-1970 高速增长</h4><p>日本的高速增长实质上是农业社会实现工业化发展的过程</p><p>高速增长的制度基础</p><ol><li>低利率与资金配给</li><li>财政投融资政策</li></ol><h4 id="1971-1979-战胜石油危机"><a href="#1971-1979-战胜石油危机" class="headerlink" title="1971-1979 战胜石油危机"></a>1971-1979 战胜石油危机</h4><p>1.汇率。日元升级降低了进口产品的价格，从而缓解了原油价格提升带来的影响</p><p>2.日本的工资决定机制。日本的工会是以企业为单位组件的，石油危机发生时，工会与企业管理层团结一致，把公司的生存问题放到了高于加薪的地位，没有使日本进入成本推动通货膨胀的恶性循环</p><h4 id="1980-1989-金闪闪的80年代"><a href="#1980-1989-金闪闪的80年代" class="headerlink" title="1980-1989 金闪闪的80年代"></a>1980-1989 金闪闪的80年代</h4><p>日本第一。汽车产量超过美国。石油危机导致汽油价格暴涨，人们转而购买高效省油的日本汽车。半导体也打败美国，成为世界第一。</p><p>逆石油危机：原油价格下跌</p><p>广场协议-&gt;日元升值</p><p>日元升值-&gt;出口减缓-&gt;金融缓和政策-&gt;基准利率下调</p><p>出口虽然减缓，但是消费支出保持了稳步增长，日本GDP增长率继续上升</p><p>泡沫形成：</p><p>由于海外自由化的压力，80年代开始日本开始阶段性推行金融自由化，利率开始由市场决定。</p><p>可转化债券，特定信托基金，短期融资券等金融工具出现，企业不再关注原本的生产经营，而是将精力用于依靠投资理财来获取收益</p><p>地价开始暴涨、股价开始暴涨、最高时期日本企业占据了全世界企业市场价总额的一半。</p><p>由于对未来的过大期待以及金融缓和政策所引起的不伴随实际需求的暂时高涨</p><p>泡沫开始形成。辛勤劳动未必能获得相应的回报，而空手套白狼的各种虚假无德的行为却能带来巨大的财富，这样的情况深深刺痛着人们的尊严</p><p>随着经济国际化和自由化，战时金融体制1940体制需要从根本上进行变革，也就是从以银行为中心的间接金融体系向直接金融体系进行软着陆</p><h4 id="1990-1999-泡沫与1940体制的消亡"><a href="#1990-1999-泡沫与1940体制的消亡" class="headerlink" title="1990-1999 泡沫与1940体制的消亡"></a>1990-1999 泡沫与1940体制的消亡</h4><p>泡沫崩溃：</p><p>1990年开始连续实施了金融紧缩政策，抑制地价上涨</p><p>金融机构存在大量不良债权</p><p>日本未能跟上时代的脚步，其重要原因在于，1940体制无法适应新型信息通信技术体系。</p><p>日本经济萧条的根本原因不在于地价下跌导致不良债权问题迟迟未能解决，也不在于居民消费物价指数下降，而在于日本的产业结构和经济体制不再适应新时代的要求</p><p>日本经济开始陷入长期停滞</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>梁永安:阅读、游历和爱情</title>
      <link href="/2022/06/15/liang-yong-an-yue-du-you-li-he-ai-qing/"/>
      <url>/2022/06/15/liang-yong-an-yue-du-you-li-he-ai-qing/</url>
      
        <content type="html"><![CDATA[<p>作者：梁永安</p><p>出版年：2022-5-21</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/liangyongan.jpg" style="zoom: 33%;" /><h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>当我吃下第一口自己种出来的番茄时，喜悦盈满身心。那一刻我深切体会到，自己种出来的果实最香甜，其他一切都显得虚浮。也就在那个时刻，我明白了幸福和快乐不是一回事：快乐时轻松欣喜，实现心之所欲；而幸福，那是一路艰辛的奋斗，是生命的展开，是一步一步地活过</p><h4 id="谈自我"><a href="#谈自我" class="headerlink" title="谈自我"></a>谈自我</h4><p>如何衡量价值？每天都反思以下自己，看看知识上有没有增加？文化视野的宽度有没有扩大？情感的含量有没有更加丰富？行动性有没有增强？</p><p>人的自我问题，涉及到多个层面</p><ul><li>本然的自我，即自然人，一路成长过来形成的自我，是以往你所有选择的结果，具有实在性。</li><li>想象的自我，即自己觉得自己是怎么样的人</li><li>理想中的自我，即自己觉得理想中的自我应该是什么样子</li></ul><p>社会面向全球的时候，我们需要海洋文明的精神推送它；坚持做周期性的事情时，要时段，要播种、收获，需要坚持农业文明的开垦性和持久性；而要探索生活的自由感时，又需要游牧民族特质发挥作用（仰望星空的好奇心，脚踏实地的恒心，追求自由的决心）</p><p>青年人要认识自我，不能坐在房子里，坐井观天，往往需要在不完美的探索中认识自己，有痛苦，有快乐，于痛苦中发现自己还活着，于欢乐中发现自己还很平庸，在这个过程中，才逐渐知道自己热爱什么样的生活，跟什么样的世界联系在一起。这就是所谓青春的激情</p><p>今天的价值体系正在转型，人会寻求物质、精神的两面实现，而时代给予的条件不能完全达到，男生就处于被两面夹攻的状态。他们一方面想传宗接代，期待有一套自己的房子，立自己的门户；另一方面，他们又感觉被房子这类物质需求压得喘不过气，心理还有另一种期待，希望生活更加自由</p><h4 id="谈工作"><a href="#谈工作" class="headerlink" title="谈工作"></a>谈工作</h4><p>年轻人要将自己的喜欢变成真实的行动，那就是去工作。对一种事物到底喜不喜欢，我们不能仅在表面判断。还必须经历对他专业化的渗透，投入到专业分工的劳动深度里去。一种事物穷极到深处就会有自由，就会升华到艺术层面的享受</p><p>人要先把一个事情做透，做到专业领域中最好的状态，然后这时候才能说你到底爱不爱它，才能说你到底真正适合去做什么</p><p>是否喜欢一份工作，你要明白一个关键问题：做这件事情，这辈子会跟什么样的人在一起。工作不仅仅是一份工作那么简单，生命须臾，跟什么样的人一起度过这些岁月，这是最有价值的</p><p>年轻人最不好、最不能的就是只抱怨但提不出建设性、成长性的方案。抱怨和批评只能让彼此负重前行，无益于彼此</p><p>这个世界有那么多的问题，归根到底是劳动的价值没有得到尊重。一切工作都是以劳动者获取自己的价值和尊严为前提，最基本的正义是让全天下的劳动者获取公正，获得自己应该过的生活</p><h4 id="谈人格"><a href="#谈人格" class="headerlink" title="谈人格"></a>谈人格</h4><p>今天我们很难定义什么是好，什么是坏，这是一个需要起步、新的思考的时代。跳出原来固定的框架，然后去选择你生活的方向，一切交给时间来回答，或许这样我们才能在今天这个时代活出质量</p><p>好人的标准是我们自己的内心感觉是否幸福，另外一个标准是有没有对别人造成大的伤害</p><p>一个人要有把自己当作试验品的坚定信念，这样你才有无畏的生活，为社会做出贡献，尽量成为一个好人</p><h4 id="躺平与幸福"><a href="#躺平与幸福" class="headerlink" title="躺平与幸福"></a>躺平与幸福</h4><p>打破一切权威，去热爱真实的世界</p><p>今天的年轻人，离自己向往的生活只有一步之遥，但是就这一步之遥，但是就这一步之遥跨不过去。他们内心积累了这么多感受和愿意去探索的东西，但是行动跟不上，暴风骤雨迎面而来的时候，就没有那个勇气</p><p>孤独不是坏事情，孤独本身是一个体会自我的过程，是一个不断认识我们生命的过程。只有孤独的人才有真正的交流能力，因为他有一个不断沉淀的过程</p><h4 id="谈女性文化"><a href="#谈女性文化" class="headerlink" title="谈女性文化"></a>谈女性文化</h4><p>女性需要伟大的独立精神，把爱情这个女性文学的传统主题放到第二位，而把人生自由的创造性放到女性生存的中心。女性的高度不在于看过几本书，也不是通过城市的生活幻境抵达，而是在辽阔的大地上实现。只有把自己的生命和自然世界，以及充满朴素真情的人们联系在一起，人才会精神欢喜。找到女性文化的根系，这是现代女性真正要解决的问题</p><p>一个人有过逆流而上的人生，才算真正体验过生活。在农业社会中很多人都希望风调雨顺，平平顺顺，这样的生活最是庸常的，就像一条鱼在同一个水层游动，还没有更多的机会思考生命的深刻议题时，一生就这样过去了。人需要过一种逆流而上的生活，这种生活虽然艰苦，但可以打开生命的维度</p><p>一个人一辈子需要出生两次，第一次是生理上的出生，第二次出生是精神上的觉醒，知道自己应该做一个什么样的人。每个人都面临第二次创造自己的人生任务，世界上大部人都没有完成这个任务，因为没有这个意识</p><p>现代社会是，男女双方对彼此都比较失望。女性对男性持批判性意见，也说明她们对男性的期待很大，希望跟这个人在一起能获得另外一个延展的世界；男性对女性也存在失望情绪，觉得女性怎么变得这么物欲，现实</p><h4 id="谈女性写作"><a href="#谈女性写作" class="headerlink" title="谈女性写作"></a>谈女性写作</h4><p>有天赋的人，文字之余他，是没有枷锁的，等于他活在文字里。如果一个人有写作天赋的话，那些文字跟他就像是亲人一样，二者没有距离</p><p>人有时候要对自己的生活状态做一些有益的调整，人需要奋斗，不要想着让人生的一切都符合自己的舒适度。其实我们在这个世界上无非是协调两个关系：一个是和自然的关系，另一个是和他人的关系</p><p>两个人结合在一起最好的一种形式，就是看到了对方非常有价值，自己非常喜欢认同的部分。比如说，这个人很朴实，他很喜欢旅行，喜欢拍照，喜欢写作，正好跟自己相合，自己也认同这种生活。</p><p>其实爱上一个人就是爱上一种生活。</p><p>喜欢一个人，跟他在一起，你要看他到底在干什么，他在建设一种什么样的生活。爱情是两个人一起去建设一种生活，两个人都是生活的建设者</p><p>自由的生活有一个特点，就是把自己变成社会的一部分，不完全属于自己。我们在这个社会上一生的使命就是给社会探索一点新东西。越是这样的人，他的情感就越不容易被那些外在的标准衡量</p><h4 id="谈爱情"><a href="#谈爱情" class="headerlink" title="谈爱情"></a>谈爱情</h4><p>这种矛盾性是我们今天的普遍状态。我们拥有自由，但是又不实质拥有它，它近在身边，却拿不到。所以我们中国青年普遍地面临“一步之遥的问题”。观念上过不去，虚妄的恐惧统治着自己，这造就了很高的心理门槛。这是因为历史转变得太快，我们的身体在城市里，灵魂还在乡村</p><h4 id="谈孤独"><a href="#谈孤独" class="headerlink" title="谈孤独"></a>谈孤独</h4><p>人要有点离群索居的气质，要有点孤独的能力。</p><p>每个人都有非常好的天资，人在社会上最怕的就是这辈子被自己的杂志淹没。</p><p>我们在孤独中需要一点儿上帝视角，那是对自己的审判，对自己的清理。如果没有孤独来帮我们实现，在喧嚣与骚动中，人人在漂流，哪有时间来反省自己</p><p>今天社会的突出问题，就是你身上有很多可能性，但是生活得没什么可能。这里面有两个矛盾：一个是你想得很多，真正的行动很少；再有，你自己特别希望开拓自由的、不一样的生活，却又特别希望一切风调雨顺，希望自己开拓的新生活能够得到父母的祝福，别人的夸奖和社会的承认。但是用农业社会种瓜得瓜，种豆得豆的逻辑去打开自由，是完全不可能的事情</p><p>人并不是要决定改变时才特别孤独。全世界的人类，只要有自己真正的价值思考，有思辨精神，很大程度上他都是孤独的。因为这个世界处于很大的矛盾中，各种各样的力量裹挟着人，形成一股一股强横的对抗力量</p><h4 id="谈读书"><a href="#谈读书" class="headerlink" title="谈读书"></a>谈读书</h4><p>书也不是读得越多越好、越广越好，多是必要的，广也是好的，但是一个人一辈子一定要找到自己的生命之书，那里蕴含着你对自己人生的认知。读书，绝不仅是一种外在的文字览阅，也不仅仅是客观的知识吸收，更多情况下，读书就像是和雪中送碳的知己交流</p><p>人终归需要一点精神的世界，需要靠心得生活，靠心生活能够跟世界建立起一种更真实、更神奇的联系。我们来世界一趟，怎么才能真正体会这个世界，真正扩展我们的生命？我觉得可以试试读好书，试着写一写书，如此，才会发现自己内心的渴望</p><h4 id="谈生活"><a href="#谈生活" class="headerlink" title="谈生活"></a>谈生活</h4><p>年轻人一定要思考世界再往前走会出现什么可能，要多看一点儿书，查一些资料，给自己一个超前性的定位。不要自己还是春天，却忙得像秋天，想要结果。现在的年轻人首要考虑如何开出自己的花来，哪怕是一朵小蓓蕾，足矣</p><p>这个世界真正的恶人，是自己处在焦虑中，也给他人输送焦虑。好多人觉得人生这么固化，这么艰难，我凭什么要去关心别人，哪有那个余力？越是这样，人越会沦落到偏黑暗的心境里，这对自我是一种消耗</p><p>从人的成长来说，首先要认识世界，打开世界，进行游历，有一个精神漫游的阶段，这期间你对世界各种各样的认识，会超出你的想象。年轻人要有一种即在其内又在其外的状态，做一个旅行者</p><p>年轻人到一定阶段，就开始认识自我。这时候就会有一个选择性问题。要什么价值，跟什么样的人共事，做什么事情，什么最幸福，跟什么人一起生活，跟异性、同性、还是跟自己，建立起一种什么样的生活方式，在哪儿生活……于是，一切就开始有了计划</p><h4 id="谈社交"><a href="#谈社交" class="headerlink" title="谈社交"></a>谈社交</h4><p>要意识到，我们的社会发展还不充分，个人的差异性追求没有很好的土壤发育，个体的意识、价值观还比较趋同，年轻人的生活特性重合度很高，也就失去了交流的动力</p><p>交互式交流的双方都能彼此成长，是共生关系，这样的交流才是真正地促进友谊、增长感情之道，而不是整天在一起吃一顿喝一顿。年轻人一定要朝着这个方向努力，提升社交质量，拒绝无效社交</p><p>有需求却无法满足的现状下，价值感一定是个人内心的期待，需要自己去主动探索、去追求。而现在年轻人的根本问题是，很多人达不到活得有价值感，自己也不愿意主动去探索生命，于是活得很勉强</p><h4 id="谈修养"><a href="#谈修养" class="headerlink" title="谈修养"></a>谈修养</h4><p>真正有价值的是寻找、珍惜自我，懂得这个世界的自由，珍惜个人生命的自由，关注自己的价值和社会需要的价值，确认自己能做些什么，最终做出一些跟别人不一样的事情，为社会增添一些亮光，而不是执着于千篇一律的东西。这时，我们才会有一种全新的生命观</p><h4 id="谈美"><a href="#谈美" class="headerlink" title="谈美"></a>谈美</h4><p>看一个人美不美，实际上还是要归根于他的生命观，他对生活的理解。美不仅是视觉感受，还暗含了背后人对生活的理解，对历史的理解，对社会的理解。美不美，不能只看外表，还要看见背后那些深刻的东西</p><p>美是一种实践</p><h4 id="谈艺术"><a href="#谈艺术" class="headerlink" title="谈艺术"></a>谈艺术</h4><p>到了青年时代，我们开始接触社会，有了自己的想法， 逐渐想清楚自己要做一个什么样的人。这种自己诞生自己的过程，就是艺术化的过程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>金字塔原理</title>
      <link href="/2022/06/05/jin-zi-ta-yuan-li/"/>
      <url>/2022/06/05/jin-zi-ta-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>作者：作者: [美]芭芭拉•明托</p><p>出版年：2019-4</p><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/jingzitayuanli.jpg"></p><p>结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先总结后具体，先框架后细节，先结论再原因，先结果后过程，先论点后论据</p><h3 id="表达的逻辑"><a href="#表达的逻辑" class="headerlink" title="表达的逻辑"></a>表达的逻辑</h3><h4 id="为什么要用金字塔结构？"><a href="#为什么要用金字塔结构？" class="headerlink" title="为什么要用金字塔结构？"></a>为什么要用金字塔结构？</h4><p>金字塔结构的信息更容易被读者接受</p><h4 id="如何将思想组织成金字塔结构？"><a href="#如何将思想组织成金字塔结构？" class="headerlink" title="如何将思想组织成金字塔结构？"></a>如何将思想组织成金字塔结构？</h4><p>如果作者传达给读者的思想已经事先进行了归类和概括，并且按自上而下的顺序呈现，读者就能更容易理解作者想要表达的思想。</p><ul><li>归类分组<ul><li>找出逻辑关系，抽象概括，将多个概念抽象后分组</li></ul></li><li>自上而上表达，结论先行<ul><li>先提出总结性思想，再提出被总结的具体思想</li></ul></li><li>自下而上思考，总结概括<ul><li>纵向：文章中任一层次中的思想必须是对其下一层次思想的总结概括</li><li>横向：每组中的思想必须属于同一逻辑范畴</li><li>横向：每组中的思想必须按照逻辑顺序组织关系<ul><li>演绎顺序：大前提：小前提，结论</li><li>时间（步骤）顺序：第一，第二，第三</li><li>结构（空间）顺序：波士顿，纽约，华盛顿</li><li>程度（重要性）顺序：最重要，次重要，等等</li></ul></li></ul></li></ul><h4 id="金字塔内部的结构"><a href="#金字塔内部的结构" class="headerlink" title="金字塔内部的结构"></a>金字塔内部的结构</h4><p>纵向关系：疑问/回答式对话结构</p><ul><li>迫使你在理清思路时，从视觉上使纵向的疑问/回答式对话关系清晰化。你的每一个表述都应当引发读者的疑问，而你也必须在这一表述下的横向层次上回答读者的疑问</li></ul><p>横向关系：横向的演绎或归纳推理</p><ul><li>演绎关系：A-&gt;B,B-&gt;C,所以A-&gt;C</li><li>归纳关系：A，B，C -&gt; 抽象得到D</li></ul><p>序言：讲故事式的序言</p><ul><li>背景、冲突、疑问、回答。说明背景的时间和地点，在这一背景中发生了某件事情，可称之为冲突，使读者提出你的文章将要回答的疑问</li></ul><h4 id="如何构建金字塔"><a href="#如何构建金字塔" class="headerlink" title="如何构建金字塔"></a>如何构建金字塔</h4><p>自上而下法</p><ul><li>1.提出主题思想</li><li>2.设想受众的主要疑问</li><li>3.写序言：背景-冲突-疑问-回答</li><li>4.与受众进行疑问-回答式对话</li><li>5.对受众的新疑问，重复进行疑问-回答式对话</li></ul><p>自下而上法</p><ul><li>1.列出你想表达的所有思想要点</li><li>2.找出各要点之间的逻辑关系</li><li>3.得出结论</li></ul><p>初学者注意事项</p><ul><li>1.一定要先搭结构，先尝试自上而下法</li><li>2.序言先写背景，将背景作为序言的起点</li><li>3.先多花时间思考序言，不要省略</li><li>4.将历史背景放到序言中</li><li>5.序言仅涉及读者不会对其真实性提出质疑的内容</li><li>6.在关键句层次上，更宜使用归纳推理而非演绎推理</li></ul><h4 id="序言的具体写法"><a href="#序言的具体写法" class="headerlink" title="序言的具体写法"></a>序言的具体写法</h4><p>先介绍读者熟悉的背景，说明发生的冲突，并借此引发读者的疑问，然后针对该疑问给出答案</p><p>讲故事结构：让读者抛开复杂的思想，专注于你的话题。激发读者兴趣，吸引注意力：新奇、悬念、与读者本人相关</p><ul><li>背景：<ul><li>文章主题相关，且读者肯定会同意的内容，应当是读者已经认可或者将会认可的内容</li><li>引出背景的句子有一个重要的特征：将读者锁定在特定的时间和空间，从而为讲故事做准备</li></ul></li><li>冲突<ul><li>讲故事时推动情节发展的因素，能够促使读者提出疑问</li></ul></li></ul><p>四个典型的例子</p><ul><li>背景：需要完成某个任务； 冲突：发生了妨碍任务发生的事情；读者的疑问：我们应该怎么做</li><li>背景：存在某个问题；冲突：知道解决问题的方案；读者的问题：如何实施解决方案</li><li>背景：存在某个问题；冲突：有人提出了一个解决方案；读者的问题：该方案是否正确？</li><li>背景：采取了某个行动；冲突：行动给未达到预期；读者的问题：为什么没有达到预期？</li></ul><p>写好序言的原则</p><ul><li>1.序言的目的是提示读者而不是告诉读者某些信息。不应该含有某些需要读者证明才能接受的信息，例如图标</li><li>2.序言必须包含3个要素，即背景、冲突和答案</li><li>3.序言的长度取决于读者和主题的需要</li></ul><p>序言的常见模式</p><p>1.发出指示式：针对我们应该做什么或我们应该怎么做等问句</p><p>2.请求支持式：针对是否应该这样做等问句</p><p>3.解释做法式：针对我们应该如何做等问句</p><p>4.比较选择式：针对我们应该做什么等问句</p><h4 id="演绎推理和归纳推理"><a href="#演绎推理和归纳推理" class="headerlink" title="演绎推理和归纳推理"></a>演绎推理和归纳推理</h4><p>演绎推理</p><ul><li>演绎推理的步骤：大前提+小前提-&gt;结论<ul><li>阐述世界上已经存在的某种情况</li><li>阐述世界上同时存在的相关情况。如果第二个表述是针对第一个表述的主语或者谓语，则说明这两个表述相关</li><li>说明这两种情况同时存在时所隐含的意义</li></ul></li><li>演绎推理也可以时以下三个步骤<ul><li>出现的问题或存在的现象</li><li>产生问题的根源、原因</li><li>解决问题的方案</li></ul></li></ul><p>归纳推理</p><ul><li>正确定义该组思想，找到一个能够表示该组所有思想共同点的名词</li><li>识别并剔除该组思想中与其他思想不相称（不属同类、不具备共同点）的思想</li></ul><h3 id="思考的逻辑"><a href="#思考的逻辑" class="headerlink" title="思考的逻辑"></a>思考的逻辑</h3><h4 id="应用逻辑顺序"><a href="#应用逻辑顺序" class="headerlink" title="应用逻辑顺序"></a>应用逻辑顺序</h4><p>所有列入同一组中的思想必须具有某种逻辑顺序</p><p>1.因果前后关系（时间/步骤顺序）</p><p>2.整体分割为部分，或部分组成整体（结构/空间顺序）</p><p>MECE原则：相互独立，完全穷尽</p><p>3.类似事务按重要性归为一组（程度/重要性顺序）</p><h4 id="概括各组思想"><a href="#概括各组思想" class="headerlink" title="概括各组思想"></a>概括各组思想</h4><p>确保思想属于同一组，应抽象、提炼、概括思想精华</p><p>总结句避免使用缺乏思想的句子</p><p>概括行动性思想（介绍采取的行动、行为、动作、步骤 、流程时），应说明采取行动后取得的结果（效果、达到的目标）</p><p>概括描述性思想（介绍背景、信息）时，应说明这些思想具有的共同点的含义（共同点的意义）</p><p>总结句要说明行动产生的结果/目标</p><p>找出各结论之间的共性</p><h3 id="解决问题的逻辑"><a href="#解决问题的逻辑" class="headerlink" title="解决问题的逻辑"></a>解决问题的逻辑</h3><p>界定问题 -&gt; 结构化分析问题 -&gt; 分析/找到解决方案 -&gt;组成金字塔与他人交流</p><h4 id="界定问题"><a href="#界定问题" class="headerlink" title="界定问题"></a>界定问题</h4><p>判断问题是否存在，通常要看经过努力得到的结果（现状），与希望得到的结果（目标）之间是否有差距。由某一特定背景导致的某一特定结果，称为非期望结果（R1，即现状），问题是指你不喜欢的某一结果，想得到其他结果(期望结果R2)，解决方案则是指如何从现状R1到目标R2</p><p>—- 连续分析</p><p>1.是否/有没有可能有问题(机会) —- 界定问题</p><p>2.问题在哪里 —- 界定问题</p><p>3.为什么存在(产生问题的根源，原因) —-结构化分析原因</p><p>4.我们能做什么  —-寻找解决方案</p><p>5.我们应该做什么  —-寻找解决方案</p><p>界定问题的框架</p><p>1.展开说明框架中的各要素</p><ul><li>发生了什么事情：背景（切入点/序幕+困扰/困惑）</li><li>我们不喜欢它什么（非期望结果R1）</li><li>我们想要什么（期望结果R2）</li></ul><p>2.开始写序言</p><h4 id="结构化分析问题"><a href="#结构化分析问题" class="headerlink" title="结构化分析问题"></a>结构化分析问题</h4><p>收集信息 -&gt; 描述发现 -&gt; 得出结论 -&gt; 提出方案</p><p>结构化分析问题的方法</p><p>1.呈现有形结构</p><ul><li>将整体分割为部分分析，将部分组成整体看待</li></ul><p>2.寻找因果关系</p><ul><li>寻找具有因果关系的要素，行为或者任务，得出最终诊断结果</li></ul><p>3.归类分组</p><ul><li>把所有可能的原因按相似性分类</li></ul><p>建立逻辑树：根据相互独立，完全穷尽的原则，对各种可能性作为一个系统逻辑的细分</p><p>是非问题分析</p><h3 id="演示的逻辑"><a href="#演示的逻辑" class="headerlink" title="演示的逻辑"></a>演示的逻辑</h3><h4 id="在书面上呈现金字塔"><a href="#在书面上呈现金字塔" class="headerlink" title="在书面上呈现金字塔"></a>在书面上呈现金字塔</h4><p>1.突出显示文章的框架结构</p><ul><li>多级标题法：不同层次的思想，用不同的标记区分；层次越低的思想离页面的右端越近；同一层次的思想采用同一表现形式</li></ul><p>2.上下文之间要有过渡</p><h4 id="ppt演示文稿中呈现金字塔结构"><a href="#ppt演示文稿中呈现金字塔结构" class="headerlink" title="ppt演示文稿中呈现金字塔结构"></a>ppt演示文稿中呈现金字塔结构</h4><p>1.每次只演示和说明一个论点</p><p>2.论点使用完整的陈述句，而不是标题性语言</p><p>3.文字尽量简短</p><p>4.使用简单的词汇和数字</p><p>5.字号应该足够大</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刻意练习</title>
      <link href="/2022/05/25/ke-yi-lian-xi/"/>
      <url>/2022/05/25/ke-yi-lian-xi/</url>
      
        <content type="html"><![CDATA[<p>作者：[美] 安德斯·艾利克森（Anders Ericsson） / 罗伯特·普尔（Robert Pool）</p><p>出版时间：2016-11</p><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/keyilianxi.jpg"></p><p>全文中心思想总结：设定目标，专注、有反馈、及时纠正的大量练习，创建行业的心理表征，你能成为行业的专家</p><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>纠正误区</p><ul><li>成功与练习时间并不成正比</li><li>练习的成果并不与时间呈正相关，取决于练习方法</li></ul><p>刻意练习的本质：长时记忆</p><p>认知复杂度：构建客观世界的能力。认知复杂度高的人具有高度复杂化的思维能力，更善于用互补和互不相容的概念来理解客观世界</p><p>隐性知识</p><ul><li>需要到情境中去学习，从情境学习出发，当一名认知学徒<ul><li>找到学习共同体</li><li>隐形知识显性化</li><li>模仿榜样</li><li>培养多样性</li></ul></li></ul><p>一万小时定律给人真正的启发是：耐心地，谦虚地保持大时间周期的可以练习</p><p>本书会告诉什么</p><ul><li>通过正确的训练与练习进行创造的能力。</li><li>如何在行业和领域中发挥自己的才能</li><li>介绍了一种人类潜力的新的思考方式：我们拥有更大的力量来掌握自己的人生</li><li>正确的练习是什么，以及可以怎样发挥它的作用</li></ul><p>本书的脉络：</p><ul><li>刻意练习是什么，为什么管用，杰出人物如何运用它来发展能力，</li><li>天赋与练习之间的交织</li><li>最后解释对我们其他人刻意练习意味着什么，如何将刻意练习运用到专业组织的工作中</li></ul><h3 id="有目的的练习"><a href="#有目的的练习" class="headerlink" title="有目的的练习"></a>有目的的练习</h3><p>在任何行业或领域当中，最有效的和最强大的那类练习，都通过充分利用人类的身体与大脑的适应能力，来逐步塑造和提升他们的技能，以做到一些过去不可能的事情</p><p>天真的练习：反复地做某件事情，并指望只靠那种反复，就能提高表现和水平</p><ul><li>一旦某个人的表现达到了“可接受”的水平，并且可以做到自动化，那么，再多练习几年，也不会有什么进步</li></ul><p>有目的的练习</p><p>走出你的舒适区，但要以专注的方式制定明确的目标，为达到那些目标制定一个计划，并且想要检测出你的进步的方法。还要想办法保持你的动机</p><ul><li>具有定义明确的特定目标<ul><li>明确的目标可以有效引导练习</li></ul></li><li>有目的的练习是专注的<ul><li>要想取得进步，必须把注意力完全集中在你的任务上</li></ul></li><li>有目的的练习包含反馈<ul><li>无论做什么事情，都需要反馈来准确辨别你在哪些方面还有不足，以及怎么会存在这些不足</li></ul></li><li>有目的的练习需要走出舒适区<ul><li>无法从舒适区走出，就永远无法进步</li><li>遇到瓶颈怎么办？<ul><li>试着做不同的事情，而非更难得事情<ul><li>不管什么障碍，越过它最好得办法是从不同方向去想办法</li></ul></li><li>并非达到极限，而是动机不足<ul><li>有意义的正面反馈是保持动机的关键要素之一</li></ul></li></ul></li></ul></li></ul><p>除了目的的练习还需要什么？</p><ul><li>专注的练习和走出舒适区，逼迫自己超越极限，但这还不够，这忽略了练习和训练方法中的其他一些同等重要的方面。对特定的练习和训练方法进行研究后，证明了“刻意练习“是提高人们在个人领域和行业中的能力，最强大和最有效的方法</li></ul><h3 id="大脑的适应能力"><a href="#大脑的适应能力" class="headerlink" title="大脑的适应能力"></a>大脑的适应能力</h3><p>大脑的结构与运行都会为了应对各种不同的心理训练而改变，很大程度上像你的肌肉和心血管系统响应体育锻炼那样</p><p>大脑拥有无限的适应能力</p><p>如果你足够多地练习做某件事情，你的大脑会改变某些神经元的用途，以帮助完成任务</p><p>通过研究发现：大脑的结构和功能并不是固定不变的，它们会根据你对它们的运用而改变。因此，通过清醒的、刻意的练习，以我们期望的方式来塑造大脑，包括你的大脑，我的大脑，以及任何人的大脑都是可能的</p><p>走出舒适区的必要性：</p><ul><li>身体偏爱稳定性：身体偏爱稳定性（体内平衡），单个细胞喜欢稳定性。反馈机制-&gt;身体维持现状</li><li>被迫走出舒适区后，身体原来的体内平衡无法再继续保持下去，身体便开始响应那些变化，目的是在身体内建立新的体内平衡</li><li>挑战越大，变化越大，但不要太过。补偿是不断发生的，一下子推得太猛，使自己远离了舒适区，就有可能受伤</li></ul><p>规律：经常性得训练会使得大脑中受到训练挑战得区域发生改变，大脑通过自身重新布线的当时来适应这些挑战，增强其执行那些挑战所需要的能力</p><ul><li>年轻人的大脑更具适应能力。折弯幼枝效应</li><li>超长时间来训练大脑中的某些部位，可能得付出一些代价</li><li>训练引起的认知和生理变化需要继续保持。如果停止训练，它们便开始消失</li></ul><p>以上可以得出结论：人类的潜能是可以构建的</p><ul><li>挑战体内平衡，走出舒适区，迫使你的大脑和身体来适应</li></ul><h3 id="心理表征"><a href="#心理表征" class="headerlink" title="心理表征"></a>心理表征</h3><p>心理表征是一种与我们大脑正在思考的某个物体，某个观点，某些信息或者其他事物相对应的心理结构，或具体或抽象</p><p>大多数的刻意练习包括创建更加有效的心理表征</p><ul><li>心理表征存在行业特异性，不同行业的心理表征存在巨大差异</li><li>相同的点：保存在记忆当中，可以用于有效地顺应某些类型的局面</li></ul><p>将杰出人物和其他人区别开来的因素，正式前者心理表征的质量和数量</p><p>经过年复一年的练习，已经改变了大脑中的神经回路，以创建高度专业化的心理表征，这些心理表征反过来使得令人置信的记忆、规律的识别、问题的解决等成为可能，也使得他们能够培养和发展各种高级的能力，以便于在特定的专业领域中表现卓越</p><p>心理表征的作用</p><ul><li>有助于找出规律<ul><li>预测未来</li><li>无意识决策</li></ul></li><li>有助于解释信息</li><li>有助于组织信息</li><li>有助于制定计划</li><li>有助于高效学习</li></ul><h3 id="黄金标准：刻意练习"><a href="#黄金标准：刻意练习" class="headerlink" title="黄金标准：刻意练习"></a>黄金标准：刻意练习</h3><p>刻意练习是什么？</p><ul><li>刻意练习的技能，是其他人已经想出怎么提高的技能，也是已经拥有一套行之有效的训练方法的技能。</li><li>刻意练习发生在人们的舒适区外，而且要求学生持续不断地尝试那些刚刚超出他们当前能力范围的事物</li><li>刻意练习包含得到良好定义的特定目标，通常还包括目标表现的某些方面</li><li>刻意练习是有意而为的，需要人们完全的关注和有意识的行动</li><li>刻意练习包含反馈，以及应对那些反馈而进行调整的努力</li><li>刻意练习即产生有效的心理表征，有依靠有效的心理表征</li><li>刻意练习通过着重关注过去获取的技能的某些特定方面，致力于有针对性地提高那些方面</li></ul><p>如何运用刻意练习？</p><ul><li>确定杰出人物</li><li>找出杰出人物和其他人物的区别</li><li>提出训练方法（找到一位优秀的导师）</li></ul><p>一万小时的对与错</p><ul><li>错：一万小时-&gt;行业杰出，并没有发现二者之间必然的因果定律</li><li>对：任何一个有着悠久历史的行业和领域，要想要成就一番事业，致力于变成业内的杰出人物，需要付出许多年艰苦卓绝的努力</li></ul><h3 id="在工作中运用刻意练习原则"><a href="#在工作中运用刻意练习原则" class="headerlink" title="在工作中运用刻意练习原则"></a>在工作中运用刻意练习原则</h3><p>让练习成为工作的一部分</p><p>三种错误思想：</p><ul><li>认为某人的能力通常收到基因特征的限制</li><li>如果你足够长时间地做某件事情，一定会更擅长</li><li>要想提高，只需要努力，足够刻苦，你会更加优秀</li></ul><p>致力于改进计划，着重实干，而不是知晓</p><h3 id="在生活中运用刻意练习原则"><a href="#在生活中运用刻意练习原则" class="headerlink" title="在生活中运用刻意练习原则"></a>在生活中运用刻意练习原则</h3><p>找一位好导师，帮你创建心理特征，以便你能够监测和纠正你自己的表现</p><p>专注和投入，即有意地提升和精进你的技能，是提高训练效果的最强大的方式</p><ul><li>制定明确的目标，把练习课程的时间缩得很短，是更加迅速地提升新的技能水平的最佳方式</li></ul><p>如果没有导师怎么办？</p><ul><li>自己设计练习方法。反复做一件事情，目的是找出你在哪些方面存在不足，并且聚焦在哪些方面可以取得进步，试着采用不同的方法来提高，直到你最终找到适合自己的办法</li><li>用三个F创建有效的心理特征：将技能分解成一些组成部分，以便于反复练习，并且有效地分析、确定你的不足之处，然后想出各种办法来解决它们<ul><li>专注 focus</li><li>反馈 feedback</li><li>纠正 fix it</li></ul></li></ul><p>跨越停滞阶段：想办法逼自己一下，但不要逼得太狠，这通常会帮你搞清楚自己的停滞点在什么地方。设计一种练习方法，专门用来改进那个特定的弱点</p><p>保持动机</p><p>有目的的练习是一项艰巨的任务。它难以坚持下去，即使你仍然在坚持练习，但你难以保持专注和努力。因此，到最后你不再能推动自己前进，而且不再进步</p><p>如何保持动机？</p><ul><li>靠意志力保持动机是不靠谱的</li><li>弱化停下脚步的理由<ul><li>最有效的一种是留出固定的时间来练习，不受所有其他义务和分心事情所干扰</li></ul></li><li>增强继续前行的动力<ul><li>一旦你已经练习了一段时间，并且可以看到结果了，这种技能本身就可以成为你动机的一部分</li><li>当你不再相信自己可以实现某个目标时，千万不要半途而废，和你自己达成一个协议，你将尽可能进自己的努力回归到之前的状态或者跨越停滞阶段，然后你再放弃，到那个时候，也许你就不会放弃了</li><li>一种营造和保持社会动机的最好办法，是使你自己身边的人们都鼓支持和挑战你的努力</li><li>将对同一件事情感兴趣的所有人聚集起来，或者吸引他们加入一个现有的团体，并且将团体的同志情谊和共同的目标作为达到自己目标的额外动机</li><li>精心设置目标，将漫长旅途分解成一系列可控的目标，并且每次只关注它们中的一个，甚至可以再每次达到目标时，给自己一个小小的奖励</li></ul></li></ul><h3 id="成为杰出人物的路线图"><a href="#成为杰出人物的路线图" class="headerlink" title="成为杰出人物的路线图"></a>成为杰出人物的路线图</h3><p>1.产生兴趣</p><p>到了他们成长的某个时刻，他们对某一特定领域行业格外感兴趣，并且表现得比其他同龄孩子更有希望成就一番事业</p><p>2.变得认真</p><p>只有花了数年时间苦练某项技能的人吗，才会自然而然地喜欢上那一技能，但也可能正式因为这种练习本身引出人们心理上的适应，从而产生了更多的愉悦和更强的动机从事那项特定的活动</p><p>3.全力投入</p><p>4.开拓创新</p><h3 id="怎么解释天生才华"><a href="#怎么解释天生才华" class="headerlink" title="怎么解释天生才华"></a>怎么解释天生才华</h3><p>杰出能力是大量练习与培训的结果</p><p>练习是决定某人在某个特定领域或行业中最终成就的唯一最重要因素，如果基因在其中发挥作用，那么他们的作用会慢慢消失</p><h3 id="用刻意练习创造全新的世界"><a href="#用刻意练习创造全新的世界" class="headerlink" title="用刻意练习创造全新的世界"></a>用刻意练习创造全新的世界</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>底层逻辑</title>
      <link href="/2022/05/22/di-ceng-luo-ji/"/>
      <url>/2022/05/22/di-ceng-luo-ji/</url>
      
        <content type="html"><![CDATA[<p>作者：刘润</p><p>出版年：2021-10</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/dicengluoji.jpg" style="zoom: 67%;"/><p>个人评价：整本书有很多让人耳目一新的名词定义、观点和看法，很值得参考和学习。不好的地方是整本书的行文逻辑较为混乱，适合公众号一篇一篇的发文，但称不上是一本好书</p><h3 id="是非对错"><a href="#是非对错" class="headerlink" title="是非对错"></a>是非对错</h3><h4 id="三种对错观"><a href="#三种对错观" class="headerlink" title="三种对错观"></a>三种对错观</h4><ul><li>法学家的对错观：评论家，谁证据确凿谁的错</li><li>经济学家的对错观：政策制定者，谁社会总成本低谁的错</li><li>商人的对错观：真实人生，谁损失大谁的错</li></ul><p>一件事情出现不好的结果时，责怪、埋怨、后悔都是无用的，它们改变不了结果。如果自己有所损失，只能怪自己，也只有自己才能改变事情最终的结果——靠自己，自强者万强</p><h4 id="人性道德和法律"><a href="#人性道德和法律" class="headerlink" title="人性道德和法律"></a>人性道德和法律</h4><ul><li>人性：生存和繁衍的诉求</li><li>道德：为了群体的繁荣，最后促进个体的生存、繁衍，大家共同达成的社会契约</li><li>法律：维护群体存在的道德底线</li></ul><h4 id="人生的三层智慧：博弈、定力、选择"><a href="#人生的三层智慧：博弈、定力、选择" class="headerlink" title="人生的三层智慧：博弈、定力、选择"></a>人生的三层智慧：博弈、定力、选择</h4><ul><li>博弈：心态和策略。心态：共赢和感激；策略：以牙还牙，以眼还眼</li><li>定力：长期主义</li><li>选择：勇于选择，勇于放弃</li></ul><h4 id="公理体系VS逻辑推演"><a href="#公理体系VS逻辑推演" class="headerlink" title="公理体系VS逻辑推演"></a>公理体系VS逻辑推演</h4><ul><li>公理体系：严谨证明，不是对则是错</li><li>逻辑推演：观点与模型<ul><li>学习不同的观点与模型</li><li>意识到每个模型都是不完美的，但并不意味着模型是错的</li><li>理论与模型的成立，有前提</li></ul></li></ul><p>这一章节的个人感觉是逻辑性欠缺，抽象出来了一堆概念名词，这些概念名词如何去指导人去判断对错的缺乏严密的逻辑性</p><h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><h4 id="事实、观点、立场和信仰"><a href="#事实、观点、立场和信仰" class="headerlink" title="事实、观点、立场和信仰"></a>事实、观点、立场和信仰</h4><ul><li>事实：独立于人的判断客观存在</li><li>观点：对事实的看法</li><li>立场：被位置和礼仪影响的观点</li><li>信仰：内部完全自洽的逻辑体系</li></ul><p>当一个人持有的不是观点而是立场时，当一个屁股决定脑袋时，你应该要做的事情，是对他说“It is good for you”</p><p>反过来，我们也要时刻反省自己：我说的话、我的表述，是事实，是观点，是立场，还是信仰</p><h4 id="如何防止注射式洗脑"><a href="#如何防止注射式洗脑" class="headerlink" title="如何防止注射式洗脑"></a>如何防止注射式洗脑</h4><p>为什么+观点 这样一句句子，会让人本能地给观点找原因，而忽视掉观点本身的正确与否，即将观点注射进了大脑</p><p>狡猾的人，用这个局式注射别人。愚蠢的人，却用这个句式注射自己</p><h4 id="如何赢得一场辩论"><a href="#如何赢得一场辩论" class="headerlink" title="如何赢得一场辩论"></a>如何赢得一场辩论</h4><p>辩论的目的：说服观众，改变观众的态度</p><p>辩论的关键：不断表达自己的观点。偷换概念（重新定义概念，纠正对方的概念）</p><p>辩论的核心竞争力：基于逻辑的急智</p><p>如何赢得一场辩论</p><ul><li>what：核心竞争力，瞬间反应的智慧</li><li>how：怎么辩论，纠正对方的概念</li><li>why：为什么辩论，说服观众</li></ul><h4 id="解决问题的方式"><a href="#解决问题的方式" class="headerlink" title="解决问题的方式"></a>解决问题的方式</h4><p>1.抛弃经验，放弃想当然，不要轻易下结论，要怀着空杯心态去看问题</p><p>2.假设-验证-结论-调整：提出一个假设，为了印证假设，而不辞辛苦、不嫌麻烦地去验证假设，然后得出结论，最后做出调整</p><p>3.就事论事，不要被利益、立场左右</p><h4 id="如何快速洞察本质"><a href="#如何快速洞察本质" class="headerlink" title="如何快速洞察本质"></a>如何快速洞察本质</h4><p>透过表象看系统</p><ul><li>给事务一个刺激，它会产生相应的行为，这是表象。拨动表盘，机械手表开始转动</li><li>表象为什么手表会动，背后有一套黑盒子，这是系统</li></ul><p>系统=要素*连接关系</p><ul><li>要素：变量：存量（某一个静止的时间点，存在多少）+流量（动态的时间段，有多少流入（流入量），有多少流出（流出量））</li><li>连接关系：<ul><li>因果链：A+ 造成 B+</li><li>增强回路：A+造成B+，B+进一步造成A+</li><li>调节回路：A+造成B+，B+造成A-</li><li>滞后效应：A+，等待一段时间后A+</li></ul></li></ul><p>如何分析问题</p><ul><li>找到核心变量</li><li>找到关键因果链</li><li>找到增强回路</li><li>找到调节回路</li><li>考虑滞后效应</li></ul><h4 id="流程、制度与系统"><a href="#流程、制度与系统" class="headerlink" title="流程、制度与系统"></a>流程、制度与系统</h4><p>流程：基于时间线做完一件事的整个过程。流程是线性的、连贯的、客观的</p><p>制度：做一件事的行为准则</p><p>系统：若干部分相互联系，相互作用形成的具有某个功能的整体</p><p>改变流程，制度：管理</p><p>改变制度：治理</p><h4 id="逻辑思维与逻辑闭环"><a href="#逻辑思维与逻辑闭环" class="headerlink" title="逻辑思维与逻辑闭环"></a>逻辑思维与逻辑闭环</h4><p>what：看起来是这样，事情表象</p><p>why：为什么会这样，找根本解</p><p>how：以前怎样，追本溯源</p><p>what：还有什么这样，举一反三</p><p>逻辑素养</p><ul><li>证有不证无</li><li>以偏不概全</li><li>证有靠举例</li><li>概全靠推理</li></ul><h4 id="复利思维"><a href="#复利思维" class="headerlink" title="复利思维"></a>复利思维</h4><p>高看了指数，本金和收益率跟重要</p><h4 id="概率思维"><a href="#概率思维" class="headerlink" title="概率思维"></a>概率思维</h4><p>不完全信息决策，算EV</p><p>提高概率：时代、战略、治理管理</p><h4 id="数学思维"><a href="#数学思维" class="headerlink" title="数学思维"></a>数学思维</h4><ul><li><p>从不确定中找到确定性：正确的事情重复做</p></li><li><p>动态的眼光看问题：一件事情的结果，并不是瞬间产生的，而是长期以来的积累效应造成的。出了问题，不要只看当时的那个瞬间，你只有从宏观一直追溯到微观，才能找到问题的根源所在</p></li><li><p>公理体系：定义几个公理，整个体系基于公理推到出来。使命、愿景、价值观-&gt;公司的发展制度、工作流程、决策方式</p></li><li><p>数学的方向性：同方向是合力，不同方向互相阻碍</p></li><li><p>全局最优和达成共赢：信任-&gt;共赢</p></li></ul><h4 id="系统思维"><a href="#系统思维" class="headerlink" title="系统思维"></a>系统思维</h4><p>商业模式就是利益相关者的交易结构</p><h3 id="个体进化"><a href="#个体进化" class="headerlink" title="个体进化"></a>个体进化</h3><h4 id="人生商业模式-能力-效率-amp-杠杆"><a href="#人生商业模式-能力-效率-amp-杠杆" class="headerlink" title="人生商业模式=能力*效率&amp;杠杆"></a>人生商业模式=能力*效率&amp;杠杆</h4><p>能力</p><ul><li><p>最重要的能力，获得能力的能力</p></li><li><p>具象化：怎么用2年时间获得别人5年的能力</p></li><li><p>答案：加班（勤奋）</p><ul><li>个人评论：个人觉得作者这里表达欠妥。这里想要表述的应该是“用时间换取自我提升”，个人的勤奋的并不代表加班的工作，而是把时间花在提升自己上面，如果加班是提升自己的最好方式，那么加班是一个选项；但如果加班仅仅只是加班，用时间换金钱，这并不是勤奋</li></ul></li><li><p>高效的勤奋</p><ul><li>刻意练习：通过不断重复训练稍微困难的任务，从而获得最高效的进步</li></ul></li></ul><p>效率</p><ul><li>选择：选择做最有价值的事情</li><li>方法：正确的方法做正确的事情</li><li>工具：使用能够提升效率的工具</li></ul><p>杠杆</p><p>杠杆的作用：复制、放大</p><p>个人评论：作者的表达略偏向于口语表达、演讲，在抽象总结上面远远不够，也许观点是好的，但称不上是一个好的作者</p><ul><li>团队杠杆：沉淀坚实可复制的知识内核、赋能团队成员</li><li>产品杠杆：做提高的人类生产力，节省人类时间的产品</li><li>资本杠杆：通过资本放大效应</li><li>影响力杠杆：人脉不是那些能够帮助你的人，而是那些你能够帮助到的人</li></ul><h4 id="正确的工作"><a href="#正确的工作" class="headerlink" title="正确的工作"></a>正确的工作</h4><p>态度：把工作当作玩，工作是创造而不是消耗</p><p>个人评论：前提是热爱你现在的工作。如果你不热爱现在的工作，要么勇于换一份工作，要么尝试爱上现在的工作</p><h4 id="如何做好时间管理"><a href="#如何做好时间管理" class="headerlink" title="如何做好时间管理"></a>如何做好时间管理</h4><p>时间颗粒度</p><p>年</p><ul><li>职业、生活目标</li><li>强项弱项</li><li>活动</li></ul><p>天</p><ul><li>睡觉和工作之外的8小时体现出人的差距</li></ul><p>小时</p><ul><li>专著做事，避免上下文切换到来的时间损耗</li></ul><p>时间管理当作习惯</p><h4 id="指数级增长、正态分布和幂律分布"><a href="#指数级增长、正态分布和幂律分布" class="headerlink" title="指数级增长、正态分布和幂律分布"></a>指数级增长、正态分布和幂律分布</h4><p>边际交付时间：每提供一项服务或一个产品所增加的交付时间</p><p>边际交付时间低：收入水平越偏向于幂律分布，头部占有大部分市场份额。只有这种情况，商业上才有可能获得指数级增长</p><p>边际交付时间高：收入水平越偏向与正态分布，大部人处于中部</p><h4 id="做正确事"><a href="#做正确事" class="headerlink" title="做正确事"></a>做正确事</h4><h4 id="人脉的本质是给予价值、平等交换"><a href="#人脉的本质是给予价值、平等交换" class="headerlink" title="人脉的本质是给予价值、平等交换"></a>人脉的本质是给予价值、平等交换</h4><p>经验人模的基本心态：毫无保地把你的价值付诸在别人身上</p><p>你能帮助到的人，才是你的人脉。不断积累自己的价值，并不断输出自己的价值</p><h4 id="知识、技能与态度"><a href="#知识、技能与态度" class="headerlink" title="知识、技能与态度"></a>知识、技能与态度</h4><p>知识</p><ul><li>已经发现和证明的规律，不需要自身经历去验证的</li><li>学习知识：记忆</li><li>知识具有有效期和适用场景，知识需要不断学习更新</li><li>不要把知识当作技能学</li></ul><p>技能</p><ul><li>需要实践去验证的知识。骑车、如何演讲等</li><li>不要把技能当作知识学</li></ul><p>态度</p><ul><li>选择用来看世界的隐形眼镜</li><li>用心学习态度</li></ul><h4 id="心态放高，姿态摆低"><a href="#心态放高，姿态摆低" class="headerlink" title="心态放高，姿态摆低"></a>心态放高，姿态摆低</h4><p>自、示弱、看淡</p><h4 id="做自己的CEO"><a href="#做自己的CEO" class="headerlink" title="做自己的CEO"></a>做自己的CEO</h4><p>与企业本质上是合伙关系</p><ul><li>工资：支付给责任</li><li>奖金：支付给超额业绩</li><li>股权：支付给未来潜力</li><li>价值观：支付给梦想</li></ul><h4 id="做艺术家"><a href="#做艺术家" class="headerlink" title="做艺术家"></a>做艺术家</h4><p>人体的DNA机制：做有利于生存、有利于繁衍的事情，人体就会按量分泌出一些令你愉悦的化学物质，作为奖励。不做就会分泌出另一种化学物质，让你痛苦</p><p>艺术让人类不再受制于DNA，带来自由</p><h3 id="理解他人"><a href="#理解他人" class="headerlink" title="理解他人"></a>理解他人</h3><h4 id="what、why、how与知行合一"><a href="#what、why、how与知行合一" class="headerlink" title="what、why、how与知行合一"></a>what、why、how与知行合一</h4><p>what：要做什么？ why：为什么要做？ how：怎么做？</p><p>有what，缺why就没动力，没how，就是鸡汤，纸上谈兵</p><h4 id="关于幽默"><a href="#关于幽默" class="headerlink" title="关于幽默"></a>关于幽默</h4><p>幽默的三种理论</p><ul><li>优越感理论：通过创作一个失败者，让别人感觉自己是成功者，从而产生心满意足的优越感</li><li>错愕感理论：两条逻辑线交叉的地方突然来一个脑筋急转弯</li><li>释放感理论：用危险制造紧张感，再用安全释放掉</li></ul><p>幽默感的前提是智慧，幽默感是溢出的智慧</p><h4 id="关于洞察"><a href="#关于洞察" class="headerlink" title="关于洞察"></a>关于洞察</h4><h4 id="关于边界感"><a href="#关于边界感" class="headerlink" title="关于边界感"></a>关于边界感</h4><p>边界感的本质，是对所有权的认知。你要知道，什么是他的，什么你的，你在你的范围内做事，他在他的范围内做事，如果要跨越边界，就需要先征求对方的同意</p><h4 id="创业与多巴胺"><a href="#创业与多巴胺" class="headerlink" title="创业与多巴胺"></a>创业与多巴胺</h4><p>获得快乐的方式有三种</p><ul><li>通过目的性很强的多巴胺，去找事情做，比如完成艰难的工作（比较优势，奖励机制表）</li><li>通过长时间持续锻炼去刺激分泌内啡肽</li><li>刺激分泌能让大脑觉得单纯快乐的血清素</li></ul><h3 id="社会协作"><a href="#社会协作" class="headerlink" title="社会协作"></a>社会协作</h3><h4 id="世界法则"><a href="#世界法则" class="headerlink" title="世界法则"></a>世界法则</h4><ul><li>自然法则：物竞天择，适者生存。个体优势，强壮/智慧</li><li>族群法则：为了一个更大的目标，大家牺牲了一部分人的利益，用群体的强大，保护个体的弱小</li><li>普遍法则：跨越组织和个人，所有人都理解和认同的东西</li></ul><h4 id="利用自己的战略势能"><a href="#利用自己的战略势能" class="headerlink" title="利用自己的战略势能"></a>利用自己的战略势能</h4><p>商业模式创造势能</p><p>科技创造势能</p><h4 id="什么决定产品价格"><a href="#什么决定产品价格" class="headerlink" title="什么决定产品价格"></a>什么决定产品价格</h4><p>消费者所能够感知到的价值决定价格</p><ul><li>功能价值：性价比、规模效应降低成本，技术优势降低成本</li><li>体验价值：用户视角</li><li>个性化价值：私人定制</li></ul><h4 id="利润的来源"><a href="#利润的来源" class="headerlink" title="利润的来源"></a>利润的来源</h4><p>趋势红利、社会工资、创新利润</p><h4 id="没有KPI，如何管理公司"><a href="#没有KPI，如何管理公司" class="headerlink" title="没有KPI，如何管理公司"></a>没有KPI，如何管理公司</h4><p>创造性的工作，自驱力</p><h4 id="让优秀员工成为事业合伙人"><a href="#让优秀员工成为事业合伙人" class="headerlink" title="让优秀员工成为事业合伙人"></a>让优秀员工成为事业合伙人</h4><ul><li><p>利益共同体：有钱大家一起分。共同的短期利益</p></li><li><p>事业共同体：牺牲短期价值，来获取可能有风险的，但是长期的，更大的回报。共同的长期利益</p></li><li><p>命运共同体：有共同不能失去的东西</p></li></ul><h4 id="财富的本质"><a href="#财富的本质" class="headerlink" title="财富的本质"></a>财富的本质</h4><p>财富=劳动 * 生产率 * 效用</p><ul><li><p>劳动 = 时间</p></li><li><p>生产率 = 杠杆，知识、工具、团队、资金等</p></li><li><p>效用 = 劳动能创造的单位价值</p></li></ul><p>劳动创造财富：边际效应递减问题</p><p>稀缺性决定价值</p><h4 id="优先劣后"><a href="#优先劣后" class="headerlink" title="优先劣后"></a>优先劣后</h4><h4 id="信用"><a href="#信用" class="headerlink" title="信用"></a>信用</h4><h4 id="公平、公正和公开"><a href="#公平、公正和公开" class="headerlink" title="公平、公正和公开"></a>公平、公正和公开</h4><ul><li>公平：一把尺子丈量万物</li><li>公正：用哪一把尺子来丈量</li><li>公开：把丈量的过程展示给公众，让同意公正者监管公平</li></ul><h4 id="效率与公平"><a href="#效率与公平" class="headerlink" title="效率与公平"></a>效率与公平</h4><p>初次分配负责效率、再分配负责公平</p><h4 id="服从性测试"><a href="#服从性测试" class="headerlink" title="服从性测试"></a>服从性测试</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气</title>
      <link href="/2022/05/21/bei-tao-yan-de-yong-qi/"/>
      <url>/2022/05/21/bei-tao-yan-de-yong-qi/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/beitaoyandeyongqi.jpg" style="zoom:60%;" /><p>作者：岸见一郎&amp;古贺史健</p><p>出版年：2015-3</p><p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/beitaoyandeyongqi3.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我读王小波</title>
      <link href="/2022/05/20/wo-du-wang-xiao-bo/"/>
      <url>/2022/05/20/wo-du-wang-xiao-bo/</url>
      
        <content type="html"><![CDATA[<p>工作这几年读过不少作家的书，但对王小波的感情最深。也许是因为跟王小波有一些共同特点，他去世的那一年是我出生的那一年，他做过程序员我现在是程序员，他有一张丑脸我也不帅，所以想先简单写一些从王小波身上读到的一些东西。</p><p>真诚生活。王小波在三十而立中写到 “在我看来，春天里一颗小草生长，它没有什么目的。风起时一匹公马发情，它也没有什么目的。草长马发情，绝非表演给什么人看的，这就是存在本身。我要抱着草长马发情的伟大真诚去做一切事，而不是在人面前羞羞答答的表演。在我看来，人都是为了要表演，失去了自己的存在”。 生活需要真诚，更多的关注自我，不需要在意他人的看法，不需要为了迎合他人去改变自己，而是为了成为更好的自己而改变。这也和被讨厌的勇气一书中提到的“本我”类似，人到底能不能得到幸福，问题不在于世界是什么样子，而在于你是什么样子。</p><p>追寻有趣。王小波在红拂夜奔中写到“对我来说，只有满足了两个条件的事我才干：首先是无害，其次是有趣”。一个人活着就是为了吃饭，这是无趣的，生活只有房子、车子、票子，这也是顶顶无趣的，比起乞丐来，这是光鲜的无趣。一个人只向往远方未必有趣，但是一个人从来没有什么诗意的向往，必然无趣。王小波的有趣，不仅仅在他小说中的奇思妙想和诙谐幽默的文笔，更多的是他对生活的态度，不喜欢无聊，不喜欢低级趣味，就像他写到的 “一个人只拥有此生此世是不够的，他还应该拥有诗意的世界”。王小波文字中透露出的气息，是对社会现实把一个人磨砺成简单而无趣的厌恶。</p><p>保持理性。王小波在沉默的大多数这本杂文集的序中写到 “我这辈子我干什么都可以，就是不能做一个一无所能就能明辨是非的人。因为这个缘故，我成了沉默的大多数的一员。我年轻时所见的人，只掌握了一些粗浅（且不说是荒谬）的原则，就以为无所不知，对世界妄加判断，结构整个世界都深受其害……无论如何，萧翁的这些议论，对那些浅薄之辈、狂妄之辈，总是一种解毒剂”。王小波有着理性有着很深的文革时代烙印，但却深深适用于当今这个二元对立观点盛行的时代。所谓的理性，一方面是指自己的灵魂独立，精神自由，另一方面是指人与人之间的尊重与宽容，世界是多元的，真理也无法灌输，不能强迫别人接受你自以为是的东西，反之亦然。</p><p>浪漫骑士，行吟诗人，自由思想者 —— 王小波。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我与阅读</title>
      <link href="/2022/05/20/wo-yu-yue-du/"/>
      <url>/2022/05/20/wo-yu-yue-du/</url>
      
        <content type="html"><![CDATA[<p>小时候一家人出去遛弯，路过了一家书店。书店刚开业，三十元办一张会员卡作为押金，就可以可以同时租借三本书，每本书一天收费一毛钱，很实惠，便办了一张。那时候还在上小学，寒暑假是没有折扣的一段长假，那时候智能手机和网络没有普及，娱乐活动主要就是电视，这么长一段时间电视看多了也会无聊。实在太过无聊，便想着从书店租一些小人书看打发打发时间，最开始是图画书，像西游记这些，后来开始接触到一些儿童小说，然后就陷进去了，把郑渊洁、杨红樱写的能在书店找到书都读了一遍。小时候有用不完的时间，这些时间用来构建出了一个美好的童话世界。</p><p>初中开始经历青春期，开始爱上一些青春疼痛文学。作者像郭敬明、落落，杂志像花火，最爱的小说像郭敬明的夏至未至，那时候还写过一些关于立夏的同人文。后来染上了一坏习惯，作文不管是什么主题，都会变成用华丽辞藻堆砌而成的自我感动式的抒情文章。再晚一点，龙族、盗墓笔记、鬼吹灯等小说开始风靡，开始深入了解什么叫小说世界观和情节。随之陷入了网络小说的大坑，长达若干年，基本上比较有名的网络小说全都读过，这些小说很多已经被改编成了动漫。那时候看书没什么目的，仅仅就是为了消遣，在紧张的学习生活中寻找一点慰藉。</p><p>上大学后可以做的事情太多太多，几乎就没怎么拿起书，也没怎么去过读书馆，偶尔看书也是闲得太过无聊时从室友那借来一两本小说打发时间。记得室友买了一些乔治·奥威尔的小说，像1984、动物庄园，也没认真读，当时仅仅觉得：嗯，情节还不错，也就过去了。大学是自由的，是幸福的，象牙塔内不需要考虑太多，一切都很顺利。</p><p>毕业后工作，认识到自身的局限性，才真正开始有了一些思考。工作有什么价值？生活怎么更有意义？人生的方向怎么选？于是，偶然却具有必然性地开始从书籍里面，从前人的经历和思考里面寻找一些答案。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>青铜时代</title>
      <link href="/2022/05/07/qing-tong-shi-dai/"/>
      <url>/2022/05/07/qing-tong-shi-dai/</url>
      
        <content type="html"><![CDATA[<p>作者：王小波</p><p>出版年：1997-7</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/qtsd.jpg" style="zoom:100%;" /><ul><li>对于眼前这座灰蒙蒙的城市，我的看法是：我既可以生活在这里，也可以生活在别处；可以生活在眼前这座水泥城里，走在水泥的大道上，呼吸着雾霾；也可以生活在一座石头城里，走在一条龟背似的石头大街上，呼吸着路边的紫丁香。在我眼前的，既可以是这层白内障似的，磨砂灯泡似的空气，也可以是黑色透明的、像鬼火一样流动着的空气。人可以迈开脚走路，也可以乘风而去</li></ul><ul><li>此时寂寞不再像一种暧昧的癫狂，而是变成了体内的刺痛</li></ul><ul><li>假如我不曾失掉记忆，就不能取得这个胜利，也不能得到这个快乐—所以，失掉记忆也不全是坏事。总想着自己丧失了记忆，才全是坏事</li></ul><ul><li>所谓努力，就是忘掉自己在干什么，只顾去做</li></ul><ul><li>她喜欢这种区别，假如没有区别，生活也就没意思</li></ul><ul><li>这种小说总有一个迷，而这个谜就是我自己。这个故事会把我带到一个地方，但我还不知道那是哪里</li></ul><ul><li>一个人有拥有此生此世是不够的，他还应该拥有诗意的世界</li></ul><ul><li>人和自己客气未免太虚伪</li></ul><ul><li>在这个绿叶与红土相间的地方，岁月像流水一样过去，转眼之间就到了生命的黄昏</li></ul><ul><li>在他狭隘的内心里，容不下一点诗意</li></ul><ul><li>长安城里的一切已然结束，一切都在无可挽回地走向庸俗</li></ul><ul><li>假如你不走到墙外面来，就永远不会知道有这样一些景象。假如你不走出这道墙，就会以为整个世界是一个石头花园，而且一生都在石头花园里度过</li></ul><ul><li>作为中国人，不但必须证明自己聪明的智慧，还得证明自己傻的智慧，否则后患无穷</li></ul><ul><li>李卫公就是这样用尽心机，其目的就是一个人清清静静地去喝一会酒</li></ul><ul><li>年轻人和老人的区别就在这里吧，人在年轻时充满了做事的冲动，无休无止地变革一切，等到这些冲动骤然消失，他就老了</li></ul><ul><li>这一切都沉浸在墨一样的黑暗中。这样的死亡和一个无性、无智、无趣的人生相比，也不知哪个更可怕</li></ul><ul><li>到目前为止，没有一件事能让我相信我是对的，就是人生来有趣，过去有趣，渴望有趣，内心有趣却假装无趣。也没有一件事情能证明我是错的，让我相信人生来无趣，过去无趣现在也无趣，不喜欢有趣的事而且表里如一。所以到目前为止，我只能强忍着活在这世上</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>白银时代</title>
      <link href="/2022/04/12/bai-yin-shi-dai/"/>
      <url>/2022/04/12/bai-yin-shi-dai/</url>
      
        <content type="html"><![CDATA[<p>作者：王小波</p><p>出版年：1997-08</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/baiyinshidai.jpg" style="zoom:120%;" /><ul><li>既然我醒着，就不用把我叫醒了– 我一直在老师的阴影中生活，并且总是要回答那句谜语：世界是银子的</li></ul><ul><li>人不该发愣，除非他想招人注目。但让我不发楞又不可能</li></ul><ul><li>没人能教别人写作，我也不能教别人写作</li></ul><ul><li>生活是天籁，必须凝神静听</li></ul><ul><li>对不相信的事情说不在意：这就是我保全体面的方法</li></ul><ul><li>我们总是在枪毙一切有趣的东西。这是因为越是有趣的东西，就越是包含着恶毒的寓意</li></ul><ul><li>在此之前，我是把她平端着的–我觉得把她举得与肩平高显得尊重，但尊重久了，难免要抽筋</li></ul><ul><li>什么是生活，什么不是生活，我说了不算：这就是说，我不知道什么叫做生活</li></ul><ul><li>这种藤萝可以蔓延数千里，人也可以终生走不出藤萝架，这样就会一生都住在一道绿色的走廊里，这未尝不是一种幸福。这不是不能实现的事：只要把人的基因植到蚂蚁里，他(或者她)觉得自己是人，其实只是蚂蚁；此后就可以在一个盆景里面得到这种幸福，世界也会因此变得越来越新奇</li></ul><ul><li>你知道什么是天才的诀窍吗？ 那就是永远只做一件事</li></ul><ul><li>实际上，生活就是你不太乐意它发生但却发生了的事，和真实不真实没有关系</li></ul><ul><li>有种文艺理论认为，作品应该源于生活，高于生活，但我认为，起码现实生活中的大多数场景是不配被写入小说里的。所以，想象比摹写生活更可取</li></ul><ul><li>在中国，以三十年为极限，我们不可能知道三十年以前的事</li></ul><ul><li>其实，在这个意义上，生命非常短暂，有的人活到了三十岁，有人活到了四十岁，有的人根本没活过。我们知道，海明威在六十岁感到自己丧失了创造力，就用猎枪把脑子轰掉。川端康成在七十岁发现自己没有了创造力，就叼上了煤气管。实际上， 从丧失了创造力到自己察觉到，还要很长一段时间。他们二位实际死掉的时间要早得多</li></ul><ul><li>我现在发现，不论是羞愧、惊恐还是难堪，都只是一瞬间的感觉，过去就好了。由此推导出，就是死亡，也不过是瞬间的惊恐，真正死掉以后，一定还是很舒服的</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黄金时代</title>
      <link href="/2022/03/27/huang-jin-shi-dai/"/>
      <url>/2022/03/27/huang-jin-shi-dai/</url>
      
        <content type="html"><![CDATA[<p>作者：王小波</p><p>出版年：2021-08</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/huangjinshidai.jpg" style="zoom:30%;" /><ul><li>那一年我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤得牛一样。可是我过二十岁生日时没有预见到这一点，我觉得自己会永远生猛下去，什么也锤不了我</li></ul><ul><li>陈清扬后来说，她始终没搞明白我那个伟大友谊是真的呢，还是临时编出来骗她。但是她又说，那些话就像咒语一样让她着迷，哪怕为此丧失一切，也不懊悔。其实伟大友谊不真也不假，就如世上一切东西一样，你信它是真，它就真下去；你疑他是假，它就是假得。我的话也半真不假。但是我随时准备兑现我的话，哪怕天崩地裂也不退却。就因为这种态度，别人都不相信我</li></ul><ul><li>那一夜开头有月光，后来月亮落了下去，出来一天得信息，就像早上得露水一样多。那天晚上没有云风，山上静得很</li></ul><ul><li>陈清扬后来说，她一辈子只交了我一个朋友。她说，这一切都是因为我在河边的小屋里谈到伟大友谊 。人活着总要做几件事情，这就是其中之一。以后她就没和任何人有过交情。同样的事情做多了没意思</li></ul><ul><li>陈清扬说，人活在世上，就是为了忍受摧残，一直到死。想明了这一点，一切都能泰然处之</li></ul><ul><li>我要抱着草长马发情的伟大真诚去做一切事，而不是在人前羞羞答答的表演</li></ul><ul><li>忽然之间心底涌起强烈的渴望，前所未有：我要爱，要生活，把眼前的一世当作一百世一样。这里的道理很明白；我思故我在，既然我存在，就不能装作不存在。无论如何，我要对自己负起责任</li></ul><ul><li>洗过澡以后，我赤条条走到阳台上去。漫天都是星星，好像一场冻结了的大雨。这是魅人的星空。我和玲子好时，也常常晚上出去，在星空下走。那时候我们一无所有，也没有什么能妨碍我们享受静夜</li></ul><ul><li>我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人</li></ul><ul><li>在这样的夜里，人不能不想到死，想到永恒。死的气氛逼人，就如无穷的黑暗要把人吞噬。我很渺小，无论做了什么，都是同样的渺小。但是只要我还在动，就超越了死亡。现在我是诗人。虽然没发表过一行诗，但正因为如此，我更伟大。我就想那些行吟诗人，在马上为自己吟诗，度过那些漫漫寒夜</li></ul><ul><li>似水流年是一个人所有的一切，只有这个东西，才真正归你所有。其余的一切，都是片刻的欢娱和不幸，转眼间就已跑到似水流年里去了</li></ul><ul><li>我们生在这亡命的年代，作为两个亡命之徒，是何等的幸福！真应该联手作一番事业！</li></ul><ul><li>如果决定这样去写似水流年，到不患没得写，只怕写不过来。这需要一支博大精深的史笔，或者很多支笔。我上哪儿去找这么一支笔？上哪去找这么多人？就算找到了很多同伴，我也必须全身心投入，在衰老死亡之前不停地写。这样我就有机会在上天所赐的衰老之刑面前，挺起腰杆，证明我是个好样的，但要做这个决定，我还需要一点时间</li></ul><ul><li>人活在世界上就像一海绵，生活在海底。海底还飘荡着各种各样的事件，遇上了就被吸到海绵里，因此我记得各种事情</li></ul><ul><li>我还知道很多更悲惨的事——在我看来，人生最大的悲哀，在于受愚弄。这些悲惨的故事还写得完吗？ </li></ul><ul><li>记得雨果说过，凡不可挽回的东西，都不属于人，属于上帝。所以正义感也不属于我，属于上帝。 </li></ul><ul><li>寂寞是我的选择，正如在地下室里离群索居是我的选择一样。在我看来，寂寞就是可以做一切事的自由，这是因为你做什么都没人知道，或者知道了也不理会。所以我能够翻译“StoryofO”，李先生能够读西夏文。自从我割断了对女人的单恋，寂寞就真正归我所有。寂寞纯黑如夜，甜蜜如糖，醇如酒。</li></ul><ul><li>从此以后，寂寞再不归我所有。这有好处，也有不好处。走进了寂寞里，你就变成了黑夜里的巨灵神，想干啥就干啥，效率非常之高。你可以夜以继日的干任何事，不怕别人打断，直到事情干成。但是寂寞中也有让人不能忍受的时刻，那就是想说话时没有人听。</li></ul><ul><li>积极向上虽然是为人的准则，也不该时时刻刻挂在嘴上。我以为自己的本人就是把小说写得尽量好看，而不应在作品里夹杂某些刻意说教。我的写作态度是写一些作品给读小说的人看，而不是去教诲不良的青年。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的精神家园</title>
      <link href="/2022/03/06/wo-de-jing-shen-jia-yuan/"/>
      <url>/2022/03/06/wo-de-jing-shen-jia-yuan/</url>
      
        <content type="html"><![CDATA[<p>作者：王小波</p><p>出版年：2017-10</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/我的精神家园.jpg" style="zoom:70%;" /><ul><li>我相信，总会有些人渴望有趣得事情，讨厌呆板无趣的生活。假如我有什么特殊之处，那就是：这是我对生活主要的追求</li></ul><ul><li>须知参差多态，乃是幸福的本源</li></ul><ul><li>人生在世，会遇到一些好事，还会遇上些坏事。好事我承受得起，坏事也承受得住。就这样坦荡荡做个寻常人也不坏</li></ul><ul><li>真正有出息的人是对名人感兴趣的东西感兴趣，并且在那上面做出成就，而不是仅仅对名人感兴趣</li></ul><ul><li>处于不同文化中的人可以互相了解，这就需要对各种文化给予不带偏见的完整说法。</li></ul><ul><li>人类是一个整体，是所有的人，大多数的人不等于人类全体。但是我们所知的往往只是我们所处的文化，和我们一样的人，并在不知不觉中把这看成是人类全体</li></ul><ul><li>从表面上看，研究工作有很多内容，比方说，题目有没有人重视啦，一年发了多少论文啦，写了多少学术专著啦，但是这些在她看来并不是最重要的，最重要的是要有所发现</li></ul><ul><li>人的存在是一种自然现象，而不是某种意志的产物。这种现象的内容就包括：人和人是不一样的，有性别之分，贤愚之分，还有同性恋和异性恋之分，这都是自然的现象。把属于自然的现象叫做丑恶，不是一种郑重的态度。这段话的意思说白了就是这样的：有些事原本就是某个样子，不以人的意志为转移</li></ul><ul><li>倘若生活中存在这完全不能解释的事，那很可能是因为有我们所不知道的事实，而不知道的原因却是我们并不真正想知道</li></ul><ul><li>我相信我自己有文学才能，我应该做这件事。但是这句话正如一个嫌疑犯说自己没杀人一样不可信。所以信不信由你吧</li></ul><ul><li>老师们说，怎么做对是科学，怎么做好则是艺术；前者有判断真伪的法则，后者则没有；艺术的真谛就是要叫人感到好，甚至是完美无缺；传授科学知识就是要告诉你这些法则，而艺术的修养是无法传授的，只能够潜移默化</li></ul><ul><li>我反对一切统一到格调上，这是因为它会把整个生活变成一种得分游戏。一个得分游戏不管多么引人入胜，总不能包容全部生活，包容艺术，何况它根本就没有什么意思。假如我要写什么，我就不管它格调不格调，正如谈恋爱时我绝不从爱祖国谈起</li></ul><ul><li>我总觉得小说可以写痛苦，写绝望，不能写让人心烦的事，理由很简单：看了以后不烦也得烦，烦了更要烦，而心烦这件事情，正是大多数中国人最大的苦难</li></ul><ul><li>我知道有些低等生物蒙你的恩惠，可以无性繁殖，我就像细菌那样分裂繁殖好了，这样晚上睡觉，早上一下就变成了两个人，谈恋爱无非是找个伴嘛，自己裂成两半，不就有伴了吗</li></ul><ul><li>承认自己傻过，是一种美德</li></ul><ul><li>我坚信，这一幕时当日维也纳最美丽的风景。我看了以后有些嫉妒，因为他们太年轻了，青年的动人之处，就在于勇气，和他们的远大前程</li></ul><ul><li>真古迹使人留恋之处，在于它历经沧桑直至如今，在它身边生活，你才会觉得历史至今还活着。要是可以随意翻盖，那就会把历史当作可以随意捏造的东西，一个人尽可夫的娼妇；这两种感觉真是大不相同</li></ul><ul><li>做成一件事，需要比呼吁更大的勇气和努力。要是你有这些勇气和精力，不妨动手去做。要是没这份勇气和精力，不如闭上嘴，省点唾沫，使厕所的墙壁保持清洁</li></ul><ul><li>人有无尊严，有一个简单的判据，是把他被当作一个人还是一个东西来对待。这件事情有点两面性，其一是别人把你当作人还是东西，是你尊严之所在。其二是你把自己看成人还是东西，也是你的尊严所在</li></ul><ul><li>假如一个人在生活条件和人际关系上都能感到做人的尊严，他就按一个有尊严的人的标准来行事，像个君子。假如相反，他难免按无尊严人的方式行事，做出些小人的行径</li></ul><ul><li>生活方式像一个曲折漫长的故事，或者像一座使人迷失的迷宫。很不幸的是，任何一种负面的生活都能产生很多乱七八糟的细节，使它变得蛮有趣的。人就在这种趣味中沉沦下去，从根本上忘记了这种生活需要改进</li></ul><ul><li>一个社会里，道德既非圣人之言，也非少数圣徒的判断，乃是成年人的公断。某件事情是否道德，只有当人们完全了解之后，才有道德方面的结论</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爱你就像爱生命</title>
      <link href="/2022/02/20/ai-ni-jiu-xiang-ai-sheng-ming/"/>
      <url>/2022/02/20/ai-ni-jiu-xiang-ai-sheng-ming/</url>
      
        <content type="html"><![CDATA[<p>作者：王小波</p><p>出版年：2021-08</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/ainijiuxiangaishengming.jpg" style="zoom:50%;" /><ul><li>你好哇你银河</li></ul><ul><li>我和你分别以后才明白，原来我对你爱恋的过程全是在分别过程中完成的。就是说，每一次见面之后，你给我的印象都使我在余下的日子里用我这愚笨的头脑可能想到的一切称呼来呼唤你</li></ul><ul><li><p>我发觉我是一个坏小子，你爸爸说的一点也不错。可是我现在不坏了，我有了良心。我的良心就是你。真的</p><p>你劝我的话我记住了，我将来一定把我的本心拿出来给你看。为什么是将来呢？啊，将来的我比现在好，这一点我已经有了把握。你不要逼我把我的坏处告诉你，请你原谅了这一点男子汉的虚荣心吧。我会暗地里把坏处去掉。</p><p>我要完善起来。为了你我要成为完人</p></li></ul><ul><li>当我跨过沉沦的一切，向着永恒开战的时候，你是我的军旗</li></ul><ul><li>我的灵魂里有很多地方玩世不恭，对人傲慢无礼，但它有一个核心，这个核心害怕黑暗，柔弱得像绵羊一样。只有顶平等得友爱才能使它得到安慰。你对我是属于这个核心得</li></ul><ul><li>我整天在想，今天快过去吧，日子过得越快，李银河就越快回来了。你不要觉得这话肉麻，真话不肉麻。祝你愉快</li></ul><ul><li>今天还不见你出现。我的脑子里出现了很多宿命论得狂想。比方说，我很想抛一个硬币来占一占你是否今天回来。这说明我开始有点失常了</li></ul><ul><li>还有我。我是爱你得，看见就爱上了。我爱你爱到不自私的地步。就像一个人手里一只鸽子飞走了，他从心里祝福那鸽子的飞翔。你也飞吧。我会难过，也会高兴，到底会怎样我也不知道</li></ul><ul><li>我会不爱你吗？不爱你？不会。爱你就像爱生命</li></ul><ul><li>我真的不知道怎么才能和你亲近起来，你好像是一个可望而不可及的目标，我捉摸不透，追也追不上，就坐下哭了起来</li></ul><ul><li>你想知道我对你的爱情是什么吗？就是从心底里喜欢你，觉得你的一举一动都很亲切，不高兴你比喜欢我更喜欢别人。你要是喜欢了别人我会哭，但是还是喜欢你。你肯用这样的爱情回报我吗？就是你高兴我也高兴，你难过时我来安慰你，还有别爱别人！</li></ul><ul><li>我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你</li></ul><ul><li>只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话像对自己说话一样，我和你说话也像对自己说话一样。说吧，和我好吗？</li></ul><ul><li>你是非常可爱的人，真应该遇到最好的人，我也真希望我就是</li></ul><ul><li>说实话，爱你爱得要命，你要是讨厌这句话就从这儿撕。你爱不爱另论</li></ul><ul><li>我认为人不应当忽视自己，生活就是自己啊。总要无愧于自己才好。比方说我要无愧于自己就要好好地爱你才对</li></ul><ul><li>我觉得我爱了你了，从此以后，不管什么时候我都不能对你无动于衷。我可不能赞成爱里面一点责任没有。我以为它该是终身不能忘却的。比如说，将来你不爱我了，那你就离开我，可是别忘了它。这是不该忘记的东西</li></ul><ul><li>我们生活的支点是什么？就是我们自己。自己要一个绝对美好的不同凡响的生活，一个绝对美好的不同凡响的意义。你让我想起光辉、希望、醉人的美好。今生今世永远爱美，爱迷人的美。任何不能令人满意的东西，不值得我们屈尊</li></ul><ul><li>你真可爱，让人爱得要命，你一来，我就决心正经地、不是马虎地生活下去，哪怕要费心费力呢，哪怕我去牺牲呢</li></ul><ul><li>我总也写不好爱情，什么热烈和温情也到不了我的笔端，我实在是低能透啦。我觉得爱情里又无限多的喜悦，它使人在生命的道路上步伐坚定</li></ul><ul><li>我越来越认为，平庸的生活、为社会扮演角色，把人都榨干了。我们做的每一件事都是尽义务，我们自己的价值标准也是被规定了的。做人的乐趣不是太可怜了吗？难怪有人情愿做一只疯狗呢</li></ul><ul><li>我和你就好像两个小孩子，围着一个神秘的果酱罐，一点一点地尝它，看看里面有多少甜</li></ul><ul><li>你的名字美极了。真的，单单你的名字就够我爱一世的了</li></ul><ul><li>五线谱是偶尔来的，你也是偶尔来的。不过我给你的信值得写在五线谱里呢。但愿我和你，是一支唱不完的歌</li></ul><ul><li>爱把我们平淡的日子变成节日，把我们暗淡的生活照亮了，使它的颜色变得鲜明，使它的味道从一杯清淡的果汁变成浓烈的美酒</li></ul><ul><li>我的勇气和你的勇气加起来，对付这个世界总够了吧？要无忧无虑地去抒情，去歌舞狂欢，去向世界发出我们的声音，我一个人使不敢的，我怕人家说我疯。有了你我就敢。只要有你一个，就不孤独！</li></ul><ul><li>我会告诉你爱，爱可以把一切都容下。如果我的爱不能容下整个的你，算个什么爱！也许你的爱也能容下整个的我吧？我管怎么说，你要我的爱就够了</li></ul><ul><li>我要用尽所有的生命之能划出一条自身存在的曲线。似乎我没有最终的目的，可是这曲线上的每一点都有我的汗水和思维的痕迹。挖下去，永不停息。也许什么也挖不着，可是一定能挖到我自己。在挖的过程中，我找到了自身灵魂的轨道</li></ul><ul><li>我老觉得爱情奇怪，它是一种宿命的东西。对我来说，它的内容就是碰上了，然后爱上了，然后一点办法也没有了</li></ul><ul><li>我要把我的身心、全部热情、全部灵魂，连带它的一切情绪、一切细微的变化、活动、感触，它的一切甜蜜、悲伤、绝望、挣扎、叹息，它的全部温柔、善良，它的全部高尚、渺小、优点、缺点都给他，还有我的愿望、幻想、一切、一切</li></ul><ul><li>静下来想你，觉得一切都美好得不可思议。以前我我不知道爱情这么美好。爱到深处这么美好。真不想让任何人来管我们。谁也管不着，和谁都无关。告诉你，一想到你，我这张丑脸上就泛起微笑</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人间清醒</title>
      <link href="/2022/02/12/ren-jian-qing-xing/"/>
      <url>/2022/02/12/ren-jian-qing-xing/</url>
      
        <content type="html"><![CDATA[<p>作者：梁晓生</p><p>出版年：2021-9</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/renjianqingxing.jpg" style="zoom:75%;" /><h3 id="第一章-人生是一半蹉跎，一半柔和"><a href="#第一章-人生是一半蹉跎，一半柔和" class="headerlink" title="第一章 人生是一半蹉跎，一半柔和"></a>第一章 人生是一半蹉跎，一半柔和</h3><h4 id="我的父母"><a href="#我的父母" class="headerlink" title="我的父母"></a>我的父母</h4><p>父亲是个崇尚力气的文盲，母亲是个崇尚文化的文盲。崇尚相左，对我们几个孩子寄托的希望也便截然对立。父亲希望我们将来都能靠力气吃饭，母亲希望我们将来都能成为靠文化自立于社会的人</p><p>母亲的教育方式堪称真正的教育，她注重人格、品德、礼貌和学习方面</p><h4 id="我的小学"><a href="#我的小学" class="headerlink" title="我的小学"></a>我的小学</h4><p>一位会讲故事的母亲和从小的贫困生活，是造就我这样一个作家的先觉因素。狄更斯说过：贫困对于一般人是种不幸，但对于作家也许是种幸运。的确，对我来说，贫困并不仅仅意味着童年生活的不遂人愿，它促使我早熟，促使我从童年起就开始怀疑生活，思考生活，认识生活，介入生活。虽然我曾千百次地诅咒过贫困，因贫困感到过极大的自卑和羞耻</p><p>我认为，对于身为教师者，最不应该的，便是以贫富来区别对待学生</p><p>教育的社会使命之一，首先就是应在学校中扫除嫌贫谄富媚权的心态</p><p>而嫌贫谄富，在我们国家，在我们这个国家的小学，中学乃至大学，在二十一世纪的今天，依然不乏其例</p><p>我诅咒这种现象！鄙视这种现象！</p><h4 id="我的中学"><a href="#我的中学" class="headerlink" title="我的中学"></a>我的中学</h4><p>青年永远是文学的最真挚的朋友，中学时代正是人的崭新的青年时代，他们通过拥抱文字拥抱生活，他们是最容易被文学作品感动的最广大的读者群</p><p>我们渴望读书。只要是为了买书，母亲给我们钱时从未犹豫过。母亲没有钱，就向邻居借</p><p>对较多已经是作家的人来说，通往文学目标的道路用写满字迹的稿纸铺垫。这条道路不是百米赛跑，是漫长的“马拉松”，是一步步进行的竞走。这也是一条时时充满了自然淘汰现象的道路。缺少耐心，缺少信心，缺少不断进取精神的人，缺少在某一时期自甘寂寞的勇气的人，即使“一举成名”，声名鹊起，也可能“昙花一现”。始终“竞走”在文学道路上的大抵都是些”苦行僧“</p><h4 id="母亲养蜗牛"><a href="#母亲养蜗牛" class="headerlink" title="母亲养蜗牛"></a>母亲养蜗牛</h4><p>我是早已习惯了寂寞的人，视清静为一天的好运气，一种特殊享受。而且我早已习惯了自己和自己诉说，习惯了心灵的独白。那最佳的方式便是写作</p><p>他们是些很胆怯的小生命，盒子微微一动，立即缩回壳里。它们有时些天生的“居士”，更多的时候，足不出“户”，深钻在沙子里，如同专执一念打算得道成仙之人，早已将红尘看破，排除一切犯贱滋扰，“猫”在深山古洞内苦苦修行。它们又是那么的羞涩，宛如大门不出二门不迈的名家闺秀。正应了那句话，真人不露相，露相不真人。偶尔潜出“闺阁”，总是缓移“莲步”，像是提防好色之徒，攀墙缘树窥芳容玉貌似的</p><p>“那些蜗牛都好像认识我似的，往我手上爬”。我望着母亲，见母亲满面异彩。那一时刻，我觉得老人心灵深处情感交流的渴望，真真的令我肃然，令我震颤，令我沉思</p><h4 id="母亲播种过什么"><a href="#母亲播种过什么" class="headerlink" title="母亲播种过什么"></a>母亲播种过什么</h4><p>他们心中的苦闷种种，是不愿对自己的家庭成员吐诉的。但是这些城市中的小儿女，又是多么需要一个耐心倾听他们吐诉的人啊！那倾听者，不仅应有耐心，还应充满心间的爱心。还应在他们渴望安慰和体恤之时，善于安慰，善于劝解，并且，由衷地予以体恤</p><p>于是，他们后来都非常信赖也无不庆幸地选择了母亲</p><p>此世间亲情，竟延续了三十年之久。我曾很不以为然过，但母亲对我的不以为然也同样不以为然。她不与我争辩，以一种心理非常满足的、默默的矜持，表明她所一贯主张的做人态度。</p><h4 id="给哥哥的信"><a href="#给哥哥的信" class="headerlink" title="给哥哥的信"></a>给哥哥的信</h4><h3 id="第二章-岁月漫长，我们未渐行渐远"><a href="#第二章-岁月漫长，我们未渐行渐远" class="headerlink" title="第二章 岁月漫长，我们未渐行渐远"></a>第二章 岁月漫长，我们未渐行渐远</h3><h4 id="父亲的演员生涯"><a href="#父亲的演员生涯" class="headerlink" title="父亲的演员生涯"></a>父亲的演员生涯</h4><p>这是一种纯粹的个人情感，尽管这一种个人情感在我有不可殚言的虔意。我必得从伤绪中解脱，也是无序别人劝慰我自己明白的、然而怀念是一种相会的形式。我们人类的情感都曾一度依赖与它</p><p>如今之中国人，认真做事认真做人的，实在不多了。如今之中国人，彷佛对一切事没了责任感。连着当官的人，都不大肯愿意认真当官了</p><p>愿我们的生活中，对他人之事的认真，并能从中油然引出自己之愉悦的品格，发扬光大起来吧</p><h4 id="父亲的遗物"><a href="#父亲的遗物" class="headerlink" title="父亲的遗物"></a>父亲的遗物</h4><p>从少年时期至青年时期至现在，我几乎一向处在多愁善感的心态中。我觉得我这个人被那一种心态实在缠绕得太久了</p><h4 id="兄长"><a href="#兄长" class="headerlink" title="兄长"></a>兄长</h4><p>老人而有老孤儿得感觉，这一种忧伤最是别人难以理解和无法安慰得，儿女的孝心只能减轻它，冲淡它，却不能完全抵消它</p><p>对于绝大多数的人，人生本就是一堆责任而已。参悟此谛，爱情是缘，友情是缘，亲情尤其是缘，不论怎样，皆当润砾成珠</p><h4 id="当爸的感觉"><a href="#当爸的感觉" class="headerlink" title="当爸的感觉"></a>当爸的感觉</h4><h4 id="我与儿子"><a href="#我与儿子" class="headerlink" title="我与儿子"></a>我与儿子</h4><p>但正是在那一二年内，我艰难地一步步地向文坛迈进，对儿子的责任和自己的责任，于我，当年确是难以两全之事</p><p>归根到底，我的作品，也许都微不足道，但我教育出怎样一个人交给社会，那不仅仅是我对儿子的责任，也是我对社会的责任。我不希望他多么有出息–这超出我的努力及我的愿望</p><h4 id="关于母爱"><a href="#关于母爱" class="headerlink" title="关于母爱"></a>关于母爱</h4><p>但父母，尤其是母亲，若认为自己在生死线上或能救儿女之命而居然丧失了机会，那她的心灵所受的自责的拷打，是十倍百倍地超过于儿女因“亲不待”而感到的悲伤的</p><p>我祈祷我们的国家早日富强，使一切母亲的不幸的儿女，也都有处处乐园，从而使母爱的特征，不再苦涩忧郁和沉重……无私无怨无悔之事，虽感动人，却不见得都是美好之事啊</p><h4 id="第一支钢笔"><a href="#第一支钢笔" class="headerlink" title="第一支钢笔"></a>第一支钢笔</h4><h3 id="第三章-他们经过我的时候"><a href="#第三章-他们经过我的时候" class="headerlink" title="第三章 他们经过我的时候"></a>第三章 他们经过我的时候</h3><h4 id="我的少年时代"><a href="#我的少年时代" class="headerlink" title="我的少年时代"></a>我的少年时代</h4><p>于是茫然地，不免频频回首追寻消失在岁月里的童年和少年时代</p><p>我的童年和少年，教我较早地懂了许多别的孩子尚不太懂得东西——对父母得体恤，对兄弟姐妹得爱心，对一切被贫困所纠缠得人们得同情，而不是歧视他们，对于生活负面施加给人得磨难得承受力，自己要求于自己的种种的责任感，以及对于生活里一切美好事物的本能的向往，和对人世间一切美好情感的珍重</p><h4 id="也谈四十不惑"><a href="#也谈四十不惑" class="headerlink" title="也谈四十不惑"></a>也谈四十不惑</h4><p>如此看来，对于许多中国男人，“四十而不惑”，其实是四十而始惑：功名利禄，样样都要获得到，彷佛才不枉当一回男人。不惑是假，是口头禅，是让别人相信的。惑是真，是内心所想，梦寐以求的，是目标，是目的</p><h4 id="中年感怀"><a href="#中年感怀" class="headerlink" title="中年感怀"></a>中年感怀</h4><p>人也是一台车床，运转便磨损。不运转着生产些什么，便似废物。宁磨损着而生产什么，不似废物般的还天天保养，这乃是绝大多数人的活法。人到四十岁以后，感觉到自我磨损的严重程度了，感觉到自我运转的状况大不如从前了，肯定都是要心生惆怅的</p><p>中年人成熟了，又成熟又疲惫。咬紧牙关扛着社会的焦虑和不安，再吃力也只不过就是眸子里隐藏着忧郁和惆怅</p><p>他们的忧郁和惆怅，一向是社会的一道凝重的风景线</p><h4 id="爱与机缘"><a href="#爱与机缘" class="headerlink" title="爱与机缘"></a>爱与机缘</h4><p>理性强的人并都是好人，俗言的好人，却通常都是自设理性樊篱较多的人。好人大抵奉行维名立品的人生原则。但是，当好人的理性和好人的人性相冲突时，好人们又是多么可能犯难以纠正的错误啊</p><h4 id="老妪-yu"><a href="#老妪-yu" class="headerlink" title="老妪(yu )"></a>老妪(yu )</h4><p>活在好人边儿的人，大抵内心会发生这种一时的小善良，并且总克制不了这一种自我表现的冲动。表现了，自信自己仍立足于好人边上，便获得一种自慰，和证明了什么的心量安泰感和满足感</p><h4 id="瘦老头"><a href="#瘦老头" class="headerlink" title="瘦老头"></a>瘦老头</h4><p>有良知只不过意味着不做坏事，有责任的人却是要大声疾呼的</p><h4 id="十六路公共汽车咏叹调"><a href="#十六路公共汽车咏叹调" class="headerlink" title="十六路公共汽车咏叹调"></a>十六路公共汽车咏叹调</h4><h3 id="第四章-心安即是天涯"><a href="#第四章-心安即是天涯" class="headerlink" title="第四章 心安即是天涯"></a>第四章 心安即是天涯</h3><h4 id="我和橘皮的往事"><a href="#我和橘皮的往事" class="headerlink" title="我和橘皮的往事"></a>我和橘皮的往事</h4><p>以后我受过许多险恶的伤害，但她是我永远相信，生活中不只有坏人，像她那样的好人时确实存在的……因此我应永远保持对生活的真诚热爱</p><h4 id="看自行车的女人"><a href="#看自行车的女人" class="headerlink" title="看自行车的女人"></a>看自行车的女人</h4><p>我们许多人，不是已经被猜度惯了吗？偶尔有一次竟不被明明有理由猜度我们的人所猜度，于我们自己反倒是很稀奇之事了</p><p>阳光底下， 农村人，城市人，应该是平等的。弱者有时对这平等反倒显得诚惶诚恐似的，不是他们不配，而是因为这起码的平等往往太少，太少……</p><h4 id="羊皮灯罩"><a href="#羊皮灯罩" class="headerlink" title="羊皮灯罩"></a>羊皮灯罩</h4><p>其实她并不犹豫什么，也对结果抱有感觉特别良好的预期。她并非一个脱离现实的女人。北京对她最有益的教诲那就是——任何情况下，都千万别变成一个脱离现实的人而自己懵懂不语</p><h4 id="小垃圾女"><a href="#小垃圾女" class="headerlink" title="小垃圾女"></a>小垃圾女</h4><h4 id="玻璃匠和他的儿子"><a href="#玻璃匠和他的儿子" class="headerlink" title="玻璃匠和他的儿子"></a>玻璃匠和他的儿子</h4><p>我走着走着，我就流泪了。那一天，是我当父亲以来，第一次知道心疼孩子。以前呢，我的心都被穷日子累糙了，顾不上关怀自己的孩子们</p><h4 id="孩子和雁"><a href="#孩子和雁" class="headerlink" title="孩子和雁"></a>孩子和雁</h4><p>聪明的孩子和刚强的大人一样，只在别人不常去而又似乎仅属于自己的地方独自落泪</p><h4 id="种子的力量"><a href="#种子的力量" class="headerlink" title="种子的力量"></a>种子的力量</h4><h3 id="第五章-人生是一半清醒，一半释然"><a href="#第五章-人生是一半清醒，一半释然" class="headerlink" title="第五章 人生是一半清醒，一半释然"></a>第五章 人生是一半清醒，一半释然</h3><h4 id="心灵的花园"><a href="#心灵的花园" class="headerlink" title="心灵的花园"></a>心灵的花园</h4><p>心不过是人的一个重要脏器，而内心世界是一种景观，它是由外部世界不断地作用于内心渐渐形成的</p><p>人心里一旦怀有这一种嫉妒的愤恨，就会进一步干出不计后果、危害别人、危害社会的事，最后就只有自食恶果。一切怀有嫉妒的愤恨的人，最终只有那样一个下场</p><h3 id="初恋杂感"><a href="#初恋杂感" class="headerlink" title="初恋杂感"></a>初恋杂感</h3><p>我喜爱温柔的，善良的，性格内向的，情感纯真的女性</p><p>大概我们已痛失成熟的衰老和污秽……事实上纯真早已不可负得，唯一可以自慰的是我们还未泯灭向往纯真的天性。我们丢失的何止纯真一项？我们大大地亵渎了纯真，还感慨纯真的丧失，怕的是遭受天谴——我们想得如此周到，足见我们将永远地离开纯真了。嚎啕大哭把，不再纯真又渴望纯真的人</p><h4 id="也许是错过的缘"><a href="#也许是错过的缘" class="headerlink" title="也许是错过的缘"></a>也许是错过的缘</h4><h4 id="何妨减之"><a href="#何妨减之" class="headerlink" title="何妨减之"></a>何妨减之</h4><p>减法的人生，未必不是一种积极的人生。而我所谓之减法的人生，乃是不断地从自己的头脑之中删除掉某些人生节目，甚至连残余的信息都不留存，而使自己的人生节目单变得简而又简</p><p>所谓积极的清醒的人生，无非就是要找到那一种最适合自己的人生方式。一经找到，确定不移，心无旁骛。而心无旁骛，则首先要从眼里删除掉某些吸引眼球的人生风景</p><p>一种人生的真相是：无论世界上的行业丰富到何种程度，机遇又多到何种程度，我们每一个人比较能做好的事情，永远也就那么几种而已。有时，仅仅一种而已</p><p>所谓人生的价值，只不过是要认认真、无怨无悔地去做最适合自己的事情而已</p><h4 id="过年的断想"><a href="#过年的断想" class="headerlink" title="过年的断想"></a>过年的断想</h4><h4 id="我如何面对困境"><a href="#我如何面对困境" class="headerlink" title="我如何面对困境"></a>我如何面对困境</h4><p>倘说贫穷毫无疑问是一种人生逆境，那么我到可以大言不惭地说，我对贫困，自小便有一种积极主动的、努力使自己和家人在贫困之中也尽量生活得好一点儿的本能</p><p>我对人生的憧憬，目标从来定得很近很近，很低很低，很现实很现实。想象有时也是爱想象得，但那也只不过是一种早期的精神上的创作活动，一扭头就会面对现实。做好自己在现实中首先最该做好的事，哪怕是在别人看来最乏味最不值得认真对待的事</p><h4 id="人性薄处的记忆"><a href="#人性薄处的记忆" class="headerlink" title="人性薄处的记忆"></a>人性薄处的记忆</h4><p>人看待社会看待他人的目光，如果在需要温良之时从内心里输向眼中一缕温良，倒或许会使目光除成熟而外，再多了一份豁达。而深刻和犀利与豁达相结合，似乎更可能接近世事纷纭的因果关系</p><p>人性原本非是什么厚重的事物。人生的本地是柔韧软绵的。丝绵的最薄处，纤缕分分明明，经纬交织显见，成网而不紊乱</p><p>在人性的丝绵的网罩之下，记忆的棉花才会长久地保持成被的形状而不四分五裂太快地成为无用之物</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读一本书</title>
      <link href="/2022/02/06/ru-he-yue-du-yi-ben-shu/"/>
      <url>/2022/02/06/ru-he-yue-du-yi-ben-shu/</url>
      
        <content type="html"><![CDATA[<p>作者：[美] 莫提默·J. 艾德勒 / 查尔斯·范多伦</p><p>出版年：2004-1</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/ruheyueduyibenshu.jpg" style="zoom:70%;" /><h3 id="阅读的层次"><a href="#阅读的层次" class="headerlink" title="阅读的层次"></a>阅读的层次</h3><h4 id="阅读的活力与艺术"><a href="#阅读的活力与艺术" class="headerlink" title="阅读的活力与艺术"></a>阅读的活力与艺术</h4><p>这本书是为了那些想把读书的主要目的当作是增进理解能力的人而写</p><p>主动的阅读</p><p>阅读的目标：为获得咨询而阅读，以及为求得理解而读</p><p>阅读的效果：取决于在阅读上花了多少努力和技巧</p><h4 id="阅读的层次-1"><a href="#阅读的层次-1" class="headerlink" title="阅读的层次"></a>阅读的层次</h4><p>基础阅读：识字</p><p>检视阅读：在一定时间内，抓住一本书的重点。系统化略读</p><p>分析阅读：全盘的阅读，完整的阅读，优质的阅读。咀嚼和消化一本书</p><p>主题阅读：围绕某个主题的多本书的阅读</p><h4 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h4><p>阅读准备阶段：视力、听力、认知能力</p><p>学习读简单读物的阶段</p><p>快速建立字汇的阶段：从上下文所提供的线索，揭发不熟悉的字眼</p><p>第四个阶段：精炼与增强前面所学的技巧</p><h4 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h4><p>检视阅读一：有系统的略读或粗读</p><p>目标是发现这本书值不值得读</p><p>1)书名，序  2）目录页 3）索引 4）出版者的介绍 5）跟主题息息相关的篇章 6）东翻翻西翻翻</p><p>检视阅读二：粗浅的阅读</p><p>只注意你能理解的部分，不要为一些没法立即了解的东西而停顿</p><p>检视阅读的两个方式都需要快速地阅读。</p><h4 id="如何做一个自我要求的读者"><a href="#如何做一个自我要求的读者" class="headerlink" title="如何做一个自我要求的读者"></a>如何做一个自我要求的读者</h4><p>主动的阅读：一个阅读者需要提出的4个基本问题</p><p>1.整体来说，这本书到底在谈些什么</p><p>2.作者细部说了什么，怎么说的</p><p>3.这本书说得有道理吗？是全部有道理还是部分有道理</p><p>4.这本书跟你有什么关系</p><p>要真正拥有一本书，必须把这本书变成你自己的一部分</p><p>记笔记，表达与作者相同或相异的观点。 </p><p>检视阅读需要回答的问题：1）这是怎样一本书 2）整本书在谈些什么 3）作者是借着怎样的整体架构，来发展他的观点或陈述他对这个主题的理解</p><p>笔记记的是全书的架构，而非内容：结构笔记</p><h4 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h4><p><strong>1.分析阅读的第一个阶段：找出一本书在谈些什么</strong></p><p><em><strong>第一个规则</strong></em>：你必须知道自己在读的是哪一类书。关注书名</p><p>论述性的书：传达知识</p><p>实用性和理论性作品</p><p>理论性的作品是教你这是什么，实用性的作品是教你如何去做你想要做的事情，或你认为应该做的事情</p><p>理论性的作品分类：历史、科学和哲学</p><p>不同的态度阅读不同的书</p><p><em><strong>第二个规则</strong></em>：使用一个单一的句子，或最多几句话(一小段文字，来叙述整本书的内容)</p><p>简短的说出整本书的内容是什么</p><p><em><strong>第三个规则</strong></em>：将书中重要篇章列举出来，说明他们如何按照顺序组成一个整体的框架</p><p>阅读与写作是一体两面的，读者是发现书中隐藏的骨架，作者则是制造骨架为开始。一个作品应该有整体感，清楚明白，前后连贯</p><p><em><strong>第四个规则</strong></em>：找出作者要问的问题，或者作者想要解决的问题</p><p>运用这四个规则，能帮助你回答关于一本书的一些基本问题：整本书谈的是什么？</p><p><strong>2.分析阅读的第二阶段：诠释一本书的内容</strong></p><p><em><strong>第五个规则</strong></em> ：找出重要单字，透过它们与作者达成共识。找出关键字，找出字义</p><p><em><strong>第六个规则</strong></em> ：将一本书重最重要的句子圈出来，找出其中的主旨</p><p><em><strong>第七个规则</strong></em>：从相关文句的关联中，设法架构出一本书的基本论述，以明白作者的主张</p><p>对读者：重要的句子是一些需要花一些努力来诠释的句子</p><p>对作者：最重要的句子是整个论述过程重，阐述作者判断的部分</p><p>*** 第八个规则***：找出作者对问题的解答</p><p>阅读一本书，是一种对话</p><p><strong>3.分析阅读的第三阶段：像是沟通知识一样地的评论一本书</strong></p><p><em><strong>第九个规则</strong></em>：除非你已经了解，否则不要回话。只有你很满意完成了前两个阅读阶段，你才有批评的权力，也有责任这样做</p><p><em><strong>第十个规则</strong></em>：当你不同意作者的观点时，要理性的表达自己的意见，不要无理地的辩驳或争论</p><p><em><strong>第十一个规则</strong></em>：尊重知识和个人观点的不同，在做任何评判之前，都要找到理论基础</p><p>批评式阅读：</p><p>1）要求读者先完整的读完一本书，不要着急评论</p><p>2）恳请读者不要争强好胜或盲目反对</p><p>3）将知识上的不同意见看作是大体上可以解决的问题，要求读者要为自己不同的意见找到理论基础</p><p>当读者不只是盲目地跟从作者的论点，还能和作者的论点争锋相对时，他最后才能提出同意或反对的有意义的评论</p><h3 id="阅读不同读物"><a href="#阅读不同读物" class="headerlink" title="阅读不同读物"></a>阅读不同读物</h3><h4 id="实用型的书"><a href="#实用型的书" class="headerlink" title="实用型的书"></a>实用型的书</h4><p>任何实用型的书都不能解决该书所关心的问题。纸上得来终觉浅，绝知此事要躬行</p><p>理论性的原则会归纳出出色的行事规则</p><p>说明规则 or 阐述形成规则的原因</p><p>阅读一本实用型的书，要问自己的问题：1）作者的目的是什么 2）他建议用什么方法达到这个目的</p><p>3）内容真实吗？你是否能够接受作者的宗旨 - 他最终的目标，以及他建议的达成目标的方法 4）这本书跟我有什么关系？我是否应该采取行动</p><h4 id="想象文学"><a href="#想象文学" class="headerlink" title="想象文学"></a>想象文学</h4><p>论说性作品要传达的是知识，想象文学在阐述一个经验本身，那是读者只能通过阅读才能拥有或分享的经验</p><p>我们是经由感官和想象来体验事情，运用判断和推论，也就是理智，才能理解事情</p><p>不要抗拒想象文学带给你的影响力。在阅读一个故事时，让故事在我们身上活动，让故事贯穿我们，做任何它想要做的事情，我们一定得打开心灵，接纳它</p><p>在想象文学中，不要尝试去找共识、主旨或论述。</p><p>不要用适用于传递知识的，与真理一致的标准来评论小说</p><p>1）将想象文学分类。抒情诗、小说戏剧 2）抓住整本书的大意。情节是作品的大意，整本作品是经验本身 3）不仅将整本书简化为大意，还要能发现整本书是如何架构起来的</p><h4 id="历史书"><a href="#历史书" class="headerlink" title="历史书"></a>历史书</h4><p>第一、对你感兴趣的事件或者时期，尽可能阅读一种以上的历史书 、 第二、阅读历史时，不只要关心在过去某个时间、地点真正发生了什么，还要读懂在任何时空之中，尤其是现在，人们为什么会有如此这般行动的原因</p><p>每一本历史书都有一个特殊且有限定范围的主题</p><h4 id="科学和数学"><a href="#科学和数学" class="headerlink" title="科学和数学"></a>科学和数学</h4><h4 id="哲学书"><a href="#哲学书" class="headerlink" title="哲学书"></a>哲学书</h4><h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><h3 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h3><p>主题阅读所牵扯到的绝对不是一本书，应该读哪些书？</p><p>检视阅读和分析阅读作为进入主题阅读的前置作业或者准备动作</p><h3 id="阅读与心智的成长"><a href="#阅读与心智的成长" class="headerlink" title="阅读与心智的成长"></a>阅读与心智的成长</h3><p>良好的阅读基础在于主动的阅读，阅读时越主动，就读得越好。</p><p>所谓的主动阅读，也就是能提出问题来。读任何一本书时该提出什么样的问题，以及不同种类的书必须以怎样不同的方式回答这些问题</p><p>阅读的四个层次，累积渐进</p><p>好书能给我们什么帮助？ 如果你所读的书都在你的能力范围之内，你就没法提升自己的阅读能力。你必须能操纵超越你能力的书，或者说阅读超过你头脑的书，只有那样的书能帮助你的思想成长。除非你能增长心智，否则你学不到任何东西</p><p>当你成功阅读一本难读的好书之后，你的阅读技巧必然增进了。 一本好书能够教你了解这个世界以及你自己。你不只懂得如何读得更好，还要懂得生命，你变得更有智慧，而不只是更有知识</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>置身事内：中国经济与政府发展</title>
      <link href="/2021/11/28/zhi-shen-shi-nei-zhong-guo-jing-ji-yu-zheng-fu-fa-zhan/"/>
      <url>/2021/11/28/zhi-shen-shi-nei-zhong-guo-jing-ji-yu-zheng-fu-fa-zhan/</url>
      
        <content type="html"><![CDATA[<p>作者：兰小欢</p><p>出版年：2021-8</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/zhishenshinei.jpg" style="zoom:50%;" /><h2 id="上篇-微观机制"><a href="#上篇-微观机制" class="headerlink" title="上篇 微观机制"></a>上篇 微观机制</h2><h3 id="地方政府的权力与事务"><a href="#地方政府的权力与事务" class="headerlink" title="地方政府的权力与事务"></a>地方政府的权力与事务</h3><h4 id="政府治理的特点"><a href="#政府治理的特点" class="headerlink" title="政府治理的特点"></a>政府治理的特点</h4><p>1.中央统一领导，充分发挥地方主动性、积极性</p><p>2.党和政府再组织上紧密交织，人员上高度重叠(本书设计内容可将党和政府放在一起分析)</p><p>3.条块分割，多重领导。同时存在部门从上到下的垂直关系和横向的以行政区划分为界的政府</p><p>4.上级领导与协调。权力高度分散，行政体系复杂</p><p>做事的能力：掌握的资源</p><p>做事的意愿：各方的积极性与主动性</p><h4 id="事权划分的三大原则"><a href="#事权划分的三大原则" class="headerlink" title="事权划分的三大原则"></a>事权划分的三大原则</h4><p>三大原则的共同主题都是在处理不同群体的利益差别与冲突。</p><ul><li>公共服务的覆盖范围，不同人对公共服务的评价不同，享受公共服务的代价不同</li><li>信息具有复杂度，掌握不同信息的人，看法与判断不同，要把决策权交给占据信息优势的人</li><li>上下级的目标和能力不同，需要设立有效的机制去激励下级完成上级的目标</li></ul><p>**1.外部性与规模经济 **</p><p>属地管理。地方政府的权力范围与边界，由行政区划决定。</p><p>一件事情无外部性，本地政府全权处理。有外部性，上级出面协调</p><p>公共物品与服务：规模经济。行政边界的划分跟公共服务的影响范围有关。一方面，因为规模经济，覆盖的人越多越划算，政区越大越好；另一方面，受制于人们获取服务的代价与意愿，政区不能无限扩大</p><p>公共物品规模效应和边界理论–&gt;行政交界的地区，经济发展普通比较落后</p><p>**2.复杂信息 ** </p><p>上级名义上有最终决定权，拥有形式权威。但由于信息复杂，不易处理，下级自主性很大，拥有实际权威。信息优势 –&gt; 实际权威</p><p>信息获取 –&gt; 文件与会议制度</p><p>信息隐瞒 –&gt;上级对下级的监督与审计</p><p>信息复杂多变，模糊不清的地方太多，政府的繁杂事权没有清楚的法律界定，所以体制内的实际权力和责任都高度个人化。</p><p><strong>3.激励相容</strong></p><p>一方想做的事情，另一方既有意愿也有能力做好，就叫激励相容</p><p>专业化强、标准化程度高的部门，具体而明确的事务更多 –&gt; 垂直化的领导和管理(海关)</p><p>与地方经济密不可分，很多工作需要本地配合 –&gt; 地方政府分级管理(工商局)</p><p>面临双重领导的部门，都存在根本的激励机制设计问题：谁是主要领导？工作应该向谁负责？</p><p>激励相容原则要求给地方放权</p><p>要求明确地方的权力和责任。属地管理，一个地区谁主管谁负责，以行政区划为权责边界</p><p>权力和资源的配置要制度化。行政体制与财政体制，明确收入与支出的划分，约束谁能调用多少资源，预算约束</p><h4 id="招商引资"><a href="#招商引资" class="headerlink" title="招商引资"></a>招商引资</h4><p>地方政府不仅可以为经济发展创建环境，它本身就是经济发展的深度参与者，招商引资是以经济建设为中心的地方政府的核心目标</p><p>优惠价格转让工业用地</p><p>金融支持、法律政策支持</p><p>补贴、税收优惠</p><p>招工服务、人才补贴</p><p>对于企业至关重要的生产要素，地方政府几乎都有很强的干预能力。土地、资金、劳动力、科技投入、财税、产业政策、进出口政策</p><h3 id="财税与政府行为"><a href="#财税与政府行为" class="headerlink" title="财税与政府行为"></a>财税与政府行为</h3><p>财政是国家治理的基础和重要支柱，科学的财税体制是优化资源配置、维护市场统一、促进社会公平、实现国家长治久安的制度保障</p><h4 id="分税制改革"><a href="#分税制改革" class="headerlink" title="分税制改革"></a>分税制改革</h4><p><strong>1985-1993 财政包干</strong></p><p>地方财政收入与约定中央约定部分上解中央，剩余部分归地方自己</p><p>好处：可以充分调动全社会的积极性，推动社会整体走出计划经济</p><p>导致的问题：</p><ol><li>中央财政预算收入占全国财政预算总收入比重越来越低。地方财政增速大于与中央约定的固定分成比例增速</li><li>全国财政预算占GDP的比重也越来越低。1）地方政府有意不让预算收入增长太快，想尽办法增加预算外收入，地方政府给企业违规减税、企业偷税漏税</li></ol><p>两个比重的下降严重削弱了国家的财政能力，不利于推进改革</p><p><strong>分税制改革</strong></p><p>1994年分税制改革把税收分为三类：中央税(如关税)，地方税(如营业税)，共享税(如增值税)。同时设国税、地税两套机构，与地方财政部门脱钩，省以下税务机关以垂直管理为主，由上级税务机构负责管理人员和工资。</p><p>好处：减少地方政府对税收的干预，保障中央税收</p><p>缺点：税务系统人员激增，提高了税收的征收成本，企业需要应付两套人马和审查，纳税成本高。2018年国税和地税进行了合并</p><p>增值税(即产品税)。改革后变成共享税，中央拿走75%。税收返还机制：改革后地方增值税收入与改革前一样，新增部分才和中央分</p><p>20世纪初企业所得税改革</p><h4 id="土地财政"><a href="#土地财政" class="headerlink" title="土地财政"></a>土地财政</h4><p>分税制改革并没有改变地方政府以经济建设为中心的任务，却减少了其手头可支配的财政资源。一方面地方可以努力增肌啊税收规模，另一方面地方可以增加预算外收入，其中最重要的就是围绕<em><strong>土地转让和开发所产生的土地财政</strong></em></p><p>我国实行土地公有制，城市土地归国家所有，农村土地归集体所有。农村要转为建设用地，必须先通过征地变成国有土地，然后才可以用于发展工商业或建造住宅</p><p>1998年，1）单位停止福利分房，逐步实行住房分配货币化 2）土地管理法开始实施，基本锁死农村集体用地的非农建设通道，确立了城市政府对土地建设的垄断权力</p><p>2000年前开发商各显神通拿地(滋生腐败) –&gt;2002年四类经营用地招拍挂(土地财政开始膨胀 55%) –&gt; 2008年金融危机，财政与信贷刺激，土地转让收入再上台阶–&gt; 2010年 68% 。</p><p>土地财政，不仅包括巨额的土地使用权转让收入，还包括土地使用和开发有关的各种收入。大部分税收的税基是土地的价值而非面积，所以税收随着土地升值而猛增。商住用地面积上只占了出让土地的一般，但贡献了几乎所有的土地转让权收入。因此<em><strong>土地财政的实质是房地产财政</strong></em></p><h4 id="税收、地租与地方政府竞争"><a href="#税收、地租与地方政府竞争" class="headerlink" title="税收、地租与地方政府竞争"></a>税收、地租与地方政府竞争</h4><p>过去几十年，经济的起步阶段，能利用的资源主要是人力和土地，而土地更容易被资源化，将未来收入一股脑的变成今天高升的地价。土地财政有其弊端，但确实是过去数年城市化和工业化得以快速推进的重要资金来源</p><p>以行政区为单位，以税收和土地为手段展开招商引资竞争，且在上下级政府间层层承包责任和分享收益，这一制度架构对分税制改革后经济的飞速发展，无疑有很强的解释力。</p><p>带来了严重的弊端和负面效果</p><p>地方政府的债务问题。土地的资本运作，本质上是把未来的收益抵押到今天去借钱，如果投资转化为了有价值的资产和未来更高的收入，那么债务不是问题。但是地方政府官员的任期有限，催生个人的短视行为。投资质量下降，收益不高，债务负担越来越重</p><p>资源的使用效率仍然不高。地方政府可以调配平衡工业用地和商业用地，但全国范围内的土地资源和建设用地却很难优化。地区间虽然搞竞争，但是用地指标不能跨省流动。</p><h4 id="纵向不平衡与横向不平衡"><a href="#纵向不平衡与横向不平衡" class="headerlink" title="纵向不平衡与横向不平衡"></a>纵向不平衡与横向不平衡</h4><p>分税制改革后，中央拿走了收入的大头，地方的收支差距由中央转移支付来填补。但是并不代表每级政府都能不上</p><p>基层财政困难。由于上级权威高于下级，造成基层钱少事多。东部沿海地区，从土地财政中获取了大量额外收入，但中西部县乡，财政收入可能连工资都不够 </p><p>财政收入少–&gt; 政府想尽办法搞钱–&gt;政府与群众矛盾 –&gt; 16大提出和谐社会和科学发展观，统筹城乡发展，制止基层政府乱收费，农业税废止 –&gt; 基层财政更加困难 –&gt;加大上级的统筹和转移支付力度 </p><h3 id="政府投融资与债务"><a href="#政府投融资与债务" class="headerlink" title="政府投融资与债务"></a>政府投融资与债务</h3><p>土地资本化的魔力，在于可以挣脱物理属性，在抽象的意义上交易承诺和希望，将过去的储蓄、现在的收入、未来前途，统统汇聚和封存在一小片土地上，使其价值暴增</p><p>政府将未来的土地收入资本化，从银行和其他渠道借入了天量资金，利用土地金融的巨力，推动了快速的工业化和城市化</p><p>这套模式的关键是土地价格，只要不断的投资和建设能带来持续的经济增长，城市就会扩张，低价就会上涨，就可以偿还连本带利越滚越多的债务。可经济增速一但放缓，低价下跌，土地出让收入减少，累积的债务就会沉重的负担，可能压垮融资平台甚至地方政府</p><p>政府投资和土地金融的发展模式，一大弊端就是贪腐严重。与土地相关的交易和投资往往金额巨大，且权力高度集中在个别官员手中，极易滋生腐败</p><p>我国的腐败有两个显著特点 1)腐败与经济高速发展增长长期并存 2）随着改革的深入，政府和市场间关系在不断变化，腐败形式也在不断变化。21世纪以来，与土地相关的案件成了主流</p><h3 id="工业化中的政府角色"><a href="#工业化中的政府角色" class="headerlink" title="工业化中的政府角色"></a>工业化中的政府角色</h3><p>在经济发展起步阶段，资本市场和信用机制都不完善，因此以信用级别高的政府为主体来融资和投资，更为可行</p><p>规模经济 -&gt;产业聚集 -&gt;技术创新 </p><p>东亚经济奇迹一个很重要的特点，就是政府帮助本土企业进入复杂度很高的行业，充分利用其中的学习效应、规模效应和技术外溢效应，迅速提升本土制造业的技术能力和国际竞争力</p><p>政策做多可以帮助企业降低一些财务风险和市场风险，但政府不能帮助企业克服最大的不确定性，即在不断变化的市场中发展出足够的能力和竞争优势。如果做不到这一点，保护和补贴政策最终会变成企业的寻租工具</p><p>市场经济的根本优势不是决策优势。面对不可知的未来，谁也看不清楚，自由市场上，失败也比成功多得多，市场经济的根本优势是可以不断试错，在竞争中优胜劣汰</p><p>政府企业引导基金即时一种招商引资的新方式和新的产业政策工具，也是一种已市场化方式使用财政资金的探索。</p><p>20世纪90年代到21世纪初，基础设施不完善，法制环境不理想，资本市场和社会信用机制不健全，因此以信用级别高的地方政府和国企为主体，以土地为杠杆，可以撬动大量资源，加速投资进程，推动快速工业化和城市化。</p><p>但也带来了如下后果：与土地相关的腐败猖獗；城市化以地为本，忽略了人，民生支出不足，教育、医疗等公共服务供给滞后；房价飞涨，债务急升；经济过度依赖投资，既表现在民众收入不高所以消费不足，也表现在过剩产能无法被国内消化、向国际输出时又引起贸易失衡和冲突</p><h2 id="下篇-宏观现象"><a href="#下篇-宏观现象" class="headerlink" title="下篇  宏观现象"></a>下篇  宏观现象</h2><h3 id="城市化与不平衡"><a href="#城市化与不平衡" class="headerlink" title="城市化与不平衡"></a>城市化与不平衡</h3><p>以土地为中心的城市化忽略了城市化的真正核心：人。地价要靠房价来拉动，但房价要由老百姓买单，按揭要靠买房者的收入来还。所以土地的资本化，实质上是个人收入的资本化。支撑房价和地价的，是人的收入</p><p>地区房价差异的主要原因是供需失衡，人口大量涌入的大城市，居住用地的供给速度远远赶不上人口增长</p><p>城市化的核心不应该是土地，应该是人。要实现地区间人均收入均衡、缩小贫富差距，关键也在人。要真正帮助低收入群体，就要增加他们的流动性和选择权，帮他们离开穷地方，去往能为他提供更高报酬的地方，让他的人力资本更有价值。同时也要允许农民所拥有的土地流动，这些土地资产才会变得更有价值</p><p>我国城市化的三个阶段 1）1994年以前，乡镇企业崛起，农民离土不离乡，城市化速度不快 2）1994年分税制改革后，农民工进城大潮形成，土地撬动的资金支持了大规模的城市化建设。 3）党的十八大之后，随着一系列改革 的陆续推行，城市化的中心开始从土地向人转移</p><h3 id="债务与风险"><a href="#债务与风险" class="headerlink" title="债务与风险"></a>债务与风险</h3><p>人们在乐观时往往低估负债的风险，过多借债，当出现时，又会因为债务负担沉重而缺乏腾挪空间，没办法应对</p><p>债务源于人性，总想尽早满足愿望，又对未来盲目乐观，借钱时总觉得将来能还上。</p><p>我国企业债务负担较重，应对风险的能力受限。若遭受重大外部冲击，就可能面临债务违约风险。而企业裁员甚至倒闭，会降低居民收入，加大居民的风险，也加大其债主银行的风险</p><p>化解债务风险：一是偿还已有债务，二是遏制新增债务</p><p>增发货币。增发货币降低利率，低利率既能减少利息支出，也能刺激消费和投资，提升经济。</p><p>量化宽松。央行增发货币来买入各类资产，把货币注入经济。因其他经济部门受债务所困，有了钱都在还债，没有增加支出，也就没有给物价造成压力，所以不一定导致通货膨胀。量化宽松的主要问题是难以将增发的货币转到穷人手上，因此难以刺激消费支出，还会拉大贫富差距。央行发钱的方式是购买各种金融资产，所以会推高资产价格，收益的是资产所有者，也就是相对富裕的人</p><p>债务货币化。政府加大财政支出来刺激经济，由财政部发债融资，央行直接印钱买过来，无需其他金融机构参与也无需支付利息，也就是所谓的“赤字货币化”。其核心是用无利率的货币替代有利率的债务，以政府预算收支的数量替代金融市场的价格</p><p>货币政策治标不治本，无法从根本上解决债务负担背后的经济增速放缓问题，因为这是结构性问题，是地方政府推送经济发展的模式问题</p><h3 id="国内国际失衡"><a href="#国内国际失衡" class="headerlink" title="国内国际失衡"></a>国内国际失衡</h3><p>制造业巨大成功的背后，也隐藏着两重问题。第一是内部经济结构失衡：重生产、重投资，相对轻民生、轻消费，导致与巨大的产能相比，国内消费不足，而消化不了的产品只能对外输出。这就带来了第二个问题：国外需求的不稳定和贸易冲突</p><p>我国经济结构失衡的最突出特征是消费不足。</p><p>经济发展初期，将更多资源从居民消费转为资本积累，变成基础设施和工厂，可以有效推送经济起飞和产业转型，提高生产率和收入。</p><p>但当经济发展到一定规模后，这种方式就不可持续了。会导致4个问题</p><p>1）基础设施和工业体系已经比较完善，投资什么都有用的时代过来了，投资决策和调配资源的体制需要改变，地方政府主导的局面需要改变</p><p>2）由于老百姓收入和消费不足，无法消化投资形成的产能，很多投资不能形成有效的收入，都浪费掉了，所以债务负担越积越重</p><p>3）劳动收入份额下降和资本收入份额上升，会扩大贫富差距，社会对此的容忍度是有限的</p><p>4）由于消费不足和投资过剩，过剩产能必须向外输出，由于我国体量巨大，输出产能会加重全球贸易失衡，引发贸易冲突</p><p>虽然从会计核算的角度上讲，投资确实可以提升当下的GDP数字，但若投资形成的资产不能提高生产率，带来更高的收入，不能成为未来更高的消费，这种投资就没有形成实质性的财富，就是浪费</p><p>我国地方政府推动经济发展的模式，有三大特点</p><p>1）城市化过程中 重土地，轻人</p><p>2）招商引资竞争重 重扩张，重规模</p><p>3）经济结构上 重投资，重生产，轻消费</p><h3 id="总结：政府与经济发展"><a href="#总结：政府与经济发展" class="headerlink" title="总结：政府与经济发展"></a>总结：政府与经济发展</h3><p>经济发展的核心原则，就是优化资源配置，提高使用效率，尽量做到人尽其才，物尽其用，实现这一目标要依靠竞争</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算广告</title>
      <link href="/2021/11/14/ji-suan-guang-gao/"/>
      <url>/2021/11/14/ji-suan-guang-gao/</url>
      
        <content type="html"><![CDATA[<p>作者：刘鹏&amp;王超</p><p>出版年：2019-10</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/jisuanguanggao.jpg" style="zoom:50%;" /><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>从宏观上，恰恰是因为广告这一后向变现模式的存在，互联网产品的整体用户体验才达到了前所未有的高度。<br>用户产品部门只负责优化产品体验，不对营收负责，而专门面向客户的商业产品部门通过广告等后向变现方式为企业创造营收。在这样的组织方式下，用户产品部门往往能够心无旁骛，专心为提高用户体验而努力</p><p>在互联网广告中，服务于中小商家、以直接销售为目的的广告取代品牌广告成为主流。其次，它的关键不再是创意、策略等人工服务，而是以数据支撑的流量规模化交易为典型特点。也就是说，机器和算法取代了人员与服务，成为在线广告最鲜明的特点。可以说， 互联网广告的灵魂在于数据和技术</p><p>主线1:商业逻辑驱动在线广告产品和技术的升级<br>主线2:数据的交易、利用和交易</p><h4 id="在线广告的市场和背景"><a href="#在线广告的市场和背景" class="headerlink" title="在线广告的市场和背景"></a>在线广告的市场和背景</h4><ol><li><p>综述<br>在线广告：在媒体上投放的广告<br>内涵：在线广告商业活动的定义与目的<br>外延：在线广告发展历史中产生的关键产品形态</p></li><li><p>免费模式<br>免费模式：本质是将那些能够规模化、个性化传播信息的商品，以边际成本的价格出售<br>在传播的过程中，获得了3项可变现的核心资产：流量、数据、影响力<br>3项资产通过商业产品的形式转变为收入的过程，即商业化过程，与用户使用免费产品的过程是分离的，因此被称为后向变现</p></li><li><p>大数据与广告<br>特点<br>1）行为数据。商业活动中必须记录的数据：交易数据，一致性和实时性。行为数据，用户行为，非必须记录的数据，量极大<br>2）全量加工。无法通过采样才降低处理问题的复杂度，产生了专门处理海量数据的技术和存储技术(MapReduce、noSql)<br>3）自动化应用。洞察(人根据数据做出决策)；自动化应用：数据处理的结果直接发送给业务进行自动化决策，人只是建立流程和调整策略</p></li><li><p>广告的定义和目的<br>广告的定义：广告是由已确定的出资人通过各种媒介进行的有关产品(商品、服务和观点)的，通常是有偿的，有组织的，综合的，劝服性的非人员的信息传播活动。<br>“出资人、媒体、受众”</p><p>广告的根本目的: 广告主通过媒体达到低成本的用户接触</p><p>一切付费的信息、产品或服务的传播渠道，都是广告</p></li><li><p>在线广告的表现形式<br>1）横幅广告。嵌在页面中的图片<br>2）文字链广告。一段链接到广告主落地页的文字<br>3）富媒体广告。弹窗、对联、全屏等<br>4）视频广告。<br>5）交互式广告。<br>6）社交广告<br>7）移动广告<br>8）邮件广告<br>9）激励广告<br>10）团购<br>11）游戏联运。<br>12）固定导航。网站导航首页</p></li><li><p>在线广告简史<br>合约广告、竞价广告、程序化交易广告、原生广告</p><p>定向技术和交易形式的进化<br>越来越多的数据源为广告决策提供支持<br>广告与内容结合的越来越紧密</p></li></ol><h4 id="计算广告基础"><a href="#计算广告基础" class="headerlink" title="计算广告基础"></a>计算广告基础</h4><p>计算是为了解决什么问题？解决这些问题需要什么样的业务描述框架</p><ol><li><p>广告有效性原理<br>广告产生到最终产生转化行为的过程</p><p>1）选择：曝光和关注<br>曝光：广告的展示，位置<br>关注：受众意识上注意到广告。上下文广告、行为定向的基础</p><p>2）解释：理解和接受<br>理解：理解广告想要传达的信息<br>接受：认可信息</p><p>3）态度：保持和决策<br>保持：广告传达的信息给用户留下长久的记忆<br>决策：用户的转化行为</p><p>从前到后：点击率 -&gt; 转化率</p></li><li><p>技术特点<br>1）技术和技术导向。精细的受众导向，广告决策和交易朝着计算驱动的方向<br>2）效果的可衡量性<br>3）创意和投放方式的标准化。驱动力：受众定向和程序购买。接口标准<br>4）媒体概念的多样化。<br>5）数据驱动的投放决策</p></li><li><p>核心问题<br>为一系列用户与环境的组合找到最合适的广告投放策略以优化整体广告活动的利润</p></li><li><p>广告收入<br>核心指标：点击率  CTR；转化率 CVR；eCPM（千次展示收入） = 点击率 * 点击价值</p></li></ol><h4 id="在线广告的产品逻辑"><a href="#在线广告的产品逻辑" class="headerlink" title="在线广告的产品逻辑"></a>在线广告的产品逻辑</h4><ol><li><p>商业产品的设计原则<br>用户产品的设计原则：用户产品演进的根本原动力是人们追求方便的天性。因此用户产品的设计原则总是朝着更简单、更直观、更便捷的方向努力。</p><p>商业产品：能够满足明确的商业目标。只要能带来其对应商业目标的提升机会，即使在使用流程上引入一些不便，也是可以接受的<br>1）关注策略 2）数据驱动 3）用户体验</p></li></ol><h4 id="产品形态"><a href="#产品形态" class="headerlink" title="产品形态"></a>产品形态</h4><ol><li><p>合约广告<br>CPT广告<br>广告位合约(固定时段 -&gt; 受众定向)<br>受众定向(标签)：地域、人口属性、媒体频道、上下文、行为、精确位置定向、推荐、团购</p><p>按CPM计费的展示量合约广告<br>保量的特定人群的广告曝光次数 – 流量预测、流量塑形<br>流量预测：售前指导、在线流量分配、出价指导</p><p>在线分配问题：各个合约要求的人群很可能大量交叠，如何设计分配策略，使得各个合约都尽可能的被满足？<br>标签数量增加 -&gt; 分配的复杂度和精准度指数级上升</p></li><li><p>搜索与竞价广告</p><p>竞价广告的本质是将量的约束从交易过程中去除，仅采用价高者得的简单决策方式来投放每一次广告</p><p>搜索广告：以上下文查询词为粒度进行受众定向，并按照竞价方式售卖和CPC结算的广告产品</p><ul><li>查询扩展：查询词的配置方式</li><li>广告放置：eCPM</li><li>位置拍卖：广告主出价-&gt;计算eCPM-&gt;排名</li><li>定价问题: <ul><li>广义第二高价(GSP) :单位置拍卖的最优策略</li><li>VCG定价(多位置)：对于赢得了某个位置的广告主，其所付出的成本应该等于他占据这个位置给其他市场参与者带来的价值损害(难以计算)。在单位置拍卖时VCG退化成GSP</li><li>市场保留价</li><li>价格挤压 ： eCPM = 点击率*出价 ，点击率优先还是出价优先</li></ul></li></ul></li></ol><h4 id="广告网络"><a href="#广告网络" class="headerlink" title="广告网络"></a>广告网络</h4><p>   批量聚合各媒体的剩余流量，按照人群或上下文标签的流量切割方式售卖给广告主</p><p>   竞价广告与合约广告的比较</p><ul><li>市场经济；计划经济</li></ul><ul><li>不保量，保单位成本/ 保量，品牌营销</li><li>高效率，市场规模/效率偏低</li><li>重数据/非数据驱动</li></ul><h4 id="程序化交易广告"><a href="#程序化交易广告" class="headerlink" title="程序化交易广告"></a>程序化交易广告</h4><p>   RTB、ADX、DSP、DE、DMP</p><p>   部分用户数据只有广告主拥有，广告网络这样的封闭式竞价方案是无法规模化和精细化地针对定制化标签进行投放</p><p>   实时竞价 -解决定制化标签指导广告投放的问题</p><h4 id="移动互联与原生广告"><a href="#移动互联与原生广告" class="headerlink" title="移动互联与原生广告"></a>移动互联与原生广告</h4><p>   在程序化交易的场景下，广告与媒体内容的关系则在一定程度上被边缘化了(用户定制化重定向，推荐内容可能和当前上下文无任何关联)，与内容基本独立的广告交易必然会在效果和用户体验方面碰到天花板</p><p>   原生广告，内容即广告</p><p>   原生广告的相关场景</p><ul><li>信息流广告：信息流中插入商业化广告(QQ空间)</li></ul><ul><li>搜索广告：搜索关键词提供了一个明确的上下文场景</li><li>软文广告</li><li>联盟：媒体从广告库中自由选择要推广的对象，并按照自己控制的展现方式进行推广</li></ul><p>   移动互联带来的新的机会</p><ul><li>情景广告。移动设备与用户几乎不会分开，用户行为的全天侯监控和分析，做到从情景和意图出发，推送广告</li></ul><ul><li>大量潜在的本地化广告主。精确地理位置，结合意图，推送附近商家广告</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序化广告 个性化精准投放实用手册</title>
      <link href="/2021/11/10/cheng-xu-hua-guang-gao-ge-xing-hua-jing-zhun-tou-fang-shi-yong-shou-ce/"/>
      <url>/2021/11/10/cheng-xu-hua-guang-gao-ge-xing-hua-jing-zhun-tou-fang-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<p>作者：梁丽丽</p><p>出版年：2017-10</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/程序化广告.jpg" alt="alt" style="zoom:67%;" /><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>是指利用技术手段进行广告交易和管理的一种广告形态（1）以人为本的精准广告定向（2）媒体资源的自动化、数字化售卖与采购。</p><p>程序化广告的核心在于五大正确要素：在正确的时间和正确的场景，通过正确的方式，将正确的商品展示到正确的用户面前</p><h4 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h4><p>对广告主</p><ul><li>效率提升。提升媒介采购效率，提升广告投放效率</li></ul><ul><li>效果提升。覆盖人群的精准和转化率的提升<br>对媒体</li></ul><ul><li>效率提升。提升媒体资源售卖效率</li></ul><ul><li>效果提升。提升流量利用率和用户体验</li></ul><h4 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h4><ol><li><p>需求方<br>即广告主，效果类/品牌类</p></li><li><p>需求方服务<br>需求方平台(Demand-Side Plateform DSP)：为需求方提供实时竞价投放平台。需求方可以在平台上管理广告活动及其投放策略，包括设置目标受众的定向条件、预算、出价、创意等。DSP通过技术和算法自动优化投放效果并提供数据报告</p><p>采购交易平台(Trading Desk TD)： 整合多个DSP平台的技术解决方案，需求方可以在TD上统一管理多个DSP平台的投放，包括分配投放预算、制定和调整投放策略、数据报告等</p></li><li><p>流量供应方<br>媒体网站/APP<br>广告网盟(AD network)：广告平台或者广告网络，可以理解为媒体代理公司，通过为广告主采购媒体方流量，赚取中间差价</p></li><li><p>流量方服务<br>供应方平台(Supply-Side Plateform)/广告交易平台(Ad Exchange ADX)：二者功能和ADX趋于一致，DSP通过API对接AD Exchange或者SSP 实时竞价购买流量</p></li><li><p>广告服务和数据管理<br>程序化创意平台(Programmatic Creative Platefrom PCP)：专注于广告创意的投放优化，通过技术自动生成海量创意，并利用算法和数据对不同受众动态地展示广告并进行创意优化</p></li></ol><p>​        广告验证平台(Ad Verification Plateform )：通常为品牌广告主服务，为其提供广告投放过程中的品牌安全、反作弊、可视度、无效流量验证等保障</p><p>​        数据管理平台(Date Management Plateform  DMP):  为广告投放提供人群标签管理进行受众精准定向，并通过投放数据建立用户画像，进行人群标签的管理以及再投放</p><p>​        监控分析平台(Measurement &amp; Analytics Plateform )：通常会选择信任的第三方监测分析平台对广告投放数据进行同步监测，评估广告投放平台数据的真实性，验证投放的数据如展示<br>量、点击量、受众属性等是否与第三方监测报告一致</p><h2 id="交易模式"><a href="#交易模式" class="headerlink" title="交易模式"></a>交易模式</h2><ol><li><p>RTB实时竞价<br>公开竞价/打底广告/底价/私有竞价(PA)</p></li><li><p>程序化直接交易<br>首选交易：保价不保量(PD)<br>程序化保量：保价保量(PGB、PDB)</p></li><li><p>头部竞价</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>引爆用户增长</title>
      <link href="/2021/11/07/yin-bao-yong-hu-zeng-chang/"/>
      <url>/2021/11/07/yin-bao-yong-hu-zeng-chang/</url>
      
        <content type="html"><![CDATA[<p>作者：黄天文</p><p>出版年：2017-11</p><img src="https://cdn.jsdelivr.net/gh/jdljun/imghosting/img/userGrown.jpg" alt="alt" style="zoom:33%;" /><hr><h3 id="驱动增长的7大要素"><a href="#驱动增长的7大要素" class="headerlink" title="驱动增长的7大要素"></a>驱动增长的7大要素</h3><ol><li><p>供给驱动增长<br>指企业提供的产品或服务充分满足了用户的需求，从而反向拉动用户规模的增长<br>维度1:原本市场空白，通过创造有效供给产品填补市场空白，从而实现用户增长<br>维度2:供给产品线的宽度和深度决定了用户的增长，供给越充分，覆盖范围越广，越能拉动用户增长<br>供给驱动增长的核心在于：供需关系的匹配及匹配效率</p></li><li><p>用户驱动增长<br>指企业不断获取新用户，新用户留存并产生持续性消费的行为<br>单纯的用户数量的增长并不一定能带来企业收入和利润的增长，只有质量高的用户增长了才能给企业带来收入和利润上的增长。</p><p>用户驱动增长的核心：开源节流促成长<br>用户获取，用户留存，用户成长，用户传播</p></li><li><p>产品驱动增长<br>指企业为满足用户需求而创建的功能和服务，是网站功能与服务的集成</p><p>互联网的本质是连接，连接供给方和需求方。产品是连接的工具，工具决定用户获取和转化的效率<br>产品增长的核心是通过互联网产品创新不断降低用户使用门槛，扩大目标用户群体，提升用户转化率，从而实现增长</p></li><li><p>渠道驱动增长<br>指互联网平台流量的来源。渠道的属性决定了用户的质量和人群的匹配度，渠道的大小决定了流量的多少<br>渠道驱动增长的核心：寻找流量洼地，找到精准用户，采取转化率高，成本低的手段进行获客</p></li><li><p>活动驱动增长<br>指企业通过在某一时间点或者时间区间策划大型的营销活动，通过预热、造势，线上线下大力推广宣传，从而在一定时间内呈现爆发式增长的行为。</p><p>活动驱动增长的核心：短期内大力度地打折促销，产生极大的品牌曝光，配合大力度的渠道推广，实现规模化的用户增长</p></li><li><p>数据驱动增长<br>指企业在日常经营过程中遇到的所有可量化的指标，通过这些指标进行一维和多维的交叉组合分析，从而发现增长瓶颈，驱动企业有针对性地给出行之有效的解决方案，从而实现增长</p><p>三要素：发现问题、分析问题和回顾问题</p><p>核心：</p><ul><li>将事情量化，让业务可分析、可追溯、可总结</li><li>数据就像是业务人员的眼睛，通过数据分析有效诊断出增长的瓶颈，有针对性地解决问题，便可实现增长</li></ul></li><li><p>平台驱动增长<br>品牌即转化率<br>品牌驱动增长的核心：品牌因素占据了用户心智，就可以弱化其他因素对用户购买决策的影响，提高购买转化率</p></li></ol><h3 id="增长的3大误区"><a href="#增长的3大误区" class="headerlink" title="增长的3大误区"></a>增长的3大误区</h3><ol><li><p>追求虚荣指标增长<br>指不能体现产品核心竞争力，不能体现产品真实价值的指标。虚荣指标是一些表面指标，如PV、UV、点击量、APP下载量、注册用户数等，真正的核心指标是活动付费用户数有多少、给业务带来实际价值的内容有多少、活跃卖家有多少</p><p>选择核心指标的三大原则：</p><ul><li>指标的选择必须与商业模式的核心目标相契合，且不同时期关注的指标是不一样的</li><li>无论在哪个时期，我们关注的指标都不能伤害用户的核心体验</li><li>数据必须可汇总，可量化</li></ul></li><li><p>用户增长一味追求数量</p><p>用户增长并未带来业绩和收入的增长，主要取决于一下两个方面：</p><ul><li>新增用户质量，以及是否为目标用户</li><li>新增用户是否产生了留存和持续性购买，即新增用户是否成长</li></ul></li></ol><p>​        用户质量、用户留存、用户成长是用户增长的关键因素<br>​        避免方法：一定要获取精准目标用户，一定要是有质量的用户增长；从各方面提升用户留存率，促进用户成长</p><p>​        用户增长 = 有效用户增长</p><p>​        用户增长 = 用户获取 * 用户留存率(用户成长) * 用户变现率</p><ol start="3"><li>用户过早快速增长，加速产品走向死亡<br>在产品尚未被市场验证、用户留存率不高、产品不够完善的情况下，过快的用户增长只会导致负面口碑及大量用户流失，最终加速产品走向死亡<br>避免方法：在正确的时间、用正确的方法，投入正确的资源，做正确的事情<ul><li>第一阶段：发现客户痛点，并探索解决方案。最小解决方案来测试能否有效解决用户痛点</li><li>第二阶段：找到产品与市场之间的契合点</li><li>第三阶段：了解产品和渠道是否匹配</li><li>第四阶段：用户快速增长期</li></ul></li></ol><h3 id="影响增长的4个因素"><a href="#影响增长的4个因素" class="headerlink" title="影响增长的4个因素"></a>影响增长的4个因素</h3><ol><li><p>目标市场空间决定增长潜力<br>目标市场的空间决定了用户规模的大小及未来的增长潜力。目标市场间接决定了用户转化的第一层漏斗有多大，在转化率相同的情况下，第一层用户规模越大，可转化的用户越多，增长潜力和空间越大</p></li><li><p>看不见的漏斗，决定增长瓶颈<br>看不见的漏斗，是指无法通过现有运营数据发现，但会极大影响用户增长转化率的因素</p></li><li><p>市场渗透率对增长的影响<br>市场渗透率是指一种产品和服务在市场上的覆盖程度，是对市场上当前需求和潜在市场需求的一种比较<br>市场渗透率 = 商品的现有需求量/商品的潜在需求量</p></li><li><p>市场竞争对增长的影响<br>企业增长是一个动态发展的过程，伴随着激烈的市场竞争，增长是一个综合多维因素的结果，不同的市场竞争环境下，企业的增长战略锚点会有很大的不同</p><p>用户增长的基本逻辑：供需关系相互拉动，两端循环增长</p><p>互联网的本质是连接，具有很强的网络效应，供给和需求相互促进，循环拉动增长。供给以商品、产品功能、内容或服务等形式存在，需求即用户</p></li></ol><h3 id="互联网的本质特征"><a href="#互联网的本质特征" class="headerlink" title="互联网的本质特征"></a>互联网的本质特征</h3><p>互联网的本质是连接，P2P、点对点、端对端、连接一切，因连接而成网，互联互通。互联网连接一切，又把所连接的一切变成新的连接节点，从而有了连接无限的可能。正是这种连接构成了互联网的数据、关系、平台、市场四个基本特征。节点与节点之间进行信息传输形成数据、节点与节点之间相互作用，相互影响，相互连接形成关系网，诸多关系又连接形成平台，平台的交易功能形成市场。这一切都体现出互联网的4大基本要素：信息(数据)流、资金流、物流、商流</p><h4 id="互联网行业主要的三个特征"><a href="#互联网行业主要的三个特征" class="headerlink" title="互联网行业主要的三个特征"></a>互联网行业主要的三个特征</h4><ul><li>纯互联网，主要解决用户高效上网、沟通交流及获取信息的问题</li></ul><ul><li>互联网+，指互联网公司利用互联网对传统行业进行改造和升级，通过互联网产品创新，提升原有行业的效率，从而形成特定的互联网和传统行业相结合的企业</li><li>+互联网，指传统行业利用互联网来从事营销、销售等活动，将互联网作为一个营销或者销售渠道，本质上仍然是一家传统企业</li></ul><h4 id="行业分析的7个问题"><a href="#行业分析的7个问题" class="headerlink" title="行业分析的7个问题"></a>行业分析的7个问题</h4><ul><li>行业的核心用户是谁？</li><li>行业提供了怎么样的用户价值？</li><li>行业所处的产业链，从源头到终端都有哪些环节？</li><li>驱动行业发展的关键因素是什么？</li></ul><ul><li>市场和竞争状况如何？</li><li>未来的发展趋势是怎么样的？</li><li>商业模式是什么？怎么赚钱</li></ul><h3 id="运营模式与商业模式"><a href="#运营模式与商业模式" class="headerlink" title="运营模式与商业模式"></a>运营模式与商业模式</h3><p>行业特征 -&gt; 运营模式</p><p>运营模式：运营模式是对企业经营过程的计划、组织、实施和控制，是与产品生产和服务创造密切相关的各项管理工作的总称。简单来讲就是企业的经营方法。主要内容包括：业务模式、渠道模式、组织结构、经营模式</p><p>商业模式-&gt;增长的核心指标</p><p>商业模式：一种包含了一系列要素及其关系的概念性工具，用以阐明某个特定实体的商业逻辑。简单来讲就是公司通过什么途径或者方式来赚钱</p><p>运营模式是这个企业持续不断地获取利润的方法的集合。任何一种商业模式都是通过具体的运营模式来实现的，而有真正商业价值的运营模式都是以盈利为最终目的。为此，盈利模式是赚钱的具体手段，其最终是通过运营模式来实现整体的商业价值。<br>简单理解：商业模式是一个平台，运营模式是这个平台之下的战略，盈利模式是战术。商业模式偏重于如何赚钱，运营模式偏重于赚钱过程中的管理</p><h3 id="核心指标拆解"><a href="#核心指标拆解" class="headerlink" title="核心指标拆解"></a>核心指标拆解</h3><ol><li><p>按照主要业务流程拆解，自顶向下拆解问题</p><ul><li>5W1H方法描述基本问题</li><li>确定顶层业务流程</li><li>从顶层业务流程开始向下逐步拆解</li></ul></li><li><p>按照营销漏斗模型拆解<br>营销过程中将访问用户或潜在用户逐步变为购买用户的转化量化模型。拆解分析营销过程中的各个环节效率，找到薄弱环节</p></li></ol><h3 id="产品冷启动"><a href="#产品冷启动" class="headerlink" title="产品冷启动"></a>产品冷启动</h3><p>名人效应、打造爆款、马甲效应、种子用户特权机制、邀请机制、媒体报道/新媒体运营<br>充分发挥自身的优势，寻找目标用户重叠度高的渠道，找到适合自己的冷启动方式，把每个细节执行到位，就能取得很好的效果。<br>冷启动的核心是产品，方法和渠道只是辅助和放大效果，用户获取仅是一方面，留存率才是冷启动阶段最需要关注的指标。留存率越高，未来渠道获取用户时才能实现健康的增长</p><h3 id="用户拉新与留存"><a href="#用户拉新与留存" class="headerlink" title="用户拉新与留存"></a>用户拉新与留存</h3><h4 id="B端用户拉新"><a href="#B端用户拉新" class="headerlink" title="B端用户拉新"></a>B端用户拉新</h4><ol><li>明确产品定位<br>分析用户痛点和核心需求，明确需要提供什么样的产品或服务来满足目标消费者或者目标消费市场的需求</li><li>确定目标用户<br>明确产品的目标用户是谁，他们都有哪些群体特征</li><li>找到目标用户聚集地<br>分析目标用户都在什么地方，找到他们的聚集地，采取相应手段将他们转化为平台用户</li><li>制定激励方案，加速用户转化<br>拉新时配合激励政策，加速用户转化</li></ol><h4 id="B端用户留存"><a href="#B端用户留存" class="headerlink" title="B端用户留存"></a>B端用户留存</h4><ol><li><p>吸引入驻阶段<br>难点在于降低入驻的门槛，既要保证又简单便捷，又要保证入驻时录入的关键信息能够满足平台做风险管控和用户筛选之间的需求，并做好平衡</p></li><li><p>新手过渡期<br>难点在于如何快速实现交易或某些关键指标零的突破，建设用户成长机制，指引用户成长</p></li><li><p>持续活跃期<br>难点在于培养商家的自主经营能力，引导商家成长，帮助商家产生持续性收入</p></li><li><p>流失期<br>分析为什么导致了用户流失，针对性制定手段解决</p></li></ol><h4 id="商家运营的3个核心要素"><a href="#商家运营的3个核心要素" class="headerlink" title="商家运营的3个核心要素"></a>商家运营的3个核心要素</h4><ol><li>充分理解商家所处行业的发展趋势和规律，将互联网思维和营销工具与每个行业做深度的结合</li><li>充分挖掘商家的优势资源，制定有针对性的运营方案。调用积极性，帮助合理运用平台营销工具和规则持续提升营业额</li><li>利用好榜样的力量，通过塑造标杆商户，打造成功案例，挖掘优秀商家的成功经验，反哺同行业其他商家，形成有层次的商家结构</li></ol><h4 id="C端用户拉新"><a href="#C端用户拉新" class="headerlink" title="C端用户拉新"></a>C端用户拉新</h4><p>打造流量型产品、打造流量品类、营销工具创新、好友邀请、地推、异业合作、物质激励、内容化、活动拉新、机构获客</p><h4 id="C端用户留存"><a href="#C端用户留存" class="headerlink" title="C端用户留存"></a>C端用户留存</h4><p>一个健康的用户增长体系，既要搭建优质的新用户获取渠道，又要做好用户在整个生命周期的留存和运营，让用户持续在平台上活跃，搭建了一条完整的用户成长体系<br>1.新用户购买转化期，提升新用户购买转化和成长<br>2.成长期，提升用户粘性。复购<br>3.成熟期，提升用户ARPU值，提高用户购买频次和客单价，跨品类导流<br>4.衰退期，流失用户预警：流失用户预警。RFM模型<br>5.流失期，定义问题，确认类型，诊断召回</p><p>B端用户运营重点是给商家赋能，让他们学会更多的自主运营能力，C端用户运营重点是增强用户粘性，培养购买习惯<br>想通的地方在于，都需要分析每个阶段用户的需求是什么，根据用户的需求展开有针对性的引导和激励，让他们长时间留存下来</p><h3 id="用户成长体系"><a href="#用户成长体系" class="headerlink" title="用户成长体系"></a>用户成长体系</h3><p>用户成长体系是建立在用户数据模型上的基础上，找到用户成长的关键路径、核心驱动力，搭建用户成长的激励通道和连接用户行为的触达路径，而形成的一整套驱动用户成长的运营机制</p><h4 id="用户成长"><a href="#用户成长" class="headerlink" title="用户成长"></a>用户成长</h4><p>指用户在产品使用过程中的不同阶段，平台希望用户达到的不同状态<br>建立用户模型-&gt;搭建连接用户的通道-&gt;促进用户成长</p><p>一个好的用户成长体系是以产品为核心，以帮助用户解决更多需求为原点，让用户从产品中实现自我满足的需要。用户成长体系的核心在于，找到驱动用户成长的关键因素，这个是根本也是核心驱动力，其他的模型和通道是实现的方法和手段。搭建用户成长体系既要找到用户的核心驱动力，通过产品去实现，又要找到能够激励用户成长的关键因素，并且建立用户的激励通道和触达通道，建立用户与产品之间的深度连接关系</p><h4 id="用户运营"><a href="#用户运营" class="headerlink" title="用户运营"></a>用户运营</h4><p>资源有限，如何通过资源的合理配置，实现增长。把目标聚焦，抓大放小，把有限的资源投入到能带来增长的用户身上，实现资源的最大化利用</p><p>二八定律<br>分群运营：通过分群运营，解决两个问题，一个是解决用户增量，让企业从不同用户细分维度发现新的增长机会；一个是对存量用户分群，实施差异化的产品策略和运营策略</p><h4 id="用户补贴"><a href="#用户补贴" class="headerlink" title="用户补贴"></a>用户补贴</h4><p>补贴最核心的精髓是通过补贴让用户体验产品或服务的优势留存下来并持续使用。产品与服务才是根本，补贴是加速器</p><p>用户补贴的4种基本逻辑</p><ol><li><p>逻辑1: 补贴获取大量用户形成网络效应<br>为什么互联网容易形成网络效应和垄断？</p><ul><li>互联网的边际成本趋近为0</li><li>互联网的超级连接属性造就超强的马太效应(强者愈强、弱者愈弱的现象)</li></ul></li><li><p>逻辑2: 利用补贴培养用户习惯，促进用户成长，提升用户留存率</p></li><li><p>逻辑3: 补贴促进新产品、新技术快速推向市场</p></li><li><p>逻辑4: 补贴可以快速占领市场，加剧竞争和淘汰</p></li></ol><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>写在最前面的话</title>
      <link href="/2021/11/06/xu-yan/"/>
      <url>/2021/11/06/xu-yan/</url>
      
        <content type="html"><![CDATA[<p>闲来无事在语雀上想翻一些东西看看，偶然间看到一篇作者写自己大学期间做了些什么的文章，文章里面提到的有一些事情是自己想做却一直找理由在推脱没有做的。惊羡于作者的同时，又不得不反思自己的执行力，痛定思痛后终于开始做一些非空谈的事情。</p><p>花了一点事件搭了个个人博客，页面虽然还很粗糙，但基本功能算是具备了。因自己是业务后端出生，前端开发只是懂个皮毛，也是偷了懒，整个博客网站基本是用成熟的框架能力搭建起来的，没有尝试自己去开发页面，所以并未耗费太多力气，再想起以前自己以前怕麻烦的拖延，不由得汗颜。</p><p>不管如何，博客网站搭出来之后，总得放点东西上去吧。以后的读书笔记，生活记录，一些思考和牢骚都打算放上去，慢慢地让内容变得丰富，说不定以后也能做到阅其博客，知其为人呢。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
