<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="jdljun">
    
    <title>
        
            Leetcode题解整理 |
        
        Life Records
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/weblogo.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"jdljun.github.io","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/weblogo.jpg","favicon":"/images/weblogo.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"抱着草长马发情的伟大真诚去做一切事"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Life Records
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Leetcode题解整理</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/weblogo.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">jdljun</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2022-08-07 20:39:08
    </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>17.7k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>96 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><h3 id="1-自定义排序"><a href="#1-自定义排序" class="headerlink" title="1.自定义排序"></a>1.自定义排序</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 按int[0]从小到大排序</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1.双指针"></a>1.双指针</h3><p>常用于遍历数组，两个指针指向不同的元素，协同完成任务</p>
<h4 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h4><p>一个指针从左往右，一个指针从右往左</p>
<p><strong>1.二分查找</strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> middle<span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                right <span class="token operator">=</span> middle<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                left <span class="token operator">=</span> middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p><strong>1.判断是否有环</strong></p>
<p>快指针一次走两步，慢指针一次走一步，若无环，快指针最终会走到null，若有环，快慢指针会相遇</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>slow<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2.判断是否有环，并找到环入口</strong></p>
<p>结论：当快慢指针相遇时，让任意一个指针指向head，二者再以相同速度前进，再次相遇的节点就是环开始的地方</p>
<p>证明：设链表长L，环起始点到head的距离为a，环长度为r，则L=a+r，快指针一次走P步，慢指针一次走Q步。假设快慢指针相遇时，相遇点距环起点的距离为X，慢指针走的距离为a+nr+X，快指针走的距离为a+mr+X，（a+nr+X）* P = （a+mr+X）* Q  ==》a = （（mr+X）<em>Q - （nr+X）</em>P）/（P-Q） </p>
<p>当Q = 1，P=2时，简化为 a = 2<em>（nr+X ）- （mr+X）= （2</em>n-m）r  - X  = （2n-m-1）*r + （r - X）</p>
<p>即：环入口距离head的距离a 和 环长度 - 相遇点距离环入口的距离，相差整数倍的环长度。</p>
<p>让慢指针回到head，快指针从快慢指针的相遇点出发，步长均为1，当慢指针走到环入口时，快指针走了（2n-m-1）*r + （r - X）步，二者正好在环起点相遇</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Node <span class="token function">findCycleBeginNode</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>slow<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>slow<span class="token operator">!=</span>fast<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>3.有序链表找中间数</strong></p>
<p>慢指针一次走一步，快指针一次走两步，当快指针走到终点时，慢指针就处于中间位置</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMiddle</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> slow<span class="token punctuation">.</span>value<span class="token punctuation">;</span> 
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>value <span class="token operator">+</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>4.输出链表倒数第K个节点</strong></p>
<p>让快指针先走K步，然后慢指针从head出发，当快指针达到链表末尾时，慢节点即处于倒数第K个节点</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Node <span class="token function">findKNode</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>一个可变的窗口，左右两端方向一致的向前滑动(右端固定，左端向前滑动；或左端固定，右端向前滑动；或左右两端同时向前滑动)</p>
<p>关键点1：如何判断当前窗口是否满足要求</p>
<p>关键点2：左右两端如何移动</p>
<p>易错点1：左右两端移动后，一些参数如何变化</p>
<p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" >无重复字符的最长子串<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>步骤1：初始化窗口的left和right</p>
<p>步骤2：增加right扩大窗口，直到窗口中的序列不再满足要求</p>
<p>步骤3：增加left缩小窗口，直到窗口中的序列满足要求。同时，每一次增加left前，都需要更新一轮结果</p>
<p>步骤3：重复2，3，直到left、right到达尽头</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        Map<span class="token operator">&lt;</span>Character <span class="token punctuation">,</span> Character <span class="token operator">></span> charMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>charMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                charMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                size<span class="token operator">++</span><span class="token punctuation">;</span>
                right<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">></span> maxSize<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                maxSize <span class="token operator">=</span> size<span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            charMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
            size<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> maxSize<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-repeating-character-replacement/" >替换后的最长重复字符<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>滑动窗口</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">characterReplacement</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>


        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> times <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> maxTimes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            times<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
            maxTimes <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxTimes<span class="token punctuation">,</span> times<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> maxTimes <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                right<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                times<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">--</span><span class="token punctuation">;</span>
                right<span class="token operator">++</span><span class="token punctuation">;</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/" >删除最短的子数组使剩余数组有序<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public int findLengthOfShortestSubarray(int[] arr) &#123;

        if(arr.length &lt;=1) &#123;
            return 0;
        &#125;

        boolean[] fromLeft = new boolean[arr.length];
        boolean[] fromRight = new boolean[arr.length];

        int result = arr.length - 1;

        fromLeft[0] = true;
        for(int i=1; i&lt; arr.length; i++)&#123;
            fromLeft[i] = (arr[i] &gt;= arr[i-1]) &amp;&amp; fromLeft[i-1];
            if(fromLeft[i] &amp;&amp; arr.length-i-1&lt;result)&#123;
                result = arr.length-i-1;
            &#125;

            if(!fromLeft[i])&#123;
                break;
            &#125;
        &#125;
        fromRight[arr.length-1] = true;
        for(int i=arr.length-2;i&gt;=0;i--)&#123;
            fromRight[i] = (arr[i]&lt;=arr[i+1]) &amp;&amp; fromRight[i+1];
            if(fromRight[i] &amp;&amp; i&lt;result)&#123;
                result = i;
            &#125;

            if(!fromRight[i])&#123;
                break;
            &#125;
        &#125;

        for(int i=0;i&lt;arr.length;i++)&#123;
            if(!fromLeft[i])&#123;
                continue;
            &#125;
            for(int j=i+result;j&gt;i;j--)&#123;

                if(j-i-1 &gt;= result)&#123;
                    continue;
                &#125;

                if(!fromRight[j])&#123;
                    break;
                &#125;

                if(arr[i]&lt;=arr[j])&#123;
                    result = Math.min(result, j-i-1);
                &#125;
            &#125;
        &#125;

        return result;
    &#125;
</code></pre>
<h3 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2.贪心算法"></a>2.贪心算法</h3><p>每次操作保证局部最优，从而使得最终结果全局最优</p>
<h4 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h4><p>需要根据实际情况判断按区间开头排序还是按区间结尾排序。</p>
<p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/" >无重叠区间<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>为了给其他区间更大的选择空间，所以优先选择结尾小的区间。按区间结尾从小到大排序，从左往右看区间，区间不重叠则保留，重叠则排除</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span>  a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> position <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>position<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                result<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                position  <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" >用最少数量的箭引爆气球<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 右边界从左往右排序, 箭每次尽量射到右边界</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> result <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>points<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                result<span class="token operator">++</span><span class="token punctuation">;</span>
                x <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/" >分发糖果<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>约束条件：</p>
<ul>
<li>每个人至少分配一个糖果 —— 初始化糖果数为1</li>
<li>相邻孩子评分高的获得更多糖果 —— 从左往右看，评分高的孩子比左边孩子分配更多的糖果，从右往左看，评分高的孩子比右边孩子分配更多的糖果</li>
</ul>
<p>每个人首次分配一个糖果，</p>
<p>先从左往右遍历，评分大则分的糖果数更新为前一个孩子的糖果数+1，</p>
<p>再从右往左遍历，评分大并且当前糖果数小于等于前一个孩子，则分的糖果数更新为前一个孩子的糖果数+1</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ratings<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candyNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ratings<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
        candyNum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ratings<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ratings<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> candyNum<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> result <span class="token operator">+</span> candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> ratings<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>candyNum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> result <span class="token operator">+</span> candyNum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span>candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                candyNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> candyNum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h3><p>应用于有最优子结构的问题，保存字结构的解，避免重复计划</p>
<p>核心：状态转移方程</p>
<h4 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/" >斐波那契数列<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        result<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>result<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/arithmetic-slices/" >等差数列划分<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 定义dp[i] 为num[i] 结尾的等差数组的数量</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> result<span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/" >最小路径和<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        
        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/01-matrix/" > 01 矩阵<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mat<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        
        <span class="token keyword">int</span> m <span class="token operator">=</span> mat<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//向右向下</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>



        <span class="token comment" spellcheck="true">//向左向上</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>



        <span class="token keyword">return</span> dp<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/" >完全平方数<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>状态转移方程不依赖相邻位置，而是依赖于满足分割条件的位置</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">*</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/" >解码方法<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 1.看作增加一位</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 2.和前一位合并一起看</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'1'</span> <span class="token operator">||</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'2'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/" >单词拆分<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>对字符串A进行分割后形成左右两个字符串B、C，A满足条件当且仅当B、C都满足条件，B是否能分割&lt;=&gt;dp[分割位置]，C满足条件&lt;=&gt;C在字典中</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDict<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> 
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/" >最长递增子序列<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>子序列问题解法一：定义一个dp数组，dp[i] 表示以i结尾的子序列的性质。在处理好每一个位置的，在统计一遍每一个位置的结果即可得到题目要求的结果</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/" >最长公共子序列<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>子序列问题解法二：定义一个dp数组，dp[i]表示到位置i为止的子序列的性质，并不必须以i结尾。这样dp数组的最后一位即为题目所求，不需要再统计每个位置</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>String text1<span class="token punctuation">,</span> String text2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        
        <span class="token keyword">int</span> m <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment" spellcheck="true">// dp[i][j]定义为 第一个string长度最长为i，第二个string长度最长为j，最长公共子序列的长度</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>text1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> text2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" >最长重复子数组<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>dp[i] [j] 第一个数组i位置，第二个数组j位置的重复子数组的长度</p>
<p>if a[i] = b[j]  then dp[i] [j] = dp[i-1] [j-1] + 1</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLength</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> nums2<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> result <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> 

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token operator">&lt;</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        result <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>4.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/" >不相交的线<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>dp[i] [j] 定义为a数组的i个数，b数组的第j个数，最大的连线数</p>
<p>if(a[i-1] == b[j-1])  dp[i] [j] = dp[i-1] [j-1] + 1</p>
<p>否则 dp[i] [j] = max(dp[i-1] [j], dp[i] [j-1])</p>
<p>题目等价于求最长公共子序列</p>
<pre><code>    public int maxUncrossedLines(int[] nums1, int[] nums2) &#123;

        if(nums1.length &lt; 1 || nums2.length &lt; 1)&#123;
            return 0;
        &#125;

        int[][] dp = new int[nums1.length+1][nums2.length+1];

        for(int i = 1;i&lt;=nums1.length;i++)&#123;
            for(int j = 1;j&lt;=nums2.length;j++)&#123;
                if(nums1[i-1] == nums2[j-1])&#123;
                    dp[i][j] = dp[i-1][j-1] + 1;
                &#125; else &#123;
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                &#125;
            &#125;
        &#125;

        return dp[nums1.length][nums2.length];
    &#125;
</code></pre>
<p><strong>5.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/" >最大子数组和<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public int maxSubArray(int[] nums) &#123;

        int length = nums.length;
        if(length &lt; 1)&#123;
            return 0;
        &#125;

        int[] dp = new int[length];

        dp[0] = nums[0];
        int result = nums[0];
        for(int i=1;i&lt;length;i++)&#123;
            if(dp[i-1]&gt;0)&#123;
                dp[i] = dp[i-1] + nums[i];
            &#125; else&#123;
                dp[i] = nums[i];
            &#125;

            if(result &lt; dp[i])&#123;
                result = dp[i];
            &#125;
        &#125;

        return result;
    &#125;
</code></pre>
<p><strong>6.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/" >判断子序列<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>为true条件：dp[m] [n] = m;</p>
<pre><code>    public boolean isSubsequence(String s, String t) &#123;

        int m = s.length();
        int n =t.length();
        int[][] dp = new int[m+1][n+1];
        for(int i = 1;i&lt;=m;i++)&#123;
            for(int j=1;j&lt;=n;j++)&#123;
                if(s.charAt(i-1) == t.charAt(j-1))&#123;
                    dp[i][j] = dp[i-1][j-1] + 1;
                &#125;else&#123;
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                &#125;
            &#125;
        &#125;

        return dp[m][n]==m;
    &#125;
</code></pre>
<p><strong>7.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/" >不同的子序列<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>定义dp[i] [j] 等于 以t[i-1]结尾的子序列 在 最长长度为j的s子序列中出现的个数</p>
<pre><code>    public int numDistinct(String s, String t) &#123;
        
        int m = t.length();
        int n = s.length();
        if(n &lt; 1 || m &lt; 1)&#123;
            return 0;
        &#125;

        int[][] dp = new int[m+1][n+1];
        for(int i=0;i&lt;n;i++)&#123;
            if(s.charAt(i) == t.charAt(0))&#123;
                dp[0][i] = 1;
            &#125;
        &#125;

        for(int i = 1;i&lt;=m;i++)&#123;
            for(int j=1;j&lt;=n;j++)&#123;
                if(t.charAt(i-1) == s.charAt(j-1))&#123;
                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1];
                &#125;else &#123;
                    dp[i][j] = dp[i][j-1];
                &#125;
            &#125;
        &#125;

        return dp[m][n];
    &#125;
</code></pre>
<p><strong>8.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/" >两个字符串的删除操作<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public int minDistance(String word1, String word2) &#123;

        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m+1][n+1];

        for(int i=0;i&lt;=m;i++)&#123;
            dp[i][0] = i;
        &#125;
        for(int i=0;i&lt;=n;i++)&#123;
            dp[0][i] = i;
        &#125;

        for(int i =1;i&lt;=m;i++)&#123;
            for(int j=1;j&lt;=n;j++)&#123;
                if(word1.charAt(i-1) == word2.charAt(j-1))&#123;
                    dp[i][j] = dp[i-1][j-1];
                &#125;else&#123;
                    // 删除
                    dp[i][j] = Math.min(dp[i-1][j-1]+2, Math.min(dp[i-1][j]+1, dp[i][j-1]+1));
                &#125;
            &#125;
        &#125;

        return dp[m][n];
    &#125;
</code></pre>
<p><strong>9.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/" >编辑距离<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public int minDistance(String word1, String word2) &#123;

        int m = word1.length();
        int n = word2.length();

        int[][] dp = new int[m+1][n+1];

        for(int i = 0 ; i&lt;=m;i++)&#123;
            dp[i][0] = i;
        &#125;
        for(int j =0;j&lt;=n;j++)&#123;
            dp[0][j] = j;
        &#125;

        for(int i =1;i&lt;=m;i++)&#123;
            for(int j=1;j&lt;=n;j++)&#123;
                if(word1.charAt(i-1) == word2.charAt(j-1))&#123;
                    dp[i][j] = dp[i-1][j-1];
                &#125; else &#123;
                    //替换 、 
                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
                &#125;
            &#125;
        &#125;

        return dp[m][n];
    &#125;
</code></pre>
<p><strong>10.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/" >回文子串<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>动态规划1</p>
<p>dp[i] 等于 dp[i-1] + 以位置i结尾的回文串的数量</p>
<pre><code>        int[] dp = new int[s.length()+1];
        for(int i =1 ;i&lt;=s.length() ; i++)&#123;
            dp[i] = dp[i-1];
            for(int j = 1;j&lt;=i;j++)&#123;
                if(isCycString(j,i,s))&#123;
                    dp[i]++;
                &#125;
            &#125;
        &#125;

        return dp[s.length()];
    &#125;

    // aba a=1 b=1
    private boolean isCycString(int a,int b, String s)&#123;

        int n = (b-a)/2;
        for(int i = 0 ;i&lt;=n;i++)&#123;
            if(s.charAt(a+i-1) != s.charAt(b-i-1))&#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
</code></pre>
<p>动态规划2</p>
<p>定义dp[i] [j]  第i个字符到第j个字符的子串是否为回文串</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>j<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> j <span class="token operator">||</span> i <span class="token operator">==</span> j<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">==</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        result <span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            result <span class="token operator">++</span><span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>11.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/" >最长回文子序列<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>定义dp[i] [j] 为 第i个字符到第j个字符的子串最长的回文子序列的长度</p>
<pre><code>    public int longestPalindromeSubseq(String s) &#123;

        int[][] dp = new int[s.length()+1][s.length()+1];

        for(int j = 1;j&lt;=s.length();j++)&#123;
            for(int i=j; i&gt;=1;i--)&#123;
                if(s.charAt(j-1) == s.charAt(i-1))&#123;
                    if( i==j)&#123;
                        dp[i][j] = 1;
                    &#125; else if(i+1 == j)&#123;
                        dp[i][j] = 2;
                    &#125; else&#123;
                        dp[i][j] = dp[i+1][j-1] + 2;
                    &#125;
                &#125;else&#123;
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                &#125;
            &#125;
        &#125;

        return dp[1][s.length()];
    &#125;
</code></pre>
<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p><strong>1. 01背包理论基础</strong></p>
<p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>解：</p>
<p>1、定义dp数组: dp[i] [j]表示 从下标为[0-i]的物品中随意取，放进容量为j的背包，最大的value是多少</p>
<p>2、动态转移方程：</p>
<ul>
<li>如果装不下(weight[i]&gt;j)  dp[i] [j] = dp[i-1] [j] ;</li>
<li>如果装得下 dp[i] = max(dp[i-1] [j], dp[i-1] [j-weight[i]] + value[i])</li>
</ul>
<p>3、dp数组初始化：</p>
<ul>
<li>j=0时表示背包重量为0，所以dp[i] [0] = 0；</li>
<li>i=0时 如果 j&gt;=weight[0], 则dp[0] [j] = value[0] 否则 dp[0] [j] = 0</li>
</ul>
<p>4、确定遍历顺序</p>
<ul>
<li>动态转移方程是从右下遍历到左上，无论是先遍历背包还是物品均可</li>
</ul>
<pre><code>public int weightbagproblem(int[] weight, int[] value, int w)&#123;
      
    int[][] dp = new int[weight.length][w+1];
    for(int j = weight[0] ; j&lt;=w; j++)&#123;
        dp[0][j] = value[0];
    &#125;
    
    for(int i = 1; i&lt;weight.length; i++)&#123;
        for(int j = 1; j&lt;=w; j++)&#123;
            if(weight[i]&gt;j)&#123;
                dp[i][j] = dp[i-1][j];
            &#125;else&#123;
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
            &#125;
        &#125;
    &#125;
    
    return dp[weight.length-1][w];
&#125;
</code></pre>
<p><strong>2. 01背包问题的一维数组解法</strong></p>
<p>1、定义dp数组： dp[j]表示容量为j的背包，最大的value是多少</p>
<p>2、动态转移方程：dp[j] = max(dp[j], dp[j-weight[i]] + value[i])</p>
<p>3、dp数组初始化：dp[0] = 0;</p>
<p>4、确定遍历顺序: 从w到weight[i]</p>
<pre><code>public int weightbagproblem(int[] weight, int[] value, int w)&#123;
      
    int[] dp = new int[w+1];
    
    for(int i =0 ; i&lt;weight.length; i++)&#123;
        for(int j=w;j&gt;=weight[i];j--)&#123;
            dp[j] = Math.max(dp[j], dp[j-weight[i]] + value[i]);
        &#125;
    &#125;
    
    return dp[w];
&#125;
</code></pre>
<p>问题1、为什么倒序遍历？</p>
<ul>
<li>从前往后遍历，每次取得的状态会和之前的状态重合，即随着背包容量的变大，存在可能性一个物品被重复放入多次。而从后往前遍历，每次取得的状态与之前的状态无关</li>
</ul>
<p>问题2、为什么二维数组不需要从后往前？</p>
<ul>
<li>二维dp i位置的状态由上一层的i-1 推导得到，本层的dp[i] [j]  和 dp[i] [j-1] 不会相互影响</li>
</ul>
<p><strong>3.完全背包理论基础</strong></p>
<p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品可以用无限次，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>和01背包的差别：每件物品可以使用多次； 01背包j从大到小遍历，防止物品被放入多次；而完全背包刚好相反，j从小到大遍历，使得每件物品尝试放入多次</p>
<pre><code>//遍历物品
for(int i=0;i&lt;weight.length;i++)&#123;
    //遍历背包
    for(int j=weight[i];j&lt;=w;j++)&#123;
        dp[j] = max(dp[j], dp[j-weight[i]]+value[i]);
    &#125;
&#125;

//01背包只能先遍历物品，因为011背包要求背包倒序遍历，如果先遍历背包再遍历物品，那么每个背包最多只会放入一个物品
//完全背包先遍历物品还是先遍历背包不影响结果
//因为只要保证dp[j]是根据j之前的dp[j]计算出来的即可
</code></pre>
<p><strong>4.多重背包理论基础</strong></p>
<p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] ,第i种物品最多有m[i]件可用，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>解法：将第i件物品展开，就变成了一个01背包问题</p>
<p><strong>5.能否装满背包(最多装多少)</strong> </p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/" >分割等和子集<i class="fas fa-external-link-alt"></i></a></p>
<p>weight[] = nums[] , value[] = nums[], 元素不可重复使用 =&gt; 01背包问题</p>
<p>题目求解 背包容量为j是能否刚好装满 =》 dp[j]表示容量为j时能装的最大价值，价值=重量 =&gt; dp[j] = j</p>
<pre><code>    public boolean canPartition(int[] nums) &#123;

        int sum = 0;
        for(int i = 0;i&lt;nums.length;i++)&#123;
            sum = sum + nums[i];
        &#125;
        if(sum % 2 == 1)&#123;
            return false;
        &#125;

        sum = sum/2;
        
        int dp[] = new int[sum+1];
        for(int i = 0; i&lt;nums.length;i++)&#123;
            for(int j = sum; j&gt;=nums[i];j--)&#123;
                dp[j] = Math.max(dp[j], dp[j-nums[i]]+nums[i]);
            &#125;
        &#125;

        return dp[sum]==sum;
    &#125;
&#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/" >最后一块石头的重量 II<i class="fas fa-external-link-alt"></i></a></p>
<p>weight[i]=stone[i], value[i]=stone[i]</p>
<p>dp[j] 容量为j时，最大的价值</p>
<p>最后一块石头最小 等价于 分成两个子数组，两个子数组差值最小，(sum-a)-a = sum - 2a，即使得a尽量接近sum/2 ， 若sum为偶数 a = dp[sum/2]  , 若sum为奇数 a=dp[(sum-1)/2]</p>
<pre><code>    public int lastStoneWeightII(int[] stones) &#123;
        
        int sum = 0;
        for(int i = 0;i&lt;stones.length;i++)&#123;
            sum = sum + stones[i];
        &#125;

        int[] dp = new int[sum/2+1];
        for(int i = 0; i&lt;stones.length;i++)&#123;
            for(int j=sum/2;j&gt;=stones[i];j--)&#123;
                dp[j] = Math.max(dp[j], dp[j-stones[i]]+stones[i]);
            &#125;
        &#125;

        return sum - 2*dp[sum/2];
    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/" >单词拆分<i class="fas fa-external-link-alt"></i></a></p>
<p>字典中的单词看作时物品，s看作是背包，题目问的是背包能否填满</p>
<p>dp[i]定义为长度为i的s子序列能否被填满</p>
<p>dp[i] = d[i-len] &amp; s.substr(i-len,i) in wordDict[]</p>
<pre><code>    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;

        boolean[] dp = new boolean[s.length()+1];
        dp[0] = true;
        for(int i=1;i&lt;=s.length();i++)&#123;
            for(int j=0;j&lt;wordDict.size();j++)&#123;
                int len = wordDict.get(j).length();
                if(i&gt;=len)&#123;
                    dp[i] = dp[i-len] &amp;&amp; wordDict.contains(s.substring(i-len, i));
                &#125;
                if(dp[i]==true)&#123;
                    break;
                &#125;
            &#125;
        &#125;

        return dp[s.length()];
    &#125;
</code></pre>
<p><strong>6.装满背包有几种方法（组合/排列）</strong></p>
<p><strong>求组合数</strong></p>
<p>求组合数：外层for循环遍历物品，内层for遍历背包</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/" >目标和<i class="fas fa-external-link-alt"></i></a></p>
<p>题目等价于分成两个数组，两个数组差值为target的分法，设两个数组的和分别为 a 和 sum-a，差值即为：a-（sum-a） = 2a-sum = target =》 a = （target+sum）/2 。</p>
<p>当target+sum为奇数时无解，偶数时即求解：装满容量为a的背包的办法有多少种</p>
<p>定义dp[j] 为装满容量为j的背包有多少种方法</p>
<pre><code>    public int findTargetSumWays(int[] nums, int target) &#123;

        int sum = 0;
        for(int i = 0;i&lt;nums.length;i++)&#123;
            sum = sum + nums[i];
        &#125;

        if((sum+target) % 2 != 0)&#123;
            return 0;
        &#125;

        int bagWeight = (sum+target)/2;
        
        if(bagWeight&lt;0)&#123;
            return 0;
        &#125;

        int[] dp = new int[bagWeight+1];
        dp[0] = 1;
        for(int i =0;i&lt;nums.length;i++)&#123;
            for(int j = bagWeight; j&gt;=nums[i];j--)&#123;
                dp[j] = dp[j] + dp[j-nums[i]];
            &#125;
        &#125;

        return dp[bagWeight];
    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-2/" > 零钱兑换 II<i class="fas fa-external-link-alt"></i></a></p>
<p>定义dp[j] 为金额总和为j的组合数</p>
<p>则 dp[j] = dp[j] + dp[j-coins[i]]</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> amount<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>amount<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>求排列数</strong></p>
<p>求排列数：外层for遍历背包，内层for循环遍历物品。</p>
<p>如何理解：如果物品放在外层，那么编号为i和i+1的物品，出现的顺序一定是 i再i+1，就会少了i+1再i这一种排列数，所以需要把物品放在内层遍历</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/" >组合总和 Ⅳ<i class="fas fa-external-link-alt"></i></a></p>
<p>定义dp[i]为和为i的排列个数</p>
<p>则：dp[i] = dp[i] + dp[i-nums[j]]</p>
<pre><code>    public int combinationSum4(int[] nums, int target) &#123;

        int[] dp = new int[target+1];
        dp[0]=1;

        for(int i=1;i&lt;=target;i++)&#123;
            for(int j=0;j&lt;nums.length;j++)&#123;
                if(i&gt;=nums[j])&#123;
                    dp[i] = dp[i] + dp[i-nums[j]];
                &#125;
            &#125;
        &#125;

        return dp[target];
    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/" > 爬楼梯<i class="fas fa-external-link-alt"></i></a></p>
<p>换成完全背包的视角看这个问题，求得是和为n的排列数</p>
<pre><code>    public int climbStairs(int n) &#123;
        
        int[] dp = new int[n+1];
        dp[0]=1;

        for(int i=1;i&lt;=n;i++)&#123;
            for(int j=1;j&lt;=2;j++)&#123;
                if(i&gt;=j)&#123;
                    dp[i] = dp[i] + dp[i-j];
                &#125;
            &#125;
        &#125;

        return dp[n];
    &#125;
</code></pre>
<p><strong>7.背包装满的最大价值</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/" >一和零<i class="fas fa-external-link-alt"></i></a></p>
<p>每一个字符串的weight有两个：0的数量和1的数量</p>
<p>每个字符串的value都为1：</p>
<p>求解在0的背包weight不大于m，1的背包weight不大于n的情况下，value的最大值</p>
<p>=》</p>
<p>定义dp[i] [j] 表示 0的个数最大为i，1的个数最大为j的情况下，放入字符串个数的最大值</p>
<p>转移方程： dp[i] [j] = max(dp[i] [j], d[i - 当前字符串0的个数] [当前字符串1的个数])</p>
<p>初始化：dp[i] [j] = 0</p>
<pre><code>    public int findMaxForm(String[] strs, int m, int n) &#123;

        int[][] dp = new int[m+1][n+1];

        for(int p = 0;p&lt;strs.length;p++)&#123;
            int nums0 = 0;
            int nums1 = 0;
            for(int q = 0;q&lt;strs[p].length();q++)&#123;
                if(strs[p].charAt(q) == &#39;0&#39;)&#123;
                    nums0 ++;
                &#125; else if(strs[p].charAt(q) == &#39;1&#39;)&#123;
                    nums1 ++; 
                &#125;
            &#125;

            for(int i=m;i&gt;=nums0;i--)&#123;
                for(int j=n;j&gt;=nums1;j--)&#123;
                    dp[i][j] = Math.max(dp[i][j], dp[i-nums0][j-nums1]+1);
                &#125;
            &#125;
        &#125;

        return dp[m][n];
    &#125;
</code></pre>
<p><strong>8.背包装满的最大价值</strong></p>
<p><strong>9.装满背包所有物品的最小个数</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/" >零钱兑换<i class="fas fa-external-link-alt"></i></a></p>
<p>理解为value均为1，求装满背包后的value最小值</p>
<p>定义dp[j]为装满dp[j]的背包，value的最小值</p>
<p>则：dp[j] = min(dp[j], d[j-nums[i]]+1)</p>
<pre><code>    public int coinChange(int[] coins, int amount) &#123;

        int[] dp = new int[amount+1];
        for(int i = 1;i&lt;=amount;i++)&#123;
            dp[i] = Integer.MAX_VALUE-1;
        &#125;

        for(int i=0;i&lt;coins.length;i++)&#123;
            for(int j=coins[i];j&lt;=amount;j++)&#123;
                dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);
            &#125;
        &#125;

        if(dp[amount] == Integer.MAX_VALUE-1)&#123;
            return -1;
        &#125;

        return dp[amount];
    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/" > 完全平方数<i class="fas fa-external-link-alt"></i></a></p>
<p>value=1，w=n，weight[i] = i*i，求容量为n的背包装满时value的最小值</p>
<pre><code>    public int numSquares(int n) &#123;

        int[] dp = new int[n+1];
        for(int i=1;i&lt;=n;i++)&#123;
            dp[i]=Integer.MAX_VALUE-1;
        &#125;

        for(int i=0;i&lt;=n;i++)&#123;
            for(int j=1;j&lt;=n;j++)&#123;
                if(j&gt;=i*i)&#123;
                    dp[j] = Math.min(dp[j], dp[j-i*i]+1);
                &#125;
            &#125;
        &#125;

        return dp[n];
    &#125;
</code></pre>
<h4 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h4><p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/" >打家劫舍<i class="fas fa-external-link-alt"></i></a></p>
<p> dp[i] 到编号为i的房屋时，能偷窃的最大金额</p>
<p>初始dp，dp[0] 即为nums[0] ，dp[1] 为nums[0]和nums[1]较大的那个</p>
<p>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</p>
<pre><code>    public int rob(int[] nums) &#123;

        int[] dp = new int[nums.length];

        if(nums.length == 1)&#123;
            return nums[0];
        &#125;

        if(nums.length == 2)&#123;
            return Math.max(nums[0],nums[1]);
        &#125;

        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i =2;i&lt;nums.length;i++)&#123;
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
        &#125;

        return dp[nums.length-1];

    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/" >打家劫舍 II<i class="fas fa-external-link-alt"></i></a></p>
<p>分类讨论一下</p>
<p>包含第一间房：计算第一间房到倒数第二间房的最大值</p>
<p>不包含第一间房：计算第二间房到最后一间房的最大值</p>
<pre><code>    public int rob(int[] nums) &#123;

        if(nums.length == 1)&#123;
            return nums[0];
        &#125;

        if(nums.length == 2)&#123;
            return Math.max(nums[0],nums[1]);
        &#125;

        return Math.max(rob(nums, 0 , nums.length -1),rob(nums, 1 , nums.length) );
    &#125;

    private int rob(int[] nums, int start, int end)&#123;

        int length = end -start;
        int[] dp = new int[length+1];

        if(length == 1)&#123;
            return nums[start];
        &#125;

        if(length == 2)&#123;
            return Math.max(nums[start],nums[start+1]);
        &#125;

        dp[0] = nums[start];
        dp[1] = Math.max(nums[start],nums[start+1]);
        for(int i = 2;i&lt;length;i++)&#123;
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[start+i]);
        &#125;

        return dp[length-1];

    &#125;
&#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/" >打家劫舍 III<i class="fas fa-external-link-alt"></i></a></p>
<p>暴力递归（会超时）    </p>
<pre><code>
    public int rob(TreeNode root) &#123;

        if(root == null)&#123;
            return 0;
        &#125;

        // 不偷head  left+right
        int a = rob(root.left)+ rob(root.right);


        // 偷head  head + left.left+left.right + right.left + right.right
        int b = root.val;
        if(root.left != null)&#123;
            b = b + rob(root.left.left) + rob(root.left.right);
        &#125;
        if(root.right != null)&#123;
            b = b + rob(root.right.left) + rob(root.right.right);
        &#125;

        return Math.max(a,b);
        
    &#125;
</code></pre>
<p>对暴力递归进行优化（记忆化递归）</p>
<pre><code>    // 对已经计算过的节点的value进行记录
    Map&lt;TreeNode, Integer&gt; valueMap = new HashMap&lt;&gt;();

    public int rob(TreeNode root) &#123;

        if(root == null)&#123;
            return 0;
        &#125;

        if(valueMap.get(root) != null)&#123;
            return valueMap.get(root);
        &#125;

        // 不偷head  left+right
        int a = rob(root.left)+ rob(root.right);


        // 偷head  head + left.left+left.right + right.left + right.right
        int b = root.val;
        if(root.left != null)&#123;
            b = b + rob(root.left.left) + rob(root.left.right);
        &#125;
        if(root.right != null)&#123;
            b = b + rob(root.right.left) + rob(root.right.right);
        &#125;

        valueMap.put(root, Math.max(a,b));
        return Math.max(a,b);
        
    &#125;
</code></pre>
<p>动态规划(树形dp)</p>
<p>定义 int[] dp = new int[2]</p>
<p>dp[0] 表示不偷head，那么dp[0] = 左子节点的最大值+右子节点的最大值 = Math.max(robLeft[0], robLeft[1])+Math.max(robright[0],robright[1]);</p>
<p>dp[1] 表示偷head，那么dp[0] = root的value + 不偷左节点head的value+ 不偷右节点head的value =  root.val + robLeft[0] + robright[0]</p>
<pre><code>    public int rob(TreeNode root) &#123;

        int[] result =robNode(root);
        return Math.max(result[0], result[1]);
    &#125;

    private int[] robNode(TreeNode root)&#123;

        int result[] = new int[2];
        if(root == null)&#123;
            return result;
        &#125;

        int[] robLeft = robNode(root.left);
        int[] robright = robNode(root.right);

        //不偷head
        result[0] = Math.max(robLeft[0], robLeft[1])+Math.max(robright[0],robright[1]); 

        //偷head
        result[1] = root.val + robLeft[0] + robright[0];

        return result;
    &#125;
</code></pre>
<h4 id="买卖股票问题"><a href="#买卖股票问题" class="headerlink" title="买卖股票问题"></a>买卖股票问题</h4><p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" >买卖股票的最佳时机<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>股票只能买卖一次，问最大利润</strong>。</p>
<p>贪心：最左取最小，最右取最大</p>
<pre><code>    public int maxProfit(int[] prices) &#123;

        //往右遍历 记录最小值
        if(prices.length &lt;= 1)&#123;
            return 0;
        &#125;

        int result = 0;
        int min = prices[0];
        for(int i = 0 ; i&lt;prices.length;i++)&#123;
            if(prices[i] &gt; min)&#123;
                result = Math.max(result, prices[i]-min);
            &#125;
            
            if(prices[i] &lt; min)&#123;
                min = prices[i];
            &#125;
        &#125;

        return result;
    &#125;
</code></pre>
<p>动态规划</p>
<p>1.定义动态转移方程：</p>
<ul>
<li><p>定义dp[i] [0] 表示第i天持有股票所得的最多现金</p>
</li>
<li><p>dp[i] [1] 表示第i天不持有股票所得的最多现金</p>
</li>
</ul>
<p>2.确定递推公式</p>
<ul>
<li>第i天持有股票 dp[i] [0] = Max(dp[i-1] [0], -prices[i])<ul>
<li>若第i-1天也持有股票 则dp[i] [0] = dp[i-1] [0]</li>
<li>若第i-1天未持有股票 则dp[i] [0] = -price[i]<ul>
<li>之所以是-price[i]， 而不是 dp[i-1] [1] - price[i]， 是因为只能交易一次, 第i-1天未持有股票的情况下现金必定为0</li>
</ul>
</li>
</ul>
</li>
<li>第i天不持有股票 dp[i] [1] = Max(dp[i-1] [0] +  prices[i]， dp[i-1] [1])<ul>
<li>若第i-1天也持有股票, 就相当于在第i天卖出股票  则dp[i] [1] =dp[i-1] [0] +  prices[i]</li>
<li>若第i-1天不持有股票 则dp[i] [1] = dp[i-1] [1]</li>
</ul>
</li>
</ul>
<p>3.初始化</p>
<p>dp[0] [0] = -prices[0], dp[0] [1] = 0</p>
<p>4.遍历顺序 : 从前往后</p>
<pre><code>    public int maxProfit(int[] prices) &#123;

        if(prices.length&lt;=1)&#123;
            return 0;
        &#125;

        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i =1;i&lt;prices.length;i++)&#123;

            // 持有
            dp[i][0] = Math.max(dp[i-1][0], -prices[i]);

            // 不持有
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        &#125;

        return dp[prices.length - 1][1];
    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" >买卖股票的最佳时机 II<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>可以多次买卖股票，问最大收益</strong></p>
<p>和上题唯一的区别就在于第i-1天未持有股票，第i天持有股票的情况下，第i天现金的最大值未第i-1天未持有股票的最大值减去第i天股票的价格</p>
<p>（股票可以多次买卖，第i-1天未持有股票的最大值可能不为0）</p>
<pre><code>    public int maxProfit(int[] prices) &#123;

        if(prices.length&lt;=1)&#123;
            return 0;
        &#125;

        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i =1;i&lt;prices.length;i++)&#123;

            // 持有
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);

            // 不持有
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        &#125;

        return dp[prices.length - 1][1];
    &#125;
&#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" >买卖股票的最佳时机 III<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>最多买卖两次，问最大收益。</strong></p>
<p>定义dp[i] [5]</p>
<ul>
<li>dp[i] [0] 没有操作过 </li>
<li>dp[i] [1] 第一次买入股票(指的是状态，不是第i天买入)</li>
<li>dp[i] [2] 第一次卖出股票</li>
<li>dp[i] [3] 第二次买入股票</li>
<li>dp[i] [4] 第二次卖出股票</li>
</ul>
<p>动态转移方程</p>
<ul>
<li>dp[i] [0] = 0</li>
<li>dp[i] [1] = max(dp[i-1] [1],  - prices[i] )？</li>
<li>dp[i] [2] = max(dp[i-1] [2], dp[i-1] [1] + prices[i])</li>
<li>dp[i] [3] = max(dp[i-1] [3], dp[i-1] [2] - prices[i])</li>
<li>dp[i] [4] = max(dp[i-1] [4], dp[i-1] [3] + prices[i])</li>
</ul>
<p>初始化</p>
<p>dp[0] [0] = 0 ,dp[0] [1] = -prices[0] , dp[0] [2] =  0, dp[0] [3] = -prices[0] , dp[0] [4] =  0 </p>
<p>遍历</p>
<p>从左到右</p>
<pre><code>    public int maxProfit(int[] prices) &#123;

        if(prices.length==0)&#123;
            return 0;
        &#125;

        int[][] dp = new int[prices.length][5];

        dp[0][1] = dp[0][3] = -prices[0];

        for(int i = 1 ;i&lt;prices.length;i++)&#123;
            dp[i][1] = Math.max(dp[i-1][1],  -prices[i]);
            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
        &#125;

        return Math.max(dp[prices.length-1][2], dp[prices.length-1][4]);
    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" >买卖股票的最佳时机 IV<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>最多买卖k笔交易，问最大收益。</strong></p>
<p>最多K次交易，也就是最多K次买入，K次卖出</p>
<p>定义dp[i] [2k+1]， dp[i] [2j+1] 为买入 dp[i] [2j+2] 为卖出</p>
<p>动态转移方程：</p>
<p>dp[i] [2j+1]  = max(dp[i-1] [2j+1], dp[i-1] [2j] - prices[i])</p>
<p>dp[i] [2j+2]  = max(dp[i-1] [2j+2], dp[i-1] [2j+1] + prices[i])</p>
<p>初始化：</p>
<p>dp[0] [2j+1] = -prices[0]</p>
<p>从左到右遍历</p>
<pre><code>    public int maxProfit(int k, int[] prices) &#123;

        if(prices.length &lt; 1)&#123;
            return 0;
        &#125;
        
        int length = prices.length;
        int[][] dp = new int[length][2*k + 1];

        for(int j=0;j&lt;k;j++)&#123;
            dp[0][2*j+1] = -prices[0];
        &#125;

        for(int i = 1;i&lt;length;i++)&#123;
            for(int j =0;j&lt;k;j++)&#123;
                dp[i][2*j+1] = Math.max(dp[i-1][2*j+1], dp[i-1][2*j]-prices[i]);
                dp[i][2*j+2] = Math.max(dp[i-1][2*j+2], dp[i-1][2*j+1]+prices[i]);
            &#125;
        &#125;

        return dp[length-1][2*k];
    &#125;
&#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" >最佳买卖股票时机含冷冻期<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>可以多次买卖但每次卖出有冷冻期1天。</strong></p>
<p>定义dp[i] [4]</p>
<ul>
<li><p>dp[i] [0]: 买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</p>
</li>
<li><p>dp[i] [1]: 两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</p>
</li>
<li><p>dp[i] [2]: 今天卖出股票</p>
</li>
<li><p>dp[i] [3]：今天为冷冻期状态</p>
</li>
</ul>
<p>动态转移</p>
<ul>
<li>dp[i] [0] = max(dp[i-1] [0], dp[i-1] [1] - prices[i], dp[i-1] [3] - prices[i])</li>
<li>dp[i] [1] = max(dp[i-1] [1], dp[i-1] [3])</li>
<li>dp[i] [2] = dp[i-1] [0] + prices[i]</li>
<li>dp[i] [3] = dp[i-1] [2]</li>
</ul>
<p>初始化</p>
<ul>
<li>dp[0] [0] = -prices[0]</li>
<li>dp[0] [1] = 0</li>
<li>dp[0] [2] = 0</li>
<li>dp[0] [3] = 0</li>
</ul>
<p>从左到右遍历</p>
<pre><code>    public int maxProfit(int[] prices) &#123;

        if(prices.length &lt; 1)&#123;
            return 0;
        &#125;

        int length = prices.length;
        int[][] dp =new int[length][4];
        dp[0][0] = -prices[0];
        for(int i =1;i&lt;length;i++)&#123;
            dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1] [1] - prices[i], dp[i-1] [3] - prices[i]));
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);
            dp[i][2] = dp[i-1][0] + prices[i];
            dp[i][3] = dp[i-1][2];
        &#125;

        return Math.max(dp[length-1][1],Math.max(dp[length-1][2],dp[length-1][3]));
    &#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" > 买卖股票的最佳时机含手续费<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>可以多次买卖，但每次有手续费</strong></p>
<p>卖出的时候减去一个手续费</p>
<p>所以不持有的情况下，动态方程变成了dp[i] [1] = Math.max(dp[i-1] [1], dp[i-1] [0] + prices[i] - fee);</p>
<pre><code>    public int maxProfit(int[] prices, int fee所以) &#123;

        if(prices.length&lt;=1)&#123;
            return 0;
        &#125;

        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i =1;i&lt;prices.length;i++)&#123;

            // 持有
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);

            // 不持有
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);
        &#125;

        return dp[prices.length - 1][1];
    &#125;
</code></pre>
<h4 id="状态压缩动态规划"><a href="#状态压缩动态规划" class="headerlink" title="状态压缩动态规划"></a>状态压缩动态规划</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/optimal-account-balancing/" >最优账单平衡<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>public int minTransfers(int[][] transactions) &#123;

        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();

        for(int i =0; i&lt; transactions.length;i++)&#123;

            if(!map.containsKey(transactions[i][0]))&#123;
                map.put(transactions[i][0], transactions[i][2]);
            &#125; else &#123;
                map.put(transactions[i][0], map.get(transactions[i][0])+transactions[i][2]);
            &#125;

            if(!map.containsKey(transactions[i][1]))&#123;
                map.put(transactions[i][1], -transactions[i][2]);
            &#125; else &#123;
                map.put(transactions[i][1], map.get(transactions[i][1])-transactions[i][2]);
            &#125;
        &#125;

        List&lt;Integer&gt; a = new ArrayList&lt;&gt;(); // 收回多少钱

        for(Integer value : map.values())&#123;
            if(value != 0)&#123;
                a.add(value);
            &#125;
        &#125;

        int len =a.size();
        int[] cnt = new int[len];
        for(int i=0;i&lt;len;i++)&#123;
            cnt[i] = a.get(i);
        &#125;


        int m = 1&lt;&lt;len; // 集合个数
        int[] dp = new int[m];

        for(int i=1;i&lt;m;i++)&#123; // 枚举每一个子集

            // 子集求和
            int sum =0;

            for(int j=0;j&lt;len;j++)&#123;
                // 第j个元素在集合中
                if((i&gt;&gt;j &amp; 1) &gt; 0)&#123;
                    sum = sum + cnt[j];
                &#125;
            &#125;

            if(sum != 0 )&#123;
                dp[i] = Integer.MAX_VALUE/2;
            &#125; else &#123;
                dp[i] = Integer.bitCount(i)-1; // 计算i的二进制中1的个数
                // 枚举集合i的子集
                for(int j=(i-1)&amp;i;j&gt;0; j=(j-1)&amp;i)&#123;
                    dp[i] = Math.min(dp[i], dp[j]+dp[i^j]);
                &#125;
            &#125;
            

        &#125;

        return dp[m-1];

    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-sufficient-team/" >最小的必要团队<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public int[] smallestSufficientTeam(String[] req_skills, List&lt;List&lt;String&gt;&gt; people) &#123;

        // 技能进行编码 技能1 -&gt; 0 技能2-&gt;1 技能3-&gt;2
        // 每个人掌握的技能 二进制表达 111  101
        // 把背包装满 所需要的最小人数
        int n = req_skills.length;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        for(int i=0;i&lt;req_skills.length;i++)&#123;
            map.put(req_skills[i], i);
        &#125;

        int[] skill = new int[people.size()];
        for(int i=0;i&lt;people.size();i++)&#123;
            List&lt;String&gt; hasSkill = people.get(i);
            for(String s: hasSkill)&#123;
                skill[i] = skill[i] | (1&lt;&lt;map.get(s));
            &#125;
        &#125;

        // dp[state] 表示掌握技能的状态为state时，需要的最少人的组合
        int[][] dp = new int[1&lt;&lt;n][];
        dp[0] = new int[0];
        for(int i=0;i&lt;skill.length;i++)&#123;
            for(int j=0;j&lt;(1&lt;&lt;n);j++)&#123;
                if(dp[j] == null)&#123;
                    continue;
                &#125;
                int cur = skill[i] | j;
                // 还未被赋值过 或者 存在更小的路径
                if(dp[cur] == null || dp[j].length + 1 &lt; dp[cur].length)&#123;
                    dp[cur] = Arrays.copyOf(dp[j], dp[j].length + 1);
                    dp[cur][dp[j].length] = i;
                &#125;
            &#125;
        &#125;

        return dp[(1&lt;&lt;n) - 1];
    &#125;
</code></pre>
<h3 id="4-回溯法"><a href="#4-回溯法" class="headerlink" title="4.回溯法"></a>4.回溯法</h3><pre><code>void backtracking(参数) &#123;
    if (终止条件) &#123;
        存放结果;
        return;
    &#125;

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    &#125;
&#125;
</code></pre>
<h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>N个数里面按一定规则找出k个数的集合</p>
<p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/" > 组合<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
    private List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;
        dfs(n,k,1);
        return result;
    &#125;

    private void dfs(int n, int k, int start)&#123;

        // 2  n = 5 start = 4 k = 5
        if(path.size() + n- start + 1 &lt; k)&#123;
            return;
        &#125;

        if(path.size() == k)&#123;
            result.add(new ArrayList&lt;Integer&gt;(path));
            return;
        &#125;

        for(int i = start; i&lt;=n;i++)&#123;
            path.add(i);
            dfs(n,k,i+1);
            path.remove(path.size()-1);
        &#125;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/" >组合总和 III<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
    private List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;

        dfs(k,n,1,0);
        return result;
    &#125;

    private void dfs(int k , int n, int start,int sum)&#123;

        if( sum == n &amp;&amp; path.size() == k)&#123;
            result.add(new ArrayList&lt;&gt;(path));
            return;
        &#125;
        if( sum &gt; n || path.size()&gt;k)&#123;
            return;
        &#125;
        for(int i = start;i&lt;=9;i++)&#123;
            path.add(i);
            sum = sum + i;
            dfs(k,n,i+1, sum);
            path.remove(path.size()-1);
            sum = sum -i;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" >电话号码的字母组合<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    Map&lt;Character, String&gt; phoneMap = new HashMap&lt;Character, String&gt;() &#123;&#123;
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    &#125;&#125;;

    private List&lt;String&gt; result = new ArrayList&lt;&gt;();

    private List&lt;Character&gt; s = new ArrayList&lt;Character&gt;();

    public List&lt;String&gt; letterCombinations(String digits) &#123;
        if(digits.length() == 0)&#123;
            return new ArrayList&lt;&gt;();
        &#125;
        dfs(digits, 0);
        return result;
    &#125;

    private void dfs(String digits, int index)&#123;

        if(index == digits.length())&#123;
            StringBuilder sb = new StringBuilder();
            for(int i=0;i&lt;index;i++)&#123;
                sb.append(s.get(i));
            &#125;
            result.add(sb.toString());
            return;
        &#125;

        String str = phoneMap.get(digits.charAt(index));
        for(int j=0;j&lt;str.length();j++)&#123;
            s.add(str.charAt(j));
            dfs(digits, index+1);
            s.remove(s.size()-1);
        &#125;
        
    &#125;
</code></pre>
<p><strong>4.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/" >组合总和<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();


    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;
        dfs(candidates, 0, 0, target, new ArrayList&lt;Integer&gt;());
        return result;
    &#125;

    private void dfs(int[] candidates, int start, int sum, int target, List&lt;Integer&gt; path)&#123;
        if(sum == target)&#123;
            result.add(new ArrayList&lt;Integer&gt;(path));
            return;
        &#125;

        if(sum&gt;target)&#123;
            return;
        &#125;

        for(int i=start;i&lt;candidates.length;i++)&#123;
            sum = sum + candidates[i];
            path.add(candidates[i]);

            dfs(candidates, i, sum, target, path);

            sum = sum - candidates[i];
            path.remove(path.size()-1);
        &#125;
    &#125;
</code></pre>
<p><strong>5.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/" >组合总和 II<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;
        Arrays.sort(candidates);
        dfs(candidates,0,0,target,new ArrayList&lt;Integer&gt;());

        return result;
    &#125;

    private void dfs(int[] candidates, int start, int sum, int target, List&lt;Integer&gt; path)&#123;
        if(sum == target)&#123;
            result.add(new ArrayList&lt;Integer&gt;(path));
            return;
        &#125;

        if(sum&gt;target)&#123;
            return;
        &#125;

        for(int i=start;i&lt;candidates.length;i++)&#123;

            // 同一层相同元素去重
            if(i != start &amp;&amp; candidates[i] == candidates[i-1])&#123;
                continue;
            &#125;

            sum = sum + candidates[i];
            path.add(candidates[i]);

            dfs(candidates, i+1, sum, target, path);

            sum = sum - candidates[i];
            path.remove(path.size()-1);
        &#125;
    &#125;
</code></pre>
<h4 id="分割问题-1"><a href="#分割问题-1" class="headerlink" title="分割问题"></a>分割问题</h4><p>切割问题其实是一种组合问题</p>
<p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/" >分割回文串<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();
    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;

        dfs(s,0,new ArrayList&lt;String&gt;());
        return result;
    &#125;

    private void dfs(String s, int start, List&lt;String&gt; path)&#123;
        
        if(path.size() &gt;=1 &amp;&amp; !isCycStr(path.get(path.size()-1)))&#123;
            return;
        &#125;

        if(start == s.length())&#123;
            result.add(new ArrayList&lt;String&gt;(path));
            return;
        &#125;

        for(int j=start+1;j&lt;=s.length();j++)&#123;
            String subStr = s.substring(start, j);
            path.add(subStr);
            dfs(s, j, path);
            path.remove(path.size()-1);
        &#125;
        
    &#125;

    private boolean isCycStr(String s)&#123;
        if(s.length() == 1)&#123;
            return true;
        &#125;

        int n = s.length()/2;
        for(int i=0;i&lt;n;i++)&#123;
            if(s.charAt(i) != s.charAt(s.length()-i-1))&#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/" >复原 IP 地址<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;String&gt; result = new ArrayList&lt;&gt;();

    public List&lt;String&gt; restoreIpAddresses(String s) &#123;
        dfs(s, 0, 0, new ArrayList&lt;Integer&gt;());
        return result;
    &#125;

    private void dfs(String s, int end, int k, List&lt;Integer&gt; path)&#123;

        if(k &gt;= 1)&#123;
            int start = path.size() == 1? 0:path.get(path.size()-2);

            String str = s.substring(start, end);
            if(!isValidIp(str))&#123;
                return;
            &#125;

            if(end == s.length() &amp;&amp; k &lt; 4)&#123;
                return;
            &#125;

            if(end == s.length() &amp;&amp; k == 4)&#123;
                StringBuilder sb = new StringBuilder();
                for(int i=0; i&lt;path.size();i++)&#123;
                    if(i==0)&#123;
                        sb = sb.append(s.substring(0, path.get(0)));
                    &#125;else&#123;
                        sb = sb.append(&quot;.&quot;).append(s.substring(path.get(i-1), path.get(i)));
                    &#125;
                &#125;
                result.add(sb.toString());
            &#125;        
        &#125;


        for(int i = end + 1; i&lt;=s.length(); i++)&#123;
            path.add(i);
            k++;
            dfs(s, i, k, path);
            k--;
            path.remove(path.size()-1);
        &#125;
    &#125;

    private boolean isValidIp(String s)&#123;
        
        if(s.length() == 1)&#123;
            return true;
        &#125;

        if(s.length() &gt; 3)&#123;
            return false;
        &#125;

        if(s.charAt(0) == &#39;0&#39;)&#123;
            return false;
        &#125;



        int value = Integer.valueOf(s);
        if(value &gt; 255)&#123;
            return false;
        &#125;

        return true;
    &#125;
</code></pre>
<h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><p>组合和分割问题：记录叶子节点</p>
<p>子集问题：记录所有节点</p>
<p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/" >子集<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;
        dfs(nums, 0, new ArrayList&lt;Integer&gt;());
        return result;
    &#125;

    private void dfs(int[] nums, int start, List&lt;Integer&gt; path)&#123;

        result.add(new ArrayList&lt;Integer&gt;(path));

        for(int i=start; i&lt; nums.length;i++)&#123;
            path.add(nums[i]);
            dfs(nums, i+1, path);
            path.remove(path.size()-1);
        &#125;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/" >子集 II<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>遍历所有节点，同一高度下value相同的节点去重（树枝去重）</p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;
        Arrays.sort(nums);
        dfs(nums, 0, new ArrayList&lt;Integer&gt;());
        return result;
    &#125;

    private void dfs(int[] nums, int start, List&lt;Integer&gt; path)&#123;

        result.add(new ArrayList&lt;Integer&gt;(path));

        for(int i=start; i&lt; nums.length;i++)&#123;
            if(i!=start &amp;&amp; nums[i] == nums[i-1])&#123;
                continue;
            &#125;
            path.add(nums[i]);
            dfs(nums, i+1, path);
            path.remove(path.size()-1);
        &#125;
    &#125; 
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-subsequences/" >递增子序列<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;
        dfs(nums,0,new ArrayList&lt;Integer&gt;(),0);
        return result;
    &#125;

    private void dfs(int[] nums, int start, List&lt;Integer&gt; path, int k)&#123;

        if(k&gt;=2)&#123;
            if(path.get(path.size()-1) &lt; path.get(path.size()-2))&#123;
                return;
            &#125;
            result.add(new ArrayList&lt;Integer&gt;(path));
        &#125;
        
        // 同一层元素去重
        Set&lt;Integer&gt; used = new HashSet&lt;&gt;();
        for(int i=start; i&lt; nums.length;i++)&#123;
            if(used.contains(nums[i]))&#123;
                continue;
            &#125;
            used.add(nums[i]);
            path.add(nums[i]);
            dfs(nums, i+1, path, k+1);
            path.remove(path.size()-1);
        &#125;
    &#125; 
</code></pre>
<h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/" >全排列<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>记录path路径，元素去重</p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); 

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;

        dfs(nums, new ArrayList&lt;Integer&gt;(), new HashSet&lt;&gt;());
        return result;
    &#125;

    private void dfs(int[] nums, List&lt;Integer&gt; path, Set&lt;Integer&gt; used)&#123;

        if(path.size() == nums.length)&#123;
            result.add(new ArrayList&lt;Integer&gt;(path));
            return;
        &#125;

        for(int i=0;i&lt;nums.length;i++)&#123;
            if(used.contains(nums[i]))&#123;
                continue;
            &#125;
            path.add(nums[i]);
            used.add(nums[i]);

            dfs(nums, path, used);
            path.remove(path.size()-1);
            used.remove(nums[i]);
        &#125;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/" >全排列 II<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>path和同一层同时去重</p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); 

    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;
        dfs(nums, new ArrayList&lt;Integer&gt;(), new HashSet&lt;&gt;());
        return result;
    &#125;

    private void dfs(int[] nums, List&lt;Integer&gt; path, Set&lt;Integer&gt; used)&#123;

        if(path.size() == nums.length)&#123;
            result.add(new ArrayList&lt;Integer&gt;(path));
            return;
        &#125;

        Set&lt;Integer&gt; used2 = new HashSet&lt;&gt;();
        for(int i=0;i&lt;nums.length;i++)&#123;
            if(used.contains(i) || used2.contains(nums[i]))&#123;
                continue;
            &#125;
            path.add(nums[i]);
            used.add(i);
            used2.add(nums[i]);


            dfs(nums, path, used);
            path.remove(path.size()-1);
            used.remove(i);
        &#125;
    &#125;
</code></pre>
<h4 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/" >N 皇后<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>private List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();

    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;

       dfs(n, new ArrayList&lt;Integer&gt;());
       return result; 
    &#125;

    private void dfs(int n, List&lt;Integer&gt; queens)&#123;

        if(queens.size() == n)&#123;
            result.add(buildRecord(n, queens));
            return;
        &#125;

        int i = queens.size();
        boolean[][] board = updateBoard(queens, n);
        for(int j=0;j&lt;n;j++)&#123;
            if(board[i][j] == true)&#123;
                continue;
            &#125;
            queens.add(j);
            dfs(n, queens);
            queens.remove(queens.size()-1);
        &#125;
    &#125;

    private boolean[][]  updateBoard(List&lt;Integer&gt; queens, int n)&#123;
        boolean[][] board = new boolean[n][n];
        for(int i=0;i&lt;queens.size();i++)&#123;
            int j = queens.get(i);
            for(int p=0;p&lt;n;p++)&#123;
                for(int q=0;q&lt;n;q++)&#123;
                    if(p==i || q==j || (i-j)==(p-q) || (i+j)==(q+p))&#123;
                        board[p][q] = true;
                    &#125;
                &#125;
            &#125;
        &#125;
        return board;
    &#125;

    private List&lt;String&gt; buildRecord(int n, List&lt;Integer&gt; queens)&#123;
        
        List&lt;String&gt; record = new ArrayList&lt;&gt;();

        for(int i=0;i&lt;queens.size();i++)&#123;
            int queenPosition = queens.get(i);
            StringBuilder sb = new StringBuilder();
            for(int j=0;j&lt;n;j++)&#123;
                if(queenPosition == j)&#123;
                    sb.append(&quot;Q&quot;);
                &#125;else&#123;
                    sb.append(&quot;.&quot;);
                &#125;
            &#125;
            record.add(sb.toString());
        &#125;
        return record;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/" >解数独<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private boolean findResult = false;

    public void solveSudoku(char[][] board) &#123;
         dfs(board, 0);
         int a = 1;
    &#125;

    private void dfs(char[][] board, int positon)&#123;

        if(positon == 9*9 || findResult==true)&#123;
            findResult = true;
            return;
        &#125;

        int m = positon/9;
        int n = positon%9;

        if(board[m][n] != &#39;.&#39;)&#123;
            dfs(board, positon+1);
            return;
        &#125;

        List&lt;Character&gt; choice = findChoice(board, m, n);
        if(choice.size() == 0)&#123;
            return;
        &#125;
        for(int i = 0;i &lt; choice.size(); i++)&#123;
            board[m][n] = choice.get(i);
            dfs(board, positon+1);
            if(findResult == true)&#123;
                return;
            &#125;
            board[m][n] = &#39;.&#39;;
        &#125;
    &#125;

    private List&lt;Character&gt; findChoice(char[][] board, int m, int n)&#123;

        boolean[] used = new boolean[10];

        // m = 3 n = 0 p=1 q=0
        int p = m/3; int q = n/3;
        for(int i = 0 ; i &lt; 9; i++)&#123;
            if(board[m][i] != &#39;.&#39;)&#123;
                used[board[m][i] - &#39;0&#39;] = true;
            &#125;
            if(board[i][n] != &#39;.&#39;)&#123;
                used[board[i][n] - &#39;0&#39;] = true;
            &#125;

            if(board[3*p + i/3][3*q + i%3] != &#39;.&#39;)&#123;
                used[board[3*p + i/3][3*q + i%3] - &#39;0&#39;] = true;
            &#125;
        &#125;

        List&lt;Character&gt; choice = new ArrayList&lt;&gt;();
        for(int i=1 ; i&lt;=9;i++)&#123;
            if(used[i] == false)&#123;
                char b = (char)(i+48);
                choice.add(b);
            &#125;
        &#125;

        return choice;
    &#125;
</code></pre>
<h4 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-maze/" > 迷宫<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public boolean hasPath(int[][] maze, int[] start, int[] destination) &#123;
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];

        visited[start[0]][start[1]] = true;

        dfs(maze, start, visited);

        return visited[destination[0]][destination[1]];
    &#125;

    private void dfs(int[][] maze, int[] start, boolean[][] visited)&#123;

        int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;

        for(int[] dir: dirs)&#123;

            int x= start[0] + dir[0];
            int y =start[1] + dir[1];

            while(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;maze.length &amp;&amp; y&lt;maze[0].length &amp;&amp; maze[x][y] ==0)&#123;
                x = x + dir[0];
                y= y + dir[1];
            &#125;

            if(visited[x-dir[0]][y-dir[1]] == false)&#123;
                visited[x-dir[0]][y-dir[1]] = true;
                dfs(maze, new int[]&#123;x-dir[0], y-dir[1]&#125;, visited);
            &#125;
        &#125;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-maze-ii/" >迷宫 II<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private int result = Integer.MAX_VALUE;

    public int shortestDistance(int[][] maze, int[] start, int[] destination) &#123;
        
        int[][] len = new int[maze.length][maze[0].length];
        for(int i=0;i&lt;maze.length;i++)&#123;
            for(int j=0;j&lt;maze[0].length;j++)&#123;
                len[i][j] = Integer.MAX_VALUE;
            &#125;
        &#125;
        len[start[0]][start[1]] = 0;

        dfs(maze, start, len);

        return len[destination[0]][destination[1]] == Integer.MAX_VALUE? -1:len[destination[0]][destination[1]];
    &#125;

    private void dfs(int[][] maze, int[] position, int[][] len)&#123;

        int m = maze.length;
        int n = maze[0].length;

        int[][] dirs=&#123;&#123;0,1&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;, &#123;1,0&#125;&#125;;

        for(int[] dir : dirs)&#123;
            int x = position[0] + dir[0];
            int y = position[1] + dir[1];
            int curlen=1;
            while(x&gt;=0 &amp;&amp; x &lt;=m-1 &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=n-1 &amp;&amp; maze[x][y] == 0)&#123;
                x = x+ dir[0];
                y = y + dir[1];
                curlen++;
            &#125;
            if(len[position[0]][position[1]] + curlen - 1 &lt; len[x-dir[0]][y-dir[1]])&#123;
                len[x-dir[0]][y-dir[1]] = len[position[0]][position[1]] + curlen - 1;
                dfs(maze, new int[]&#123;x-dir[0], y-dir[1]&#125;, len);
            &#125;
        &#125;

    &#125;
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-maze-iii/" >迷宫 III<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private String result = &quot;impossible&quot;;

    public String findShortestWay(int[][] maze, int[] ball, int[] hole) &#123;
        
        int[][] len = new int[maze.length][maze[0].length];

        for(int i=0;i&lt;maze.length;i++)&#123;
            for(int j=0;j&lt;maze[0].length;j++)&#123;
                len[i][j] = Integer.MAX_VALUE;
            &#125;
        &#125;
        len[ball[0]][ball[1]] = 0;

        dfs(maze, ball, hole, len, new ArrayList&lt;String&gt;());

        return result;
    &#125;

    private void dfs(int[][] maze, int[] ball, int[] hole, int[][] len, List&lt;String&gt; path)&#123;
                        //  d l r u
        int[][] dirs = &#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;
        Map&lt;Integer, String&gt; dirMap = new HashMap&lt;&gt;();
        dirMap.put(0, &quot;d&quot;);dirMap.put(1, &quot;l&quot;);dirMap.put(2, &quot;r&quot;);dirMap.put(3, &quot;u&quot;);

        for(int i=0;i&lt;=3;i++)&#123;
            int[] dir = dirs[i];
            String dirch = dirMap.get(i);

            int x = ball[0] + dir[0];
            int y = ball[1] + dir[1];
            int curlen = 0;

            while(x&gt;=0 &amp;&amp; y &gt;=0 &amp;&amp; x &lt; maze.length &amp;&amp; y&lt;maze[0].length &amp;&amp; maze[x][y]==0)&#123;


                if((x == hole[0] &amp;&amp; y== hole[1]) &amp;&amp; len[ball[0]][ball[1]]+curlen+1&lt;len[x][y])&#123;
                    
                    len[x][y] = len[ball[0]][ball[1]]+curlen+1;

                    StringBuffer sb = new StringBuffer();
                    for(String s : path)&#123;
                        sb = sb.append(s);
                    &#125;
                    sb.append(dirch);
                    result = sb.toString();
                    return;
                &#125;

                x=x+dir[0];
                y=y+dir[1];
                curlen++;
            &#125;

            if(len[ball[0]][ball[1]] + curlen &lt; len[x-dir[0]][y-dir[1]])&#123;
                
                path.add(dirch);
                len[x-dir[0]][y-dir[1]] = len[ball[0]][ball[1]] + curlen;

                if(x-dir[0] == hole[0] &amp;&amp; y-dir[1] == hole[1])&#123;
                    
                    StringBuffer sb = new StringBuffer();
                    for(String s : path)&#123;
                        sb = sb.append(s);
                    &#125;
                    result = sb.toString();
                    return;
                &#125;

                dfs(maze, new int[]&#123;x-dir[0], y-dir[1]&#125;, hole, len, path);
                path.remove(path.size()-1);
            &#125;
        &#125;
    &#125;
</code></pre>
<p><strong>4.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/escape-a-large-maze/" >逃离大迷宫<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>广度优先搜索</p>
<p>队列：Queue 操作：add() poll() peek()</p>
<p>双端队列：Deque 操作: add()  pollFirst() pollLast() peekFirst() peekLast()</p>
<p>抛出队首元素</p>
<pre><code>    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) &#123;

        long EDGE = (int)1e6;

        if(blocked.length&lt;2)&#123;
            return true;
        &#125;
        
        boolean a = bfs(blocked, source, target);
        boolean b = bfs(blocked, target, source);

        return a&amp;&amp;b;
    &#125;

    private boolean bfs(int[][] blocked, int[] source, int[] target)&#123;

        long EDGE = (int)1e6;
        int n = blocked.length;
        int max = (n)*(n-1)/2;

        Set&lt;Long&gt; visited = new HashSet&lt;&gt;();
        visited.add(source[0]*EDGE + source[1]);

        Deque&lt;Long&gt; deque = new ArrayDeque&lt;&gt;();
        deque.add(source[0]*EDGE + source[1]);

        while(!deque.isEmpty() &amp;&amp; visited.size()&lt;=max)&#123;
            long p = deque.pollFirst();
            long x =  p / EDGE;
            long y = p - x*EDGE;

            int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;

            for(int[] dir : dirs)&#123;

                long nx = x + dir[0];
                long ny = y + dir[1];

                if(nx == target[0] &amp;&amp; ny == target[1])&#123;
                    return true;
                &#125;

                if(nx&gt;=0 &amp;&amp; ny&gt;=0 &amp;&amp; nx&lt;EDGE&amp;&amp;ny&lt;EDGE &amp;&amp; notInBlock(nx, ny, blocked) &amp;&amp; visited.contains(nx * EDGE + ny) == false)&#123;

                    visited.add(nx * EDGE + ny);
                    deque.add(nx * EDGE + ny);
                &#125;;
            &#125;
        &#125;
        return visited.size()&gt;max;
    &#125;

  

    private boolean notInBlock(long nx , long ny , int[][] blocked)&#123;


        for(int[] block : blocked)&#123;
            if(block[0] == nx &amp;&amp; block[1] == ny)&#123;
                return false;
            &#125;
        &#125;

        return true;
    &#125;
</code></pre>
<h4 id="二维网格搜索问题"><a href="#二维网格搜索问题" class="headerlink" title="二维网格搜索问题"></a>二维网格搜索问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/detect-cycles-in-2d-grid/" >二维网格图中探测环<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>class Solution &#123;
    public boolean containsCycle(char[][] grid) &#123;

        if(grid.length&lt;=1 || grid[0].length&lt;=1)&#123;
            return false;
        &#125;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        // 环：从任意一个点出发 上下左右移动 能回到原点
        for(int i=0;i&lt;grid.length;i++)&#123;
            for(int j=0;j&lt;grid[0].length;j++)&#123;
                if(visited[i][j] == false)&#123;
                    if(dfs(grid, i,j, grid[i][j], visited,-1,-1))&#123;
                        return true;
                    &#125;
                &#125;
            &#125;
        &#125;

        return false;
    &#125;

    private  boolean dfs(char[][] grid, int x, int y, char ch,  boolean[][] visited, int oldx ,int oldy)&#123;

        if (visited[x][y]) return true;
        visited[x][y] = true;

        int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;
        for(int[] dir : dirs)&#123;

            int curx = x + dir[0];
            int cury =y + dir[1];

            if(curx&gt;=0&amp;&amp;cury&gt;=0&amp;&amp;curx&lt;grid.length&amp;&amp;cury&lt;grid[0].length&amp;&amp;grid[curx][cury]==ch &amp;&amp; (curx!=oldx || cury!=oldy))&#123;
                if(dfs(grid, curx, cury, ch, visited, x,y))&#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h3><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>前中后遍历方式，指的就是中间节点的遍历顺序</p>
<p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" >二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        // 左中右
        dfs(root);
        return result;
    &#125;   

    private void dfs(TreeNode node)&#123;
        if(node == null)&#123;
            return;
        &#125;
        dfs(node.left);
        result.add(node.val);
        dfs(node.right);
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" >二叉树的前序遍历<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        // 中左右
        dfs(root);
        return result;
    &#125;

    private void dfs(TreeNode node)&#123;
        if(node == null)&#123;
            return;
        &#125;
        result.add(node.val);
        dfs(node.left);
        dfs(node.right);
    &#125;
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" >二叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        // 左右中
        dfs(root);
        return result;
    &#125;

    private void dfs(TreeNode node)&#123;
        if(node == null)&#123;
            return;
        &#125;
        dfs(node.left);
        dfs(node.right);
        result.add(node.val);
    &#125;
</code></pre>
<p><strong>4.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" >二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if(root==null)&#123;
            return result;
        &#125;
        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();
        que.offer(root);
        while(que.size()&gt;0)&#123;
            List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;();
            int size = que.size();
            for(int i=0;i&lt;size;i++)&#123;
                TreeNode node = que.poll();
                valueList.add(node.val);
                if(node.left!=null)&#123;
                    que.offer(node.left);
                &#125;
                if(node.right!=null)&#123;
                    que.offer(node.right);
                &#125;
            &#125;
            result.add(valueList);
        &#125;
        return result;
    &#125;
</code></pre>
<p><strong>5.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" >二叉树的层序遍历 II<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;
       List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if(root==null)&#123;
            return result;
        &#125;
        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();
        que.offer(root);
        while(que.size()&gt;0)&#123;
            List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;();
            int size = que.size();
            for(int i=0;i&lt;size;i++)&#123;
                TreeNode node = que.poll();
                valueList.add(node.val);
                if(node.left!=null)&#123;
                    que.offer(node.left);
                &#125;
                if(node.right!=null)&#123;
                    que.offer(node.right);
                &#125;
            &#125;
            result.add(valueList);
        &#125;

        List&lt;List&lt;Integer&gt;&gt; resultNew = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;result.size();i++)&#123;
            resultNew.add(result.get(result.size()-i-1));
        &#125;    
        return resultNew;
    &#125;
</code></pre>
<p><strong>6.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/" >二叉树的右视图<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if(root==null)&#123;
            return result;
        &#125;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(queue.size()&gt;0)&#123;
            int size = queue.size();
            for(int i=0;i&lt;size;i++)&#123;
                TreeNode node = queue.poll();
                if(i==size-1)&#123;
                    result.add(node.val);
                &#125;
                if(node.left!=null)&#123;
                    queue.offer(node.left);
                &#125;
                if(node.right!=null)&#123;
                    queue.offer(node.right);
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
</code></pre>
<p><strong>7.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" >二叉树的层平均值<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;

        List&lt;Double&gt; result = new ArrayList&lt;&gt;();
        if(root==null)&#123;
            return result;
        &#125;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(queue.size()&gt;0)&#123;
            int size = queue.size();
            double sum = 0;
            for(int i=0;i&lt;size;i++)&#123;
                TreeNode node = queue.poll();
                sum = sum + node.val;
                if(node.left!=null)&#123;
                    queue.offer(node.left);
                &#125;
                if(node.right!=null)&#123;
                    queue.offer(node.right);
                &#125;
            &#125;
            result.add(sum/size);
        &#125;
        return result;
    &#125;
</code></pre>
<p><strong>8.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" >N 叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;
        
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if(root==null)&#123;
            return result;
        &#125;
        Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;();
        que.offer(root);
        while(que.size()&gt;0)&#123;
            List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;();
            int size = que.size();
            for(int i=0;i&lt;size;i++)&#123;
                Node node = que.poll();
                valueList.add(node.val);
                if(node.children == null || node.children.size()==0)&#123;
                    continue;
                &#125;
                for(Node childrenNode: node.children)&#123;
                    if(childrenNode!=null)&#123;
                        que.offer(childrenNode);
                    &#125;
                &#125;
            &#125;
            result.add(valueList);
        &#125; 
        return result;
    &#125;
</code></pre>
<p><strong>9.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" >在每个树行中找最大值<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if(root==null)&#123;
            return result;
        &#125;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(queue.size()&gt;0)&#123;
            int size = queue.size();
            int max = Integer.MIN_VALUE;
            for(int i=0;i&lt;size;i++)&#123;
                TreeNode node = queue.poll();
                if(node.val&gt;max)&#123;
                    max = node.val;
                &#125;
                if(node.left!=null)&#123;
                    queue.offer(node.left);
                &#125;
                if(node.right!=null)&#123;
                    queue.offer(node.right);
                &#125;
            &#125;
            result.add(max);
        &#125;
        return result;
    &#125;
</code></pre>
<p><strong>10.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" >填充每个节点的下一个右侧节点指针<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public Node connect(Node root) &#123;
        if(root==null)&#123;
            return root;
        &#125;
        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(queue.size()&gt;0)&#123;
            // 获取size一定要在poll操作前面，因为poll操作是删除并获取一个元素，会导致queue size 变化
            int size = queue.size();
            Node node = queue.poll();
            if(node.left!=null)&#123;
                queue.offer(node.left);
            &#125;
            if(node.right!=null)&#123;
                queue.offer(node.right);
            &#125;
            for(int i=0;i&lt;size-1;i++)&#123;
                Node nodeNext = queue.poll();
                
                if(nodeNext.left!=null)&#123;
                    queue.offer(nodeNext.left);
                &#125;
                if(nodeNext.right!=null)&#123;
                    queue.offer(nodeNext.right);
                &#125;
                node.next = nodeNext;
                node = nodeNext;
            &#125;
        &#125;
        return root;
    &#125;
</code></pre>
<h4 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/" >对称二叉树<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>左子树的右边和右子树的左边比</p>
<p>左子树的左边和右子树的右边比</p>
<pre><code>    public boolean isSymmetric(TreeNode root) &#123;
        if(root == null)&#123;
            return true;
        &#125;
        return compare(root.left, root.right);
    &#125;

    private boolean compare(TreeNode left, TreeNode right)&#123;

        if(left == null &amp;&amp; right == null)&#123;
            return true;
        &#125;

        if(left != null &amp;&amp; right != null)&#123;
            return (right.val==left.val) &amp;&amp; compare(left.right, right.left) &amp;&amp; compare(left.left, right.right);
        &#125;

        return false;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" >二叉树的最大深度<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>深度搜索</p>
<pre><code>    private int result = 0;

    public int maxDepth(TreeNode root) &#123;

        dfs(root, 0);
        return result;
    &#125;

    private void dfs(TreeNode root, int depth)&#123;
        if(root == null)&#123;
            result = Math.max(result, depth);
            return;
        &#125;

        depth++;
        dfs(root.left, depth);
        dfs(root.right, depth);
    &#125;
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" >二叉树的最小深度<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>   private int result = Integer.MAX_VALUE;

    public int minDepth(TreeNode root) &#123;

        if(root == null)&#123;
            return 0;
        &#125;
        dfs(root, 1);
        return result;
    &#125;

    private void dfs(TreeNode root, int depth)&#123;
        if(root.left == null &amp;&amp; root.right == null)&#123;
            result = Math.min(result, depth);
            return;
        &#125;

        if(root.left!=null)&#123;
            dfs(root.left, depth+1);
        &#125;
        if(root.right!=null)&#123;
            dfs(root.right, depth+1);
        &#125;
    &#125;
</code></pre>
<p><strong>4.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/" >完全二叉树的节点个数<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public int countNodes(TreeNode root) &#123;
        return dfs(root);
    &#125;

    private int dfs(TreeNode root)&#123;
        if(root == null)&#123;
            return 0;
        &#125;

        return 1 + dfs(root.left) + dfs(root.right);
    &#125;
</code></pre>
<p><strong>5.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/" >平衡二叉树<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    Map&lt;TreeNode, Integer&gt; depth = new HashMap&lt;&gt;();

    public boolean isBalanced(TreeNode root) &#123;
        if(root == null)&#123;
            return true;
        &#125;

        depth.put(root, calDepth(root));
        
        return isAvg(root);
    &#125;

    private int calDepth(TreeNode root)&#123;
        if(root == null)&#123;
            return 0;
        &#125;

        int leftDepth = 0;
        int rightDepth = 0;
        if(root.left!=null)&#123;
            leftDepth = calDepth(root.left);
            depth.put(root.left, leftDepth);
        &#125;
        if(root.right!=null)&#123;
            rightDepth = calDepth(root.right);
            depth.put(root.right, rightDepth);
        &#125;

        return 1 + Math.max(leftDepth, rightDepth);
    &#125;

    private boolean isAvg(TreeNode root)&#123;

        if(root == null)&#123;
            return true;
        &#125;

        int leftDepth = 0;
        if(root.left != null)&#123;
            leftDepth = depth.get(root.left);
        &#125;

        int rightDepth = 0;
        if(root.right != null)&#123;
            rightDepth = depth.get(root.right);
        &#125;

        return isAvg(root.left) &amp;&amp; isAvg(root.right) &amp;&amp; Math.abs(leftDepth-rightDepth)&lt;=1; 
    &#125;
</code></pre>
<p><strong>6.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/" >二叉树的所有路径<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;String&gt; result = new ArrayList&lt;&gt;();
    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;

        dfs(root, new ArrayList&lt;Integer&gt;());
        return result;
    &#125;

    private void dfs(TreeNode root, List&lt;Integer&gt; path)&#123;
        path.add(root.val);
        if(root.left == null &amp;&amp; root.right == null)&#123;
            StringBuilder sb = new StringBuilder();
            sb.append(String.valueOf(path.get(0)));
            for(int i=1;i&lt;path.size();i++)&#123;
                sb.append(&quot;-&gt;&quot;).append(String.valueOf(path.get(i)));
            &#125;
            result.add(sb.toString());
            return;
        &#125;

        if(root.left!=null)&#123;
            dfs(root.left, path);
            path.remove(path.size()-1);
        &#125;
        
        if(root.right!=null)&#123;
            dfs(root.right, path);
            path.remove(path.size()-1);
        &#125;
    &#125;
</code></pre>
<p><strong>7.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/" > 左叶子之和<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public int sumOfLeftLeaves(TreeNode root) &#123;

        if(root.left == null &amp;&amp; root.right == null)&#123;
            return 0;
        &#125;
        return dfs(root);
    &#125;

    private int dfs(TreeNode root)&#123;
        if(root.left == null &amp;&amp; root.right == null)&#123;
            return root.val;
        &#125;

        int sum = 0;
        if(root.left != null)&#123;
            sum = sum + dfs(root.left);
        &#125;

        if(root.right != null &amp;&amp; (root.right.left!=null || root.right.right!=null))&#123;
            sum = sum + dfs(root.right);
        &#125;

        return sum;
    &#125;
</code></pre>
<p><strong>8.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/" >找树左下角的值<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>同一高度优先用左节点的value</p>
<pre><code>    private int result;
    private int depth=0;
    public int findBottomLeftValue(TreeNode root) &#123;
        dfs(root, 1);
        return result;
    &#125;

    private void dfs(TreeNode root, int curDepth)&#123;
        if(root.left == null &amp;&amp; root.right == null)&#123;
            if(curDepth &gt; depth)&#123;
                result = root.val;
                depth = curDepth;
            &#125;
        &#125;

        if(root.left!=null)&#123;
            dfs(root.left, curDepth+1);
        &#125;
        if(root.right!= null)&#123;
            dfs(root.right, curDepth+1);
        &#125;
    &#125;
</code></pre>
<p><strong>9.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/" >路径总和<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public boolean hasPathSum(TreeNode root, int targetSum) &#123;

        if(root == null)&#123;
            return false;
        &#125;

        return dfs(root, root.val, targetSum);
    &#125;

    private boolean dfs(TreeNode root, int curSum, int targetSum)&#123;
        if(root.left == null &amp;&amp; root.right == null)&#123;
            return curSum==targetSum;
        &#125;

        boolean leftResult = false;
        if(root.left!=null)&#123;
            leftResult = dfs(root.left, curSum+root.left.val, targetSum);
        &#125;
        boolean rightResult = false;
        if(root.right!=null)&#123;
            rightResult = dfs(root.right, curSum+root.right.val, targetSum);
        &#125;

        return leftResult || rightResult;
    &#125;
</code></pre>
<p><strong>10.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/" >路径总和 II<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;

        if(root == null)&#123;
            return result;
        &#125;

        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
        path.add(root.val);
        dfs(root, root.val, targetSum, path);

        return result;
    &#125;

    private void dfs(TreeNode root, int curSum, int targetSum, List&lt;Integer&gt; path)&#123;
        if(root.left == null &amp;&amp; root.right == null)&#123;
            if(curSum==targetSum)&#123;
                result.add(new ArrayList&lt;Integer&gt;(path));
            &#125;
        &#125;
        if(root.left!=null)&#123;
            path.add(root.left.val);
            dfs(root.left, curSum+root.left.val, targetSum, path);
            path.remove(path.size()-1);
        &#125;
        if(root.right!=null)&#123;
            path.add(root.right.val);
            dfs(root.right, curSum+root.right.val, targetSum, path);
            path.remove(path.size()-1);
        &#125;
    &#125;
</code></pre>
<h4 id="二叉树的修改和构造"><a href="#二叉树的修改和构造" class="headerlink" title="二叉树的修改和构造"></a>二叉树的修改和构造</h4><p><strong>1.</strong><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/" > 翻转二叉树<i class="fas fa-external-link-alt"></i></a></p>
<pre><code>    public TreeNode invertTree(TreeNode root) &#123;
        
        if(root == null || (root.left == null &amp;&amp; root.right == null))&#123;
            return root;
        &#125;

        dfs(root);

        return root;
    &#125;

    private void dfs(TreeNode root)&#123;
        if(root.left == null &amp;&amp; root.right == null)&#123;
            return;
        &#125;

        if(root.left != null)&#123;
            dfs(root.left);
        &#125;

        if(root.right != null)&#123;
            dfs(root.right);
        &#125;


        if(root.left != null)&#123;
            TreeNode node = new TreeNode(root.left.val, root.left.left, root.left.right);
            root.left = root.right;
            root.right = node;
        &#125; else &#123;
            TreeNode node = new TreeNode(root.right.val, root.right.left, root.right.right);
            root.right = root.left;
            root.left = node;
        &#125;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" >从中序与后序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;
 
        //inorder 左中右 9 3 15 20 7
        //postorder 左右中 9 15 7 20 3

        return traversal(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1);
    &#125;

    private TreeNode traversal(int[] inorder, int start1, int end1, int[] postorder, int start2, int end2)&#123;

        // 找跟根节点
        int rootVal = postorder[end2];
        TreeNode root = new TreeNode(rootVal);
        if(start2 == end2)&#123;
            return root;
        &#125;

        // 分割inorder 左子树start1到rootPosition-1 右子树rootPosition+1到end1
        int rootPosition=-1;
        for(int i=start1;i&lt;=end1;i++)&#123;
            if(inorder[i] == rootVal)&#123;
                rootPosition = i;
                break;
            &#125;
        &#125;

        //分割postOrder start2到start2+rootPosition-1-start1为左子树   start2+rootPosition-start1到end2-1为右子树  


        //左节点递归
        if(rootPosition-1&gt;= start1)&#123;
            root.left = traversal(inorder, start1, rootPosition-1, postorder, start2, start2+rootPosition-1-start1);
        &#125;


        //右节点递归
        if(rootPosition+1&lt;=end1)&#123;
            root.right = traversal(inorder, rootPosition+1, end1, postorder, start2+rootPosition-start1, end2-1);
        &#125;

        return root;
    &#125;
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        //preorder 中左右 3,9,20,15,7
        //inorder  左中右 9,3,15,20,7

        return traversal(preorder,0,preorder.length-1, inorder, 0, inorder.length-1);
    &#125;

    private TreeNode traversal(int[] preorder, int start1, int end1, int[] inorder, int start2, int end2)&#123;

        // 找根节点
        int rootval = preorder[start1];
        TreeNode root= new TreeNode(rootval);

        if(start1 == end1)&#123;
            return root;
        &#125;

        // 找根节点位置
        int rootPosition = -1;
        for(int i=start2;i&lt;=end2;i++)&#123;
            if(inorder[i] == rootval)&#123;
                rootPosition = i;
                break;
            &#125;
        &#125;

        //分割inorder start2-&gt;rootPosition-1  rootPosition+1-&gt;end2
        //分割preorder  start1+1-&gt; start1+rootPosition-start2  start1+rootPosition-start2+1-&gt;end1

        if(start2&lt;=rootPosition-1)&#123;
            root.left = traversal(preorder, start1+1, start1+rootPosition-start2, inorder, start2,rootPosition-1);
        &#125;

        if(rootPosition+1&lt;=end2)&#123;
            root.right = traversal(preorder, start1+rootPosition-start2+1, end1, inorder,rootPosition+1, end2);
        &#125;

        return root;
    &#125;
</code></pre>
<p><strong>4.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/" >最大二叉树<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;

        return traversal(nums, 0, nums.length-1);
    &#125;

    private TreeNode traversal(int[] nums, int start, int end)&#123;

        int position = -1;
        int maxValue = -1;
        for(int i=start;i&lt;=end;i++)&#123;
            if(nums[i]&gt;=maxValue)&#123;
                position = i;
                maxValue = nums[i];
            &#125;
        &#125;

        TreeNode root = new TreeNode(maxValue);
        if(start==end)&#123;
            return root;
        &#125;

        if(start&lt;=position-1)&#123;
            root.left = traversal(nums, start, position-1);
        &#125;
        if(end&gt;=position+1)&#123;
            root.right = traversal(nums, position+1, end);
        &#125;

        return root;
    &#125;
</code></pre>
<p><strong>5.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/" >合并二叉树<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
        
        if(root1 == null &amp;&amp; root2==null)&#123;
            return null;
        &#125;
        if(root1 == null &amp;&amp; root2 != null)&#123;
            return root2;
        &#125;
        if(root1 != null &amp;&amp; root2 == null)&#123;
            return root1;
        &#125;

        TreeNode root = new TreeNode(root1.val + root2.val);
        root.left = mergeTrees(root1.left, root2.left);
        root.right = mergeTrees(root1.right, root2.right);

        return root;
    &#125;
</code></pre>
<h4 id="二叉搜索树的属性"><a href="#二叉搜索树的属性" class="headerlink" title="二叉搜索树的属性"></a>二叉搜索树的属性</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" >二叉搜索树中的搜索<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode searchBST(TreeNode root, int val) &#123;
        if(root == null)&#123;
            return null;
        &#125;

        if(root.val == val)&#123;
            return root;
        &#125;

        if(root.val &gt; val)&#123;
            return searchBST(root.left, val);
        &#125;

        return searchBST(root.right, val);
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/" >验证二叉搜索树<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>二叉搜索树的中序遍历是递增序列</p>
<pre><code>    private Long max = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) &#123;
        if(root == null)&#123;
            return true;
        &#125;

        boolean left = isValidBST(root.left);

        if(max&lt;root.val)&#123;
            max = Long.valueOf(root.val);
        &#125; else &#123;
            return false;
        &#125;

        boolean right = isValidBST(root.right);

        return left &amp;&amp; right;
    &#125;
&#125;
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" >二叉搜索树的最小绝对差<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>转化为中序遍历的数组，求有序数组的元素差的最小值</p>
<pre><code>    private List&lt;Integer&gt; array = new ArrayList&lt;&gt;();
    public int getMinimumDifference(TreeNode root) &#123;
        traversal(root);
        int result = Integer.MAX_VALUE;
        for(int i=1;i&lt;array.size();i++)&#123;
            if(array.get(i)-array.get(i-1) &lt; result)&#123;
                result = array.get(i)-array.get(i-1);
            &#125;
        &#125;
        return result;
    &#125;

    private void traversal(TreeNode root)&#123;
        if(root == null)&#123;
            return;
        &#125;
        traversal(root.left);
        array.add(root.val);
        traversal(root.right);
    &#125;
</code></pre>
<p><strong>4.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" >二叉搜索树中的众数<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>中序遍历， resultlist 放入当前出现次数最多的元素，每出现一个频率相同的元素，就放入resultlist，若出现一个频率更高的元素，清空resultlist并放入新元素，并更新最大频率</p>
<pre><code>    private ArrayList&lt;Integer&gt; resList = new ArrayList&lt;&gt;();
    int count;
    int maxCount;
    TreeNode pre;

    public int[] findMode(TreeNode root) &#123;

        trasersal(root);
        int[] result = new int[resList.size()];
        for(int i=0;i&lt;resList.size();i++)&#123;
            result[i] = resList.get(i);
        &#125;
        return result;
    &#125;

    private void trasersal(TreeNode root)&#123;

        if(root==null)&#123;
            return;
        &#125;

        trasersal(root.left);

        if(pre == null || root.val != pre.val)&#123;
            count = 1;
        &#125; else &#123;
            count++;
        &#125;

        if(count&gt;maxCount)&#123;
            resList.clear();
            resList.add(root.val);
            maxCount = count;
        &#125; else if(count == maxCount)&#123;
            resList.add(root.val);
        &#125;

        pre = root;

        trasersal(root.right);
    &#125;
</code></pre>
<p><strong>5.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" >把二叉搜索树转换为累加树<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>等同于中序遍历从后往前累加，右中左的方式遍历，sum记录当前累加值</p>
<pre><code>    private int sum = 0;
    public TreeNode convertBST(TreeNode root) &#123;
        
        traversal(root);
        return root;
    &#125;

 
    private void traversal(TreeNode root)&#123;
        if(root == null)&#123;
            return;
        &#125;

        traversal(root.right);

        sum = sum + root.val;
        root.val = sum;
        
        traversal(root.left);
    &#125;
</code></pre>
<h4 id="二叉树的公共祖先问题"><a href="#二叉树的公共祖先问题" class="headerlink" title="二叉树的公共祖先问题"></a>二叉树的公共祖先问题</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" > 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        

        if(root == null || root == p || root == q)&#123;
            return root;
        &#125;

        TreeNode left = lowestCommonAncestor(root.left, p , q);

        TreeNode right = lowestCommonAncestor(root.right,p,q);

        if(left != null &amp;&amp; right != null)&#123;
            return root;
        &#125;

        if(left == null &amp;&amp; right != null)&#123;
            return right;
        &#125;

        return left;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" >二叉搜索树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        
        if(root == null || root == p || root == q)&#123;
            return root;
        &#125;

        if((root.val &gt; p.val &amp;&amp; root.val &lt; q.val) || (root.val &lt; p.val &amp;&amp; root.val &gt; q.val) )&#123;
            return root;
        &#125;

        if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;
            return lowestCommonAncestor(root.right, p, q);
        &#125;        

        return lowestCommonAncestor(root.left, p, q);
    &#125;
</code></pre>
<h4 id="二叉搜索树的构造与修改"><a href="#二叉搜索树的构造与修改" class="headerlink" title="二叉搜索树的构造与修改"></a>二叉搜索树的构造与修改</h4><p><strong>1.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" >二叉搜索树中的插入操作<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode insertIntoBST(TreeNode root, int val) &#123;

        if(root == null)&#123;
            return new TreeNode(val);
        &#125;

        if(root.val &lt; val)&#123;
            root.right = insertIntoBST(root.right, val);
        &#125;

        if(root.val&gt;val)&#123;
            root.left = insertIntoBST(root.left, val);
        &#125;

        return root;
    &#125;
</code></pre>
<p><strong>2.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/" >删除二叉搜索树中的节点<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>public TreeNode deleteNode(TreeNode root, int key) &#123;
        
        if(root == null)&#123;
            return null;
        &#125;

        if(root.val == key)&#123;
            if(root.left == null &amp;&amp; root.right == null)&#123;
                return null;
            &#125;

            if(root.left != null &amp;&amp; root.right == null)&#123;
                return root.left;
            &#125;

            if(root.left == null &amp;&amp; root.right != null)&#123;
                return root.right;
            &#125;

            if(root.left != null &amp;&amp; root.right != null)&#123;
                TreeNode rightMinNode = root.right;
                while(rightMinNode.left != null)&#123;
                    rightMinNode = rightMinNode.left;
                &#125;
                rightMinNode.left = root.left;
                return root.right; 
            &#125;
        &#125;

        if(root.val &lt; key)&#123;
            root.right = deleteNode(root.right, key);
        &#125;

        if(root.val &gt; key)&#123;
            root.left = deleteNode(root.left, key);
        &#125;

        return root;
    &#125;
</code></pre>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/" >修剪二叉搜索树<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>public TreeNode trimBST(TreeNode root, int low, int high) &#123;

        if(root == null)&#123;
            return null;
        &#125;

        if(root.val &gt;= low &amp;&amp; root.val &lt;= high )&#123;
            root.left = trimBST(root.left, low, high);
            root.right =trimBST(root.right, low, high);

            return root;
        &#125;

        if(root.val &gt; high)&#123;
            return trimBST(root.left, low, high);
        &#125;

        if(root.val &lt; low)&#123;
            return trimBST(root.right, low, high);
        &#125;

        return root;
    &#125;
</code></pre>
<p><strong>3.<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" >将有序数组转换为二叉搜索树<i class="fas fa-external-link-alt"></i></a></strong></p>
<pre><code>    public TreeNode sortedArrayToBST(int[] nums) &#123;
        
        return build(nums, 0, nums.length - 1);
    &#125;

    private TreeNode build(int[] nums,int start,int end)&#123;

        if(start == end)&#123;
            return new TreeNode(nums[start]);
        &#125;

        int middle = (start + end) / 2;

        TreeNode root = new TreeNode(nums[middle]);
        if(middle&gt;start)&#123;
            root.left = build(nums, start, middle-1);
        &#125;
        if(middle&lt;end)&#123;
            root.right = build(nums, middle+1, end);
        &#125;

        return root;
    &#125;
</code></pre>
<h3 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a>2.并查集</h3><p>初始化</p>
<pre><code>// 每个人的parent是自己
parent[i] = i;
</code></pre>
<p>找根节点</p>
<pre><code>if(parent[i] == i)&#123;
    return i;
&#125; else &#123;
    return find(parent[i]);
&#125;
</code></pre>
<p>合并</p>
<pre><code>parent[find(i)] = find(j)
</code></pre>
<p>带路径压缩的查找</p>
<pre><code>if(find[i] == i)&#123;
    return i;
&#125; else &#123;
    parent[i] = find(parent[i]);
    return parent[i];
&#125;
</code></pre>
<p>带秩的初始化</p>
<pre><code>parent[i] = i;
rank[i] = 1;
</code></pre>
<p>带秩的合并</p>
<pre><code>//小的往大的上面合并
if(rank[i] &gt; rank[j])&#123;
    parent[j] = i;
&#125;else &#123;
    parent[i] = j;
&#125;
</code></pre>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/09/12/gao-xiao-neng-ren-shi-de-qi-ge-xi-guan/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">高效能人士的七个习惯</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/07/25/di-yi-xing-yuan-li/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">第一性原理</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">jdljun</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="nav-number">1.</span> <span class="nav-text">常用代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">1.自定义排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-number">2.</span> <span class="nav-text">算法思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.1.</span> <span class="nav-text">1.双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">左右指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">2.1.2.</span> <span class="nav-text">快慢指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">2.1.3.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">2.贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.1.</span> <span class="nav-text">区间问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.2.</span> <span class="nav-text">分配问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.3.</span> <span class="nav-text">3.动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.3.1.</span> <span class="nav-text">一维动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.3.2.</span> <span class="nav-text">二维动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.3.</span> <span class="nav-text">分割问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.4.</span> <span class="nav-text">子序列问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.5.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.6.</span> <span class="nav-text">打家劫舍问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.7.</span> <span class="nav-text">买卖股票问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.3.8.</span> <span class="nav-text">状态压缩动态规划</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">4.回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.1.</span> <span class="nav-text">组合问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">分割问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.3.</span> <span class="nav-text">子集问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.4.</span> <span class="nav-text">排列问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.5.</span> <span class="nav-text">棋盘问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.6.</span> <span class="nav-text">迷宫问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.7.</span> <span class="nav-text">二维网格搜索问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">1.二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">二叉树的遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">3.1.2.</span> <span class="nav-text">二叉树的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%9E%84%E9%80%A0"><span class="nav-number">3.1.3.</span> <span class="nav-text">二叉树的修改和构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">3.1.4.</span> <span class="nav-text">二叉搜索树的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.5.</span> <span class="nav-text">二叉树的公共祖先问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="nav-number">3.1.6.</span> <span class="nav-text">二叉搜索树的构造与修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.1.7.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">3.2.</span> <span class="nav-text">2.并查集</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
